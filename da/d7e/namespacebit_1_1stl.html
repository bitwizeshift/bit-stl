<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bit::stl: bit::stl Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">bit::stl
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dd/d9f/namespacebit.html">bit</a></li><li class="navelem"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html">stl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">bit::stl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The standard namespace for this project.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:d4/dc0/namespacebit_1_1stl_1_1casts"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dc0/namespacebit_1_1stl_1_1casts.html">casts</a></td></tr>
<tr class="memdesc:d4/dc0/namespacebit_1_1stl_1_1casts"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline namespace for managing cast utilities. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d3/d66/namespacebit_1_1stl_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d66/namespacebit_1_1stl_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:d3/d66/namespacebit_1_1stl_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private namespace for managing implementation-details within headers. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d7/dd7/namespacebit_1_1stl_1_1enum__ops"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dd7/namespacebit_1_1stl_1_1enum__ops.html">enum_ops</a></td></tr>
<tr class="memdesc:d7/dd7/namespacebit_1_1stl_1_1enum__ops"><td class="mdescLeft">&#160;</td><td class="mdescRight">This namespace introduces bitwise operations to any enums that specialize <code><a class="el" href="../../d7/d4c/structbit_1_1stl_1_1is__enum__bitmask.html" title="Type-trait to determine whether a type is an enum_bitmask. ">is_enum_bitmask</a></code>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:db/de3/namespacebit_1_1stl_1_1literals"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/de3/namespacebit_1_1stl_1_1literals.html">literals</a></td></tr>
<tr class="memdesc:db/de3/namespacebit_1_1stl_1_1literals"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline namespace for managing literal operators. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:d2/d55/structbit_1_1stl_1_1aligned__storage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d2/d55/structbit_1_1stl_1_1aligned__storage">aligned_storage</a></td></tr>
<tr class="memdesc:d2/d55/structbit_1_1stl_1_1aligned__storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the nested type type, which is a PODType suitable for use as uninitialized storage for any object whose size is at most Len and whose alignment requirement is a divisor of Align.  <a href="../../da/d7e/namespacebit_1_1stl.html#d2/d55/structbit_1_1stl_1_1aligned__storage">More...</a><br /></td></tr>
<tr class="separator:d2/d55/structbit_1_1stl_1_1aligned__storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dff/classbit_1_1stl_1_1allocator__deleter.html">allocator_deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deleter for use with standard allocators.  <a href="../../d8/dff/classbit_1_1stl_1_1allocator__deleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d1a/structbit_1_1stl_1_1are__associative__containers.html">are_associative_containers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a series of <code>Types</code> are all Containers.  <a href="../../de/d1a/structbit_1_1stl_1_1are__associative__containers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d31/structbit_1_1stl_1_1are__bidirectional__iterators.html">are_bidirectional_iterators</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a series of <code>Types</code> are all BidirectionalIterators.  <a href="../../d6/d31/structbit_1_1stl_1_1are__bidirectional__iterators.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d1b/structbit_1_1stl_1_1are__containers.html">are_containers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a series of <code>Types</code> are all Containers.  <a href="../../da/d1b/structbit_1_1stl_1_1are__containers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dde/structbit_1_1stl_1_1are__contiguous__containers.html">are_contiguous_containers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a series of <code>Types</code> are all ContiguousContainers.  <a href="../../d5/dde/structbit_1_1stl_1_1are__contiguous__containers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d87/structbit_1_1stl_1_1are__destructible.html">are_destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a series of <code>Types</code> are all Destructibles.  <a href="../../df/d87/structbit_1_1stl_1_1are__destructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d06/structbit_1_1stl_1_1are__equality__comparable.html">are_equality_comparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a series of <code>Types</code> are all EqualityComparable.  <a href="../../d0/d06/structbit_1_1stl_1_1are__equality__comparable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db5/structbit_1_1stl_1_1are__forward__iterators.html">are_forward_iterators</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a series of <code>Types</code> are all ForwardIterators.  <a href="../../df/db5/structbit_1_1stl_1_1are__forward__iterators.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dfa/structbit_1_1stl_1_1are__input__iterators.html">are_input_iterators</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a series of <code>Types</code> are all InputIterators.  <a href="../../d9/dfa/structbit_1_1stl_1_1are__input__iterators.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dd3/structbit_1_1stl_1_1are__iterators.html">are_iterators</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a series of <code>Types</code> are all Iterators.  <a href="../../df/dd3/structbit_1_1stl_1_1are__iterators.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d3c/structbit_1_1stl_1_1are__nullable__pointers.html">are_nullable_pointers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a series of <code>Types</code> are all Containers.  <a href="../../de/d3c/structbit_1_1stl_1_1are__nullable__pointers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d21/structbit_1_1stl_1_1are__random__access__iterators.html">are_random_access_iterators</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a series of <code>Types</code> are all RandomAccessIterators.  <a href="../../d0/d21/structbit_1_1stl_1_1are__random__access__iterators.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d97/structbit_1_1stl_1_1are__ranges.html">are_ranges</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d50/structbit_1_1stl_1_1are__reverse__ranges.html">are_reverse_ranges</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dbf/structbit_1_1stl_1_1are__reversible__containers.html">are_reversible_containers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a series of <code>Types</code> are all ReversibleContainers.  <a href="../../db/dbf/structbit_1_1stl_1_1are__reversible__containers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/df3/structbit_1_1stl_1_1are__same.html">are_same</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine that all types are the same type.  <a href="../../dd/df3/structbit_1_1stl_1_1are__same.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d1f/structbit_1_1stl_1_1are__same_3_01_t_00_01_t_01_4.html">are_same&lt; T, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dcd/structbit_1_1stl_1_1are__same_3_01_t_00_01_t_00_01_ts_8_8_8_01_4.html">are_same&lt; T, T, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dcc/structbit_1_1stl_1_1are__sequence__containers.html">are_sequence_containers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a series of <code>Types</code> are all SequenceContainers.  <a href="../../d1/dcc/structbit_1_1stl_1_1are__sequence__containers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d4/daf/structbit_1_1stl_1_1arity"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d4/daf/structbit_1_1stl_1_1arity">arity</a></td></tr>
<tr class="memdesc:d4/daf/structbit_1_1stl_1_1arity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine the arity of a function.  <a href="../../da/d7e/namespacebit_1_1stl.html#d4/daf/structbit_1_1stl_1_1arity">More...</a><br /></td></tr>
<tr class="separator:d4/daf/structbit_1_1stl_1_1arity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d40/structbit_1_1stl_1_1arity_3_01_fn_01_6_01_4.html">arity&lt; Fn &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/da7/structbit_1_1stl_1_1arity_3_01_fn_01_6_6_01_4.html">arity&lt; Fn &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d47/structbit_1_1stl_1_1arity_3_01_r_07_5_08_07_types_8_8_8_08_4.html">arity&lt; R(*)(Types...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d8c/structbit_1_1stl_1_1arity_3_01_r_07_c_1_1_5_08_07_types_8_8_8_08_01const_01_4.html">arity&lt; R(C::*)(Types...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d14/structbit_1_1stl_1_1arity_3_01_r_07_c_1_1_5_08_07_types_8_8_8_08_01const_01volatile_01_4.html">arity&lt; R(C::*)(Types...) const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dd1/structbit_1_1stl_1_1arity_3_01_r_07_c_1_1_5_08_07_types_8_8_8_08_01volatile_01_4.html">arity&lt; R(C::*)(Types...) volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/da9/structbit_1_1stl_1_1arity_3_01_r_07_c_1_1_5_08_07_types_8_8_8_08_4.html">arity&lt; R(C::*)(Types...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dcf/structbit_1_1stl_1_1arity_3_01_r_07_types_8_8_8_08_01const_01_4.html">arity&lt; R(Types...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d21/structbit_1_1stl_1_1arity_3_01_r_07_types_8_8_8_08_01const_01volatile_01_4.html">arity&lt; R(Types...) const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d07/structbit_1_1stl_1_1arity_3_01_r_07_types_8_8_8_08_01volatile_01_4.html">arity&lt; R(Types...) volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dbb/structbit_1_1stl_1_1arity_3_01_r_07_types_8_8_8_08_4.html">arity&lt; R(Types...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An immutable wrapper around non-owned contiguous data.  <a href="../../da/dcc/classbit_1_1stl_1_1array__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de8/classbit_1_1stl_1_1assertion__failure.html">assertion_failure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown from assertion failures when BIT_COMPILER_EXCEPTIONS_ENABLED is defined.  <a href="../../d5/de8/classbit_1_1stl_1_1assertion__failure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/da0/classbit_1_1stl_1_1bad__enum__cast.html">bad_enum_cast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception of this type is thrown when an enum_cast to a string fails with an invalid serialization, or when an enum value is outside of range of a string.  <a href="../../d5/da0/classbit_1_1stl_1_1bad__enum__cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d2f/classbit_1_1stl_1_1bad__expected__access.html">bad_expected_access</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d2f/structbit_1_1stl_1_1bad__narrow__cast.html">bad_narrow_cast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception for failed narrow_casts.  <a href="../../d0/d2f/structbit_1_1stl_1_1bad__narrow__cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dee/classbit_1_1stl_1_1bad__optional__access.html">bad_optional_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown when an optional is attempted to be accessed while not containing a value.  <a href="../../dc/dee/classbit_1_1stl_1_1bad__optional__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd0/structbit_1_1stl_1_1bad__pointer__cast.html">bad_pointer_cast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception for failed pointer cast.  <a href="../../d3/dd0/structbit_1_1stl_1_1bad__pointer__cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de5/structbit_1_1stl_1_1base__type.html">base_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the base type of T without modifiers.  <a href="../../d7/de5/structbit_1_1stl_1_1base__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d9f/structbit_1_1stl_1_1base__type_3_01_t_01_6_01_4.html">base_type&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/deb/structbit_1_1stl_1_1base__type_3_01_t_01_6_6_01_4.html">base_type&lt; T &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d59/structbit_1_1stl_1_1base__type_3_01_t_01_5_01_4.html">base_type&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html" title="The basic_hashed_string is a wrapper around an owning basic_string with the hash. ...">basic_hashed_string</a> is a wrapper around an owning basic_string with the hash.  <a href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html" title="The basic_hashed_string_view is a compile-time hashed wrapper around a non-owning string (basic_strin...">basic_hashed_string_view</a> is a compile-time hashed wrapper around a non-owning string (<a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html" title="A wrapper around non-owned strings. ">basic_string_view</a>).  <a href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/de7/classbit_1_1stl_1_1basic__string__span.html">basic_string_span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A light-weight non-owning wrapper around strings.  <a href="../../db/de7/classbit_1_1stl_1_1basic__string__span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d50/classbit_1_1stl_1_1basic__string__tokenizer.html">basic_string_tokenizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tokenizer class for strings.  <a href="../../d3/d50/classbit_1_1stl_1_1basic__string__tokenizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around non-owned strings.  <a href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d92/classbit_1_1stl_1_1basic__zstring__span.html">basic_zstring_span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A light-weight non-owning wrapper around strings.  <a href="../../dd/d92/classbit_1_1stl_1_1basic__zstring__span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d16/classbit_1_1stl_1_1basic__zstring__view.html">basic_zstring_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around non-owned zero-terminated strings.  <a href="../../d6/d16/classbit_1_1stl_1_1basic__zstring__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1c/classbit_1_1stl_1_1circular__array.html">circular_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A circular buffer that uses an array for storage.  <a href="../../d8/d1c/classbit_1_1stl_1_1circular__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is an implementation of a non-owning circular buffer.  <a href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d53/classbit_1_1stl_1_1circular__deque.html">circular_deque</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A circular buffer with a deque API.  <a href="../../d8/d53/classbit_1_1stl_1_1circular__deque.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfe/classbit_1_1stl_1_1circular__queue.html">circular_queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A circular buffer with a queue API.  <a href="../../dc/dfe/classbit_1_1stl_1_1circular__queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d8c/classbit_1_1stl_1_1clone__ptr.html">clone_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d1/d8c/classbit_1_1stl_1_1clone__ptr.html" title="clone_ptr is a smart pointer that owns and manages another object through a pointer and disposes of t...">clone_ptr</a> is a smart pointer that owns and manages another object through a pointer and disposes of that object when the <a class="el" href="../../d1/d8c/classbit_1_1stl_1_1clone__ptr.html" title="clone_ptr is a smart pointer that owns and manages another object through a pointer and disposes of t...">clone_ptr</a> goes out of scope  <a href="../../d1/d8c/classbit_1_1stl_1_1clone__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html" title="compressed_pair is a struct template that provides a way to store two heterogeneous objects as a sing...">compressed_pair</a></code> is a <code>struct</code> template that provides a way to store two heterogeneous objects as a single unit that leverages empty-base-optimization  <a href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/df1/classbit_1_1stl_1_1compressed__tuple.html">compressed_tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tuple that leverages EBO to compress types.  <a href="../../d6/df1/classbit_1_1stl_1_1compressed__tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d8/d1f/structbit_1_1stl_1_1conjunction"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d8/d1f/structbit_1_1stl_1_1conjunction">conjunction</a></td></tr>
<tr class="memdesc:d8/d1f/structbit_1_1stl_1_1conjunction"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine the bool_constant from a logical AND operation of other bool_constants.  <a href="../../da/d7e/namespacebit_1_1stl.html#d8/d1f/structbit_1_1stl_1_1conjunction">More...</a><br /></td></tr>
<tr class="separator:d8/d1f/structbit_1_1stl_1_1conjunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d8f/structbit_1_1stl_1_1conjunction_3_01_b1_01_4.html">conjunction&lt; B1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d22/structbit_1_1stl_1_1conjunction_3_01_b1_00_01_bn_8_8_8_01_4.html">conjunction&lt; B1, Bn... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d6/d7e/classbit_1_1stl_1_1delegate"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a></td></tr>
<tr class="memdesc:d6/d7e/classbit_1_1stl_1_1delegate"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is for a lightweight way of managing function callbacks without requiring heap allocations.  <a href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">More...</a><br /></td></tr>
<tr class="separator:d6/d7e/classbit_1_1stl_1_1delegate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de5/classbit_1_1stl_1_1delegate_3_01_r_07_types_8_8_8_08_4.html">delegate&lt; R(Types...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d2e/structbit_1_1stl_1_1disable__if.html">disable_if</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:da/d3e/structbit_1_1stl_1_1disable__if_3_01true_00_01_t_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#da/d3e/structbit_1_1stl_1_1disable__if_3_01true_00_01_t_01_4">disable_if&lt; true, T &gt;</a></td></tr>
<tr class="separator:da/d3e/structbit_1_1stl_1_1disable__if_3_01true_00_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d16/structbit_1_1stl_1_1disjunction.html">disjunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine the <code>bool_constant</code> from a logical OR operations of other bool_constant.  <a href="../../dd/d16/structbit_1_1stl_1_1disjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d02/structbit_1_1stl_1_1disjunction_3_01_b1_01_4.html">disjunction&lt; B1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d63/structbit_1_1stl_1_1disjunction_3_01_b1_00_01_bn_8_8_8_01_4.html">disjunction&lt; B1, Bn... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d20/classbit_1_1stl_1_1dynamic__index__constant.html">dynamic_index_constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A index-constant that can be specified etiher at runtime or compile time.  <a href="../../d5/d20/classbit_1_1stl_1_1dynamic__index__constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1a/classbit_1_1stl_1_1dynamic__index__constant_3_01dynamic__index_00_01_idx_01_4.html">dynamic_index_constant&lt; dynamic_index, Idx &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d72/classbit_1_1stl_1_1dynamic__size__constant.html">dynamic_size_constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A size-constant that can be specified etiher at runtime or compile time.  <a href="../../d5/d72/classbit_1_1stl_1_1dynamic__size__constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d68/classbit_1_1stl_1_1dynamic__size__constant_3_01dynamic__size_00_01_idx_01_4.html">dynamic_size_constant&lt; dynamic_size, Idx &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:db/d9b/structbit_1_1stl_1_1empty"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#db/d9b/structbit_1_1stl_1_1empty">empty</a></td></tr>
<tr class="memdesc:db/d9b/structbit_1_1stl_1_1empty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility metafunction that always expands into an empty struct with no members or type members.  <a href="../../da/d7e/namespacebit_1_1stl.html#db/d9b/structbit_1_1stl_1_1empty">More...</a><br /></td></tr>
<tr class="separator:db/d9b/structbit_1_1stl_1_1empty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d20/structbit_1_1stl_1_1enable__if.html">enable_if</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d1/d68/structbit_1_1stl_1_1enable__if_3_01false_00_01_t_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d1/d68/structbit_1_1stl_1_1enable__if_3_01false_00_01_t_01_4">enable_if&lt; false, T &gt;</a></td></tr>
<tr class="separator:d1/d68/structbit_1_1stl_1_1enable__if_3_01false_00_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d61/structbit_1_1stl_1_1enable__overload__if.html">enable_overload_if</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="../../dc/d20/structbit_1_1stl_1_1enable__if.html">enable_if</a>, but doesn't sfinae-away a type; instead produces an uninstantiable unique type when true.  <a href="../../df/d61/structbit_1_1stl_1_1enable__overload__if.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d8/ddd/structbit_1_1stl_1_1enable__overload__if_3_01false_00_01_t_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d8/ddd/structbit_1_1stl_1_1enable__overload__if_3_01false_00_01_t_01_4">enable_overload_if&lt; false, T &gt;</a></td></tr>
<tr class="separator:d8/ddd/structbit_1_1stl_1_1enable__overload__if_3_01false_00_01_t_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d36/classbit_1_1stl_1_1enum__range.html">enum_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range for enumerable values.  <a href="../../d5/d36/classbit_1_1stl_1_1enum__range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d1b/structbit_1_1stl_1_1enum__traits.html">enum_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits for an enum.  <a href="../../d9/d1b/structbit_1_1stl_1_1enum__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d5a/classbit_1_1stl_1_1expected_3_01void_00_01_e_01_4.html">expected&lt; void, E &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6a/classbit_1_1stl_1_1fat__ptr.html">fat_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fat pointer that contains the pointer and the size.  <a href="../../d9/d6a/classbit_1_1stl_1_1fat__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d1c/classbit_1_1stl_1_1fat__ptr_3_01_t[]_4.html">fat_ptr&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc4/classbit_1_1stl_1_1final__act.html">final_act</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class leverages RAII to perform cleanup actions at the end of a scope.  <a href="../../db/dc4/classbit_1_1stl_1_1final__act.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d2/db4/structbit_1_1stl_1_1function__argument"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d2/db4/structbit_1_1stl_1_1function__argument">function_argument</a></td></tr>
<tr class="memdesc:d2/db4/structbit_1_1stl_1_1function__argument"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to access the <code>Ith</code> argument type of a given function.  <a href="../../da/d7e/namespacebit_1_1stl.html#d2/db4/structbit_1_1stl_1_1function__argument">More...</a><br /></td></tr>
<tr class="separator:d2/db4/structbit_1_1stl_1_1function__argument"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d37/structbit_1_1stl_1_1function__argument_3_01_i_00_01_fn_01_6_01_4.html">function_argument&lt; I, Fn &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc0/structbit_1_1stl_1_1function__argument_3_01_i_00_01_fn_01_6_6_01_4.html">function_argument&lt; I, Fn &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d80/structbit_1_1stl_1_1function__argument_3_01_i_00_01_r_07_5_08_07_types_8_8_8_08_4.html">function_argument&lt; I, R(*)(Types...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d53/structbit_1_1stl_1_1function__argument_3_01_i_00_01_r_07_c_1_1_5_08_07_types_8_8_8_08_01const_01_4.html">function_argument&lt; I, R(C::*)(Types...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d4d/structbit_1_1stl_1_1function__argument_3_01_i_00_01_r_07_c_1_1_5_08_07_types_8_8_8_08_01const_01volatile_01_4.html">function_argument&lt; I, R(C::*)(Types...) const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dc9/structbit_1_1stl_1_1function__argument_3_01_i_00_01_r_07_c_1_1_5_08_07_types_8_8_8_08_01volatile_01_4.html">function_argument&lt; I, R(C::*)(Types...) volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d8a/structbit_1_1stl_1_1function__argument_3_01_i_00_01_r_07_c_1_1_5_08_07_types_8_8_8_08_4.html">function_argument&lt; I, R(C::*)(Types...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d3c/structbit_1_1stl_1_1function__argument_3_01_i_00_01_r_07_types_8_8_8_08_01const_01_4.html">function_argument&lt; I, R(Types...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d64/structbit_1_1stl_1_1function__argument_3_01_i_00_01_r_07_types_8_8_8_08_01const_01volatile_01_4.html">function_argument&lt; I, R(Types...) const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dde/structbit_1_1stl_1_1function__argument_3_01_i_00_01_r_07_types_8_8_8_08_01volatile_01_4.html">function_argument&lt; I, R(Types...) volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d5a/structbit_1_1stl_1_1function__argument_3_01_i_00_01_r_07_types_8_8_8_08_4.html">function_argument&lt; I, R(Types...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:df/d77/structbit_1_1stl_1_1function__signature"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#df/d77/structbit_1_1stl_1_1function__signature">function_signature</a></td></tr>
<tr class="memdesc:df/d77/structbit_1_1stl_1_1function__signature"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction to extract the signature of a given function type.  <a href="../../da/d7e/namespacebit_1_1stl.html#df/d77/structbit_1_1stl_1_1function__signature">More...</a><br /></td></tr>
<tr class="separator:df/d77/structbit_1_1stl_1_1function__signature"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/df7/structbit_1_1stl_1_1function__signature_3_01_fn_01_6_01_4.html">function_signature&lt; Fn &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dcc/structbit_1_1stl_1_1function__signature_3_01_fn_01_6_6_01_4.html">function_signature&lt; Fn &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d54/structbit_1_1stl_1_1function__signature_3_01_fn_01_5_01_4.html">function_signature&lt; Fn * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dc6/structbit_1_1stl_1_1function__signature_3_01_r_07_arg_types_8_8_8_08_01const_01_4.html">function_signature&lt; R(ArgTypes...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d40/structbit_1_1stl_1_1function__signature_3_01_r_07_arg_types_8_8_8_08_01const_01volatile_01_4.html">function_signature&lt; R(ArgTypes...) const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/daf/structbit_1_1stl_1_1function__signature_3_01_r_07_arg_types_8_8_8_08_01volatile_01_4.html">function_signature&lt; R(ArgTypes...) volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dcb/structbit_1_1stl_1_1function__signature_3_01_r_07_arg_types_8_8_8_08_4.html">function_signature&lt; R(ArgTypes...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d98/structbit_1_1stl_1_1function__signature_3_01_r_07_c_1_1_5_08_07_arg_types_8_8_8_08_01const_01_4.html">function_signature&lt; R(C::*)(ArgTypes...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/de5/structbit_1_1stl_1_1function__signature_3_01_r_07_c_1_1_5_08_07_arg_types_8_8_8_08_01const_01volatile_01_4.html">function_signature&lt; R(C::*)(ArgTypes...) const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d7b/structbit_1_1stl_1_1function__signature_3_01_r_07_c_1_1_5_08_07_arg_types_8_8_8_08_01volatile_01_4.html">function_signature&lt; R(C::*)(ArgTypes...) volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de3/structbit_1_1stl_1_1function__signature_3_01_r_07_c_1_1_5_08_07_arg_types_8_8_8_08_4.html">function_signature&lt; R(C::*)(ArgTypes...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/deb/structbit_1_1stl_1_1hash.html">hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash struct that satisfies the requirements of <code>std::hash</code>, but is implemented in terms of hash_value to allow for easy ADL overloads and type-querying.  <a href="../../dd/deb/structbit_1_1stl_1_1hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d46/structbit_1_1stl_1_1identity.html">identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This simple type is used to add '::type' to any transformation type-traits.  <a href="../../df/d46/structbit_1_1stl_1_1identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d17/structbit_1_1stl_1_1in__place__index__t.html">in_place_index_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is a special disambiguation tag for variadic functions, used in any and optional.  <a href="../../dc/d17/structbit_1_1stl_1_1in__place__index__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d6c/structbit_1_1stl_1_1in__place__t.html">in_place_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is a special disambiguation tag for variadic functions, used in any and optional.  <a href="../../d2/d6c/structbit_1_1stl_1_1in__place__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d31/structbit_1_1stl_1_1in__place__type__t.html">in_place_type_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is a special disambiguation tag for variadic functions, used in any and optional.  <a href="../../d6/d31/structbit_1_1stl_1_1in__place__type__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dd0/structbit_1_1stl_1_1index__of__type.html">index_of_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine the index of <code>T</code> in the variadic pack <code>Types</code>.  <a href="../../d0/dd0/structbit_1_1stl_1_1index__of__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d40/structbit_1_1stl_1_1insensitive__char__traits.html">insensitive_char_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Char traits to allow case-insensitive comparisons for strings.  <a href="../../da/d40/structbit_1_1stl_1_1insensitive__char__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d82/structbit_1_1stl_1_1invoke__result.html">invoke_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d92/structbit_1_1stl_1_1is__associative__container.html">is_associative_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given type is a AssociativeContainer.  <a href="../../d1/d92/structbit_1_1stl_1_1is__associative__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dfd/structbit_1_1stl_1_1is__base__of__all.html">is_base_of_all</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine that <code>Base</code> is the base of all <code>Derived</code>.  <a href="../../d1/dfd/structbit_1_1stl_1_1is__base__of__all.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d99/structbit_1_1stl_1_1is__base__of__any.html">is_base_of_any</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine that <code>Base</code> is the base of any <code>Derived</code>.  <a href="../../dc/d99/structbit_1_1stl_1_1is__base__of__any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db3/structbit_1_1stl_1_1is__bidirectional__iterator.html">is_bidirectional_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given type is a BidirectionalIterator.  <a href="../../dd/db3/structbit_1_1stl_1_1is__bidirectional__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc2/structbit_1_1stl_1_1is__bool__constant.html">is_bool_constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility metafunction that determines whether <code>T</code> is a size_constant.  <a href="../../db/dc2/structbit_1_1stl_1_1is__bool__constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/deb/structbit_1_1stl_1_1is__bool__constant_3_01bool__constant_3_01_b_01_4_01_4.html">is_bool_constant&lt; bool_constant&lt; B &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7e/structbit_1_1stl_1_1is__const__member__function__pointer.html">is_const_member_function_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine if <code>Func</code> is a const member function pointer.  <a href="../../dc/d7e/structbit_1_1stl_1_1is__const__member__function__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dea/structbit_1_1stl_1_1is__const__member__function__pointer_3_01_r_07_c_1_1_5_08_07_args_8_8_8_08_01const_01_4.html">is_const_member_function_pointer&lt; R(C::*)(Args...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dca/structbit_1_1stl_1_1is__const__member__function__pointer_3_01_r_07_c_1_1_5_08_07_args_8_8_8_08_01const_01volatile_01_4.html">is_const_member_function_pointer&lt; R(C::*)(Args...) const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d71/structbit_1_1stl_1_1is__container.html">is_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given type is a Container.  <a href="../../d1/d71/structbit_1_1stl_1_1is__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddd/structbit_1_1stl_1_1is__contiguous__container.html">is_contiguous_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given type is a ContiguousContainer.  <a href="../../dd/ddd/structbit_1_1stl_1_1is__contiguous__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d1d/structbit_1_1stl_1_1is__cv__member__function__pointer.html">is_cv_member_function_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine if <code>Func</code> is a const volatile member function pointer.  <a href="../../dd/d1d/structbit_1_1stl_1_1is__cv__member__function__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d7e/structbit_1_1stl_1_1is__cv__member__function__pointer_3_01_r_07_c_1_1_5_08_07_args_8_8_8_08_01const_01volatile_01_4.html">is_cv_member_function_pointer&lt; R(C::*)(Args...) const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d5f/structbit_1_1stl_1_1is__derived__from__all.html">is_derived_from_all</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine that <code>Derived</code> is derived from all <code>Bases</code>.  <a href="../../d8/d5f/structbit_1_1stl_1_1is__derived__from__all.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dad/structbit_1_1stl_1_1is__derived__from__any.html">is_derived_from_any</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine that <code>Derived</code> is derived from any <code>Bases</code>.  <a href="../../da/dad/structbit_1_1stl_1_1is__derived__from__any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d56/structbit_1_1stl_1_1is__destructible.html">is_destructible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given type is Destructible.  <a href="../../d5/d56/structbit_1_1stl_1_1is__destructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d20/structbit_1_1stl_1_1is__dynamic__span.html">is_dynamic_span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the given type a dynamic span?  <a href="../../d6/d20/structbit_1_1stl_1_1is__dynamic__span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d5b/structbit_1_1stl_1_1is__dynamic__span_3_01span_3_01_t_00_01dynamic__extent_01_4_01_4.html">is_dynamic_span&lt; span&lt; T, dynamic_extent &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d4c/structbit_1_1stl_1_1is__enum__bitmask.html">is_enum_bitmask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine whether a type is an enum_bitmask.  <a href="../../d7/d4c/structbit_1_1stl_1_1is__enum__bitmask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d4e/structbit_1_1stl_1_1is__equality__comparable.html">is_equality_comparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given type is a EqualityComparable.  <a href="../../d2/d4e/structbit_1_1stl_1_1is__equality__comparable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d38/structbit_1_1stl_1_1is__explicitly__convertible.html">is_explicitly_convertible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine if <code>From</code> is explicitly convertible to <code>to</code>.  <a href="../../d6/d38/structbit_1_1stl_1_1is__explicitly__convertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6e/structbit_1_1stl_1_1is__forward__iterator.html">is_forward_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd8/structbit_1_1stl_1_1is__in__place.html">is_in_place</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine if the type is an in_place type.  <a href="../../d9/dd8/structbit_1_1stl_1_1is__in__place.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d33/structbit_1_1stl_1_1is__in__place_3_01in__place__index__t_3_01_i_01_4_01_4.html">is_in_place&lt; in_place_index_t&lt; I &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dc3/structbit_1_1stl_1_1is__in__place_3_01in__place__t_01_4.html">is_in_place&lt; in_place_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/structbit_1_1stl_1_1is__in__place_3_01in__place__type__t_3_01_t_01_4_01_4.html">is_in_place&lt; in_place_type_t&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dea/structbit_1_1stl_1_1is__input__iterator.html">is_input_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given type is an InputIterator.  <a href="../../d8/dea/structbit_1_1stl_1_1is__input__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d5b/structbit_1_1stl_1_1is__iterator.html">is_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given type is an Iterator.  <a href="../../d4/d5b/structbit_1_1stl_1_1is__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfe/structbit_1_1stl_1_1is__nullable__pointer.html">is_nullable_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given type is a Container.  <a href="../../d2/dfe/structbit_1_1stl_1_1is__nullable__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d3/dcc/structbit_1_1stl_1_1is__one__of"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d3/dcc/structbit_1_1stl_1_1is__one__of">is_one_of</a></td></tr>
<tr class="memdesc:d3/dcc/structbit_1_1stl_1_1is__one__of"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine if <code>T</code> is one of <code>Ts</code>.  <a href="../../da/d7e/namespacebit_1_1stl.html#d3/dcc/structbit_1_1stl_1_1is__one__of">More...</a><br /></td></tr>
<tr class="separator:d3/dcc/structbit_1_1stl_1_1is__one__of"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/db6/structbit_1_1stl_1_1is__one__of_3_01_t_01_4.html">is_one_of&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d95/structbit_1_1stl_1_1is__one__of_3_01_t_00_01_t_00_01_ts_8_8_8_01_4.html">is_one_of&lt; T, T, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/df4/structbit_1_1stl_1_1is__one__of_3_01_t_00_01_t0_00_01_ts_8_8_8_01_4.html">is_one_of&lt; T, T0, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d9f/structbit_1_1stl_1_1is__random__access__iterator.html">is_random_access_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given type is a RandomAccessIterator.  <a href="../../d1/d9f/structbit_1_1stl_1_1is__random__access__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d69/structbit_1_1stl_1_1is__range.html">is_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dcd/structbit_1_1stl_1_1is__reverse__range.html">is_reverse_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dce/structbit_1_1stl_1_1is__reversible__container.html">is_reversible_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given type is a ReversibleContainer.  <a href="../../d3/dce/structbit_1_1stl_1_1is__reversible__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d80/structbit_1_1stl_1_1is__same__constness.html">is_same_constness</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine if <code>T</code> and <code>U</code> have the same const- qualification.  <a href="../../d3/d80/structbit_1_1stl_1_1is__same__constness.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d22/structbit_1_1stl_1_1is__same__cv.html">is_same_cv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine if <code>T</code> and <code>U</code> have the same cv- qualification.  <a href="../../db/d22/structbit_1_1stl_1_1is__same__cv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dee/structbit_1_1stl_1_1is__same__sign.html">is_same_sign</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine if <code>T</code> and <code>U</code> have the same sign.  <a href="../../d0/dee/structbit_1_1stl_1_1is__same__sign.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/db3/structbit_1_1stl_1_1is__same__volatility.html">is_same_volatility</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine if <code>T</code> and <code>U</code> have the same volatile- qualification.  <a href="../../d9/db3/structbit_1_1stl_1_1is__same__volatility.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d09/structbit_1_1stl_1_1is__sequence__container.html">is_sequence_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a given type is a SequenceContainer.  <a href="../../dd/d09/structbit_1_1stl_1_1is__sequence__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dc1/structbit_1_1stl_1_1is__size__constant.html">is_size_constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility metafunction that determines whether <code>T</code> is a size_constant.  <a href="../../d0/dc1/structbit_1_1stl_1_1is__size__constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/ded/structbit_1_1stl_1_1is__size__constant_3_01size__constant_3_01_size_01_4_01_4.html">is_size_constant&lt; size_constant&lt; Size &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dc9/structbit_1_1stl_1_1is__span.html">is_span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the given type a span ?  <a href="../../d3/dc9/structbit_1_1stl_1_1is__span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d34/structbit_1_1stl_1_1is__span_3_01span_3_01_t_00_01_n_01_4_01_4.html">is_span&lt; span&lt; T, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d0a/structbit_1_1stl_1_1is__volatile__member__function__pointer.html">is_volatile_member_function_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine if <code>Func</code> is a volatile member function pointer.  <a href="../../d9/d0a/structbit_1_1stl_1_1is__volatile__member__function__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d42/structbit_1_1stl_1_1is__volatile__member__function__pointer_3_01_r_07_c_1_1_5_08_07_args_8_8_8_08_01const_01volatile_01_4.html">is_volatile_member_function_pointer&lt; R(C::*)(Args...) const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dc3/structbit_1_1stl_1_1is__volatile__member__function__pointer_3_01_r_07_c_1_1_5_08_07_args_8_8_8_08_01volatile_01_4.html">is_volatile_member_function_pointer&lt; R(C::*)(Args...) volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazy class used for lazy-loading any type.  <a href="../../d0/dbb/classbit_1_1stl_1_1lazy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d23/classbit_1_1stl_1_1map__view.html">map_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight, non-owning wrapper around map operations.  <a href="../../d5/d23/classbit_1_1stl_1_1map__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d6/db2/structbit_1_1stl_1_1monostate"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/db2/structbit_1_1stl_1_1monostate">monostate</a></td></tr>
<tr class="memdesc:d6/db2/structbit_1_1stl_1_1monostate"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit type intended for use as a well-behaved empty alternative in <code>variant</code>.  <a href="../../da/d7e/namespacebit_1_1stl.html#d6/db2/structbit_1_1stl_1_1monostate">More...</a><br /></td></tr>
<tr class="separator:d6/db2/structbit_1_1stl_1_1monostate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dac/structbit_1_1stl_1_1negation.html">negation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility metafunction for negating a bool_constant.  <a href="../../d7/dac/structbit_1_1stl_1_1negation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d64/structbit_1_1stl_1_1nonesuch.html">nonesuch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility type for the detected_t idiom.  <a href="../../dc/d64/structbit_1_1stl_1_1nonesuch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d9/d75/structbit_1_1stl_1_1normalize__char"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d9/d75/structbit_1_1stl_1_1normalize__char">normalize_char</a></td></tr>
<tr class="memdesc:d9/d75/structbit_1_1stl_1_1normalize__char"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes character types T to non-signed/unsigned character types.  <a href="../../da/d7e/namespacebit_1_1stl.html#d9/d75/structbit_1_1stl_1_1normalize__char">More...</a><br /></td></tr>
<tr class="separator:d9/d75/structbit_1_1stl_1_1normalize__char"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d30/structbit_1_1stl_1_1normalize__char_3_01char_01_4.html">normalize_char&lt; char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d07/structbit_1_1stl_1_1normalize__char_3_01signed_01char_01_4.html">normalize_char&lt; signed char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d9f/structbit_1_1stl_1_1normalize__char_3_01unsigned_01char_01_4.html">normalize_char&lt; unsigned char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d2/d69/structbit_1_1stl_1_1nth__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d2/d69/structbit_1_1stl_1_1nth__type">nth_type</a></td></tr>
<tr class="memdesc:d2/d69/structbit_1_1stl_1_1nth__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait for extracting the <code>Ith</code> type from a variadic pack.  <a href="../../da/d7e/namespacebit_1_1stl.html#d2/d69/structbit_1_1stl_1_1nth__type">More...</a><br /></td></tr>
<tr class="separator:d2/d69/structbit_1_1stl_1_1nth__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d51/structbit_1_1stl_1_1nth__type_3_010_00_01_type0_00_01_types_8_8_8_01_4.html">nth_type&lt; 0, Type0, Types... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dab/structbit_1_1stl_1_1nth__type_3_01_i_00_01_type0_00_01_types_8_8_8_01_4.html">nth_type&lt; I, Type0, Types... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type represents null optional value.  <a href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight wrapper around a pointer type.  <a href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An offset pointer based on boost::offset_ptr.  <a href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template optional manages an optional contained value, i.e. a value that may or may not be present.  <a href="../../d0/d1d/classbit_1_1stl_1_1optional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dde/classbit_1_1stl_1_1pointer__wrapper.html">pointer_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper type around a given type that allows it to be treated with pointer-semantics instead of reference-semantics.  <a href="../../d6/dde/classbit_1_1stl_1_1pointer__wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d6a/classbit_1_1stl_1_1propagate__const.html">propagate_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper to propagate the const qualifier.  <a href="../../d6/d6a/classbit_1_1stl_1_1propagate__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d68/classbit_1_1stl_1_1range.html">range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a range from a given Container.  <a href="../../d9/d68/classbit_1_1stl_1_1range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/df3/structbit_1_1stl_1_1remove__pointers.html">remove_pointers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all pointers from a given type.  <a href="../../df/df3/structbit_1_1stl_1_1remove__pointers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d69/structbit_1_1stl_1_1remove__pointers_3_01_t_01_5_01_4.html">remove_pointers&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d72/structbit_1_1stl_1_1remove__pointers_3_01_t_01_5const_01_4.html">remove_pointers&lt; T *const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d84/structbit_1_1stl_1_1remove__pointers_3_01_t_01_5const_01volatile_01_4.html">remove_pointers&lt; T *const volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/df8/structbit_1_1stl_1_1remove__pointers_3_01_t_01_5volatile_01_4.html">remove_pointers&lt; T *volatile &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d33/structbit_1_1stl_1_1resolves__overload__index.html">resolves_overload_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction to determine the index of the type that would be resolved if presented with Types... simultaneous overloads, and presented with <code>T</code>.  <a href="../../dd/d33/structbit_1_1stl_1_1resolves__overload__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d53/structbit_1_1stl_1_1resolves__overload__type.html">resolves_overload_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction to determine the type that would be resolved if presented with Types... simultaneous overloads, and presented with <code>T</code>.  <a href="../../d1/d53/structbit_1_1stl_1_1resolves__overload__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer that lives as long as the current scope.  <a href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d2e/classbit_1_1stl_1_1scoped__ptr_3_01_t[]_00_01_deleter_01_4.html">scoped_ptr&lt; T[], Deleter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d95/classbit_1_1stl_1_1set__view.html">set_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight, non-owning wrapper around set operations.  <a href="../../d0/d95/classbit_1_1stl_1_1set__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d5/d60/structbit_1_1stl_1_1sfinae__base"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d5/d60/structbit_1_1stl_1_1sfinae__base">sfinae_base</a></td></tr>
<tr class="memdesc:d5/d60/structbit_1_1stl_1_1sfinae__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for sfinae types.  <a href="../../da/d7e/namespacebit_1_1stl.html#d5/d60/structbit_1_1stl_1_1sfinae__base">More...</a><br /></td></tr>
<tr class="separator:d5/d60/structbit_1_1stl_1_1sfinae__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html">source_location</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Source location is a small, immutable type used for representing where retrieving information about where this type is constructed.  <a href="../../d6/d2f/classbit_1_1stl_1_1source__location.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A light-weight non-owning wrapper around contiguous memory.  <a href="../../d5/d30/classbit_1_1stl_1_1span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d61/structbit_1_1stl_1_1static__divisible__by__range.html">static_divisible_by_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/ddd/structbit_1_1stl_1_1static__divisible__by__range_3_01v_00_01b_00_01b_01_4.html">static_divisible_by_range&lt; v, b, b &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d49/structbit_1_1stl_1_1static__gcd.html">static_gcd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the greatest common denominator of <code>a</code> and <code>b</code> The result is aliased as <em>static_gcd::value</em>.  <a href="../../de/d49/structbit_1_1stl_1_1static__gcd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da4/structbit_1_1stl_1_1static__gcd_3_010_00_01b_01_4.html">static_gcd&lt; 0, b &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d72/structbit_1_1stl_1_1static__is__prime.html">static_is_prime</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/db3/structbit_1_1stl_1_1static__is__prime_3_010_01_4.html">static_is_prime&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dce/structbit_1_1stl_1_1static__is__prime_3_011_01_4.html">static_is_prime&lt; 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc9/structbit_1_1stl_1_1static__is__prime_3_012_01_4.html">static_is_prime&lt; 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d54/structbit_1_1stl_1_1static__lcm.html">static_lcm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de7/structbit_1_1stl_1_1static__square__sum__of__range.html">static_square_sum_of_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dde/structbit_1_1stl_1_1static__sum__of__range.html">static_sum_of_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d83/classbit_1_1stl_1_1tagged__iterator.html">tagged_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thin wrapper around a different iterator type to add uniqueness.  <a href="../../dc/d83/classbit_1_1stl_1_1tagged__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a 3-state boolean type that introduces 'indeterminate' as the third state.  <a href="../../d0/dc9/classbit_1_1stl_1_1tribool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d0e/structbit_1_1stl_1_1tuple__element_3_010_00_01compressed__pair_3_01_t_00_01_u_01_4_01_4.html">tuple_element&lt; 0, compressed_pair&lt; T, U &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d56/structbit_1_1stl_1_1tuple__element_3_011_00_01compressed__pair_3_01_t_00_01_u_01_4_01_4.html">tuple_element&lt; 1, compressed_pair&lt; T, U &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d82/structbit_1_1stl_1_1tuple__element_3_01_i_00_01compressed__tuple_3_01_types_8_8_8_01_4_01_4.html">tuple_element&lt; I, compressed_tuple&lt; Types... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d9c/classbit_1_1stl_1_1tuple__element__iterator.html">tuple_element_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dcd/structbit_1_1stl_1_1tuple__size_3_01compressed__pair_3_01_t_00_01_u_01_4_01_4.html">tuple_size&lt; compressed_pair&lt; T, U &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d9a/structbit_1_1stl_1_1tuple__size_3_01compressed__tuple_3_01_types_8_8_8_01_4_01_4.html">tuple_size&lt; compressed_tuple&lt; Types... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dd/d73/classbit_1_1stl_1_1underlying__container__type"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#dd/d73/classbit_1_1stl_1_1underlying__container__type">underlying_container_type</a></td></tr>
<tr class="separator:dd/d73/classbit_1_1stl_1_1underlying__container__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d19/structbit_1_1stl_1_1unexpect__t.html">unexpect_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag type used for tag-dispatch.  <a href="../../d1/d19/structbit_1_1stl_1_1unexpect__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type representing an unexpected value coming from an expected type.  <a href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper type to represent universally unique identifiers.  <a href="../../d5/d75/classbit_1_1stl_1_1uuid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dc5/classbit_1_1stl_1_1zip__iterator.html">zip_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator used for zipping multiple iterator ranges together into a single iterator.  <a href="../../d3/dc5/classbit_1_1stl_1_1zip__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a02537ee2880264a40fcfe4f16f73db9a"><td class="memItemLeft" align="right" valign="top"><a id="a02537ee2880264a40fcfe4f16f73db9a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hashed_string</b> = <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; char &gt;</td></tr>
<tr class="separator:a02537ee2880264a40fcfe4f16f73db9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c8fdf0a72af9c6366a44d80b07df71"><td class="memItemLeft" align="right" valign="top"><a id="a27c8fdf0a72af9c6366a44d80b07df71"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hashed_wstring</b> = <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; wchar_t &gt;</td></tr>
<tr class="separator:a27c8fdf0a72af9c6366a44d80b07df71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b943df91261c5c3996892fd07c4a13e"><td class="memItemLeft" align="right" valign="top"><a id="a1b943df91261c5c3996892fd07c4a13e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hashed_u16string</b> = <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; char16_t &gt;</td></tr>
<tr class="separator:a1b943df91261c5c3996892fd07c4a13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3229d87da205f5801832a22dc755b6b"><td class="memItemLeft" align="right" valign="top"><a id="ad3229d87da205f5801832a22dc755b6b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hashed_u32string</b> = <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; char32_t &gt;</td></tr>
<tr class="separator:ad3229d87da205f5801832a22dc755b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ea9e337581daaeb1764a7d34843c37"><td class="memItemLeft" align="right" valign="top"><a id="ad8ea9e337581daaeb1764a7d34843c37"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hashed_string_view</b> = <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; char &gt;</td></tr>
<tr class="separator:ad8ea9e337581daaeb1764a7d34843c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f13560e63d464a61be82ed3ac4d43c"><td class="memItemLeft" align="right" valign="top"><a id="ab3f13560e63d464a61be82ed3ac4d43c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hashed_wstring_view</b> = <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; wchar_t &gt;</td></tr>
<tr class="separator:ab3f13560e63d464a61be82ed3ac4d43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3286dae509aed68b4fe03ad6c6b9a24d"><td class="memItemLeft" align="right" valign="top"><a id="a3286dae509aed68b4fe03ad6c6b9a24d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hashed_u16string_view</b> = <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; char16_t &gt;</td></tr>
<tr class="separator:a3286dae509aed68b4fe03ad6c6b9a24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dceab8b6638fba97f238aac1fb661ca"><td class="memItemLeft" align="right" valign="top"><a id="a4dceab8b6638fba97f238aac1fb661ca"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hashed_u32string_view</b> = <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; char32_t &gt;</td></tr>
<tr class="separator:a4dceab8b6638fba97f238aac1fb661ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c03e112949198a99d50289dce7e6f2"><td class="memTemplParams" colspan="2"><a id="ab0c03e112949198a99d50289dce7e6f2"></a>
template&lt;typename CharT , typename Traits  = std::char_traits&lt;CharT&gt;, std::ptrdiff_t Extent = dynamic_extent&gt; </td></tr>
<tr class="memitem:ab0c03e112949198a99d50289dce7e6f2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>basic_zstring</b> = CharT *</td></tr>
<tr class="separator:ab0c03e112949198a99d50289dce7e6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943ce8a1e29d97ef545e410faaabd3a7"><td class="memTemplParams" colspan="2"><a id="a943ce8a1e29d97ef545e410faaabd3a7"></a>
template&lt;std::ptrdiff_t Extent = dynamic_extent&gt; </td></tr>
<tr class="memitem:a943ce8a1e29d97ef545e410faaabd3a7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>zstring</b> = basic_zstring&lt; char, std::char_traits&lt; char &gt;, Extent &gt;</td></tr>
<tr class="separator:a943ce8a1e29d97ef545e410faaabd3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ec786edb78723ca95eff416f7d18df"><td class="memTemplParams" colspan="2"><a id="a55ec786edb78723ca95eff416f7d18df"></a>
template&lt;std::ptrdiff_t Extent = dynamic_extent&gt; </td></tr>
<tr class="memitem:a55ec786edb78723ca95eff416f7d18df"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>wzstring</b> = basic_zstring&lt; wchar_t, std::char_traits&lt; wchar_t &gt;, Extent &gt;</td></tr>
<tr class="separator:a55ec786edb78723ca95eff416f7d18df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11e99f138a22e53a2c41a452bf9c23f"><td class="memTemplParams" colspan="2"><a id="ad11e99f138a22e53a2c41a452bf9c23f"></a>
template&lt;std::ptrdiff_t Extent = dynamic_extent&gt; </td></tr>
<tr class="memitem:ad11e99f138a22e53a2c41a452bf9c23f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>u16zstring</b> = basic_zstring&lt; char16_t, std::char_traits&lt; char16_t &gt;, Extent &gt;</td></tr>
<tr class="separator:ad11e99f138a22e53a2c41a452bf9c23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa895dd575730723851c77eb2981ad60e"><td class="memTemplParams" colspan="2"><a id="aa895dd575730723851c77eb2981ad60e"></a>
template&lt;std::ptrdiff_t Extent = dynamic_extent&gt; </td></tr>
<tr class="memitem:aa895dd575730723851c77eb2981ad60e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>u32zstring</b> = basic_zstring&lt; char32_t, std::char_traits&lt; char32_t &gt;, Extent &gt;</td></tr>
<tr class="separator:aa895dd575730723851c77eb2981ad60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac000d24a8914a0c94023979be4ffa179"><td class="memTemplParams" colspan="2"><a id="ac000d24a8914a0c94023979be4ffa179"></a>
template&lt;std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:ac000d24a8914a0c94023979be4ffa179"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>string_span</b> = <a class="el" href="../../db/de7/classbit_1_1stl_1_1basic__string__span.html">basic_string_span</a>&lt; char, std::char_traits&lt; char &gt;, Extent &gt;</td></tr>
<tr class="separator:ac000d24a8914a0c94023979be4ffa179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad892609c1d75f3c103c4aa4599e98a98"><td class="memTemplParams" colspan="2"><a id="ad892609c1d75f3c103c4aa4599e98a98"></a>
template&lt;std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:ad892609c1d75f3c103c4aa4599e98a98"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>wstring_span</b> = <a class="el" href="../../db/de7/classbit_1_1stl_1_1basic__string__span.html">basic_string_span</a>&lt; wchar_t, std::char_traits&lt; wchar_t &gt;, Extent &gt;</td></tr>
<tr class="separator:ad892609c1d75f3c103c4aa4599e98a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46422f18282328fee2a1b6fe23549c20"><td class="memTemplParams" colspan="2"><a id="a46422f18282328fee2a1b6fe23549c20"></a>
template&lt;std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a46422f18282328fee2a1b6fe23549c20"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>u16string_span</b> = <a class="el" href="../../db/de7/classbit_1_1stl_1_1basic__string__span.html">basic_string_span</a>&lt; char16_t, std::char_traits&lt; char16_t &gt;, Extent &gt;</td></tr>
<tr class="separator:a46422f18282328fee2a1b6fe23549c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ece75ff6a48b762fe43adc2445b867"><td class="memTemplParams" colspan="2"><a id="ac1ece75ff6a48b762fe43adc2445b867"></a>
template&lt;std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:ac1ece75ff6a48b762fe43adc2445b867"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>u32string_span</b> = <a class="el" href="../../db/de7/classbit_1_1stl_1_1basic__string__span.html">basic_string_span</a>&lt; char32_t, std::char_traits&lt; char32_t &gt;, Extent &gt;</td></tr>
<tr class="separator:ac1ece75ff6a48b762fe43adc2445b867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c9433e2c7eba860242f75c202d78eb"><td class="memTemplParams" colspan="2"><a id="ad2c9433e2c7eba860242f75c202d78eb"></a>
template&lt;std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:ad2c9433e2c7eba860242f75c202d78eb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>zstring_span</b> = <a class="el" href="../../dd/d92/classbit_1_1stl_1_1basic__zstring__span.html">basic_zstring_span</a>&lt; char, std::char_traits&lt; char &gt;, Extent &gt;</td></tr>
<tr class="separator:ad2c9433e2c7eba860242f75c202d78eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805428a98a25edaeaee01879f8a00c94"><td class="memTemplParams" colspan="2"><a id="a805428a98a25edaeaee01879f8a00c94"></a>
template&lt;std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a805428a98a25edaeaee01879f8a00c94"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>wzstring_span</b> = <a class="el" href="../../dd/d92/classbit_1_1stl_1_1basic__zstring__span.html">basic_zstring_span</a>&lt; wchar_t, std::char_traits&lt; wchar_t &gt;, Extent &gt;</td></tr>
<tr class="separator:a805428a98a25edaeaee01879f8a00c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b62a9e1e63b265fe5e2469dfd6b6e72"><td class="memTemplParams" colspan="2"><a id="a4b62a9e1e63b265fe5e2469dfd6b6e72"></a>
template&lt;std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a4b62a9e1e63b265fe5e2469dfd6b6e72"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>u16zstring_span</b> = <a class="el" href="../../dd/d92/classbit_1_1stl_1_1basic__zstring__span.html">basic_zstring_span</a>&lt; char16_t, std::char_traits&lt; char16_t &gt;, Extent &gt;</td></tr>
<tr class="separator:a4b62a9e1e63b265fe5e2469dfd6b6e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93762305bc884f428d8044055af525c4"><td class="memTemplParams" colspan="2"><a id="a93762305bc884f428d8044055af525c4"></a>
template&lt;std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a93762305bc884f428d8044055af525c4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>u32zstring_span</b> = <a class="el" href="../../dd/d92/classbit_1_1stl_1_1basic__zstring__span.html">basic_zstring_span</a>&lt; char32_t, std::char_traits&lt; char32_t &gt;, Extent &gt;</td></tr>
<tr class="separator:a93762305bc884f428d8044055af525c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac960b0c0061252bb398695e4bd0c706b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac960b0c0061252bb398695e4bd0c706b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ac960b0c0061252bb398695e4bd0c706b">is_string_span</a> = detail::is_string_span&lt; std::remove_cv_t&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ac960b0c0061252bb398695e4bd0c706b"><td class="mdescLeft">&#160;</td><td class="mdescRight">type-trait to determine whether the type is a string_span  <a href="#ac960b0c0061252bb398695e4bd0c706b">More...</a><br /></td></tr>
<tr class="separator:ac960b0c0061252bb398695e4bd0c706b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad591c6c50fab0fb9348d8afd38322a37"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad591c6c50fab0fb9348d8afd38322a37"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ad591c6c50fab0fb9348d8afd38322a37">is_zstring_span</a> = detail::is_zstring_span&lt; std::remove_cv_t&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ad591c6c50fab0fb9348d8afd38322a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">type-trait to determine whether the type is a null-terminated string  <a href="#ad591c6c50fab0fb9348d8afd38322a37">More...</a><br /></td></tr>
<tr class="separator:ad591c6c50fab0fb9348d8afd38322a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7d69900d17489caf0ffbebea99485a"><td class="memItemLeft" align="right" valign="top"><a id="abb7d69900d17489caf0ffbebea99485a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>string_view</b> = <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; char &gt;</td></tr>
<tr class="separator:abb7d69900d17489caf0ffbebea99485a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2094d98472588d728985e9d677b0ed4c"><td class="memItemLeft" align="right" valign="top"><a id="a2094d98472588d728985e9d677b0ed4c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>wstring_view</b> = <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; wchar_t &gt;</td></tr>
<tr class="separator:a2094d98472588d728985e9d677b0ed4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf49a062911610dee85d6498d73c0e49"><td class="memItemLeft" align="right" valign="top"><a id="acf49a062911610dee85d6498d73c0e49"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u16string_view</b> = <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; char16_t &gt;</td></tr>
<tr class="separator:acf49a062911610dee85d6498d73c0e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c07055689d0d4e12452165cb90061f"><td class="memItemLeft" align="right" valign="top"><a id="a97c07055689d0d4e12452165cb90061f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u32string_view</b> = <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; char32_t &gt;</td></tr>
<tr class="separator:a97c07055689d0d4e12452165cb90061f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52ea4771a4f1b858b0c4355628dfd4f"><td class="memItemLeft" align="right" valign="top"><a id="ac52ea4771a4f1b858b0c4355628dfd4f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>zstring_view</b> = <a class="el" href="../../d6/d16/classbit_1_1stl_1_1basic__zstring__view.html">basic_zstring_view</a>&lt; char &gt;</td></tr>
<tr class="separator:ac52ea4771a4f1b858b0c4355628dfd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac55cc561f2177ed6edbbf5017a955a"><td class="memItemLeft" align="right" valign="top"><a id="a0ac55cc561f2177ed6edbbf5017a955a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>wzstring_view</b> = <a class="el" href="../../d6/d16/classbit_1_1stl_1_1basic__zstring__view.html">basic_zstring_view</a>&lt; wchar_t &gt;</td></tr>
<tr class="separator:a0ac55cc561f2177ed6edbbf5017a955a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ef4f44c4c168bc00112b0b5d6eef64"><td class="memItemLeft" align="right" valign="top"><a id="a19ef4f44c4c168bc00112b0b5d6eef64"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u16zstring_view</b> = <a class="el" href="../../d6/d16/classbit_1_1stl_1_1basic__zstring__view.html">basic_zstring_view</a>&lt; char16_t &gt;</td></tr>
<tr class="separator:a19ef4f44c4c168bc00112b0b5d6eef64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20eaaefa0a47f1b93c58572666af1cf0"><td class="memItemLeft" align="right" valign="top"><a id="a20eaaefa0a47f1b93c58572666af1cf0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u32zstring_view</b> = <a class="el" href="../../d6/d16/classbit_1_1stl_1_1basic__zstring__view.html">basic_zstring_view</a>&lt; char32_t &gt;</td></tr>
<tr class="separator:a20eaaefa0a47f1b93c58572666af1cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad243489c846cede444d03231400b6666"><td class="memTemplParams" colspan="2"><a id="ad243489c846cede444d03231400b6666"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad243489c846cede444d03231400b6666"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ad243489c846cede444d03231400b6666">owner</a> = T</td></tr>
<tr class="memdesc:ad243489c846cede444d03231400b6666"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer that represents ownership. <br /></td></tr>
<tr class="separator:ad243489c846cede444d03231400b6666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbb17680abe59a19bc51089ad122a44"><td class="memTemplParams" colspan="2"><a id="abdbb17680abe59a19bc51089ad122a44"></a>
template&lt;typename Iterator , typename Sentinel &gt; </td></tr>
<tr class="memitem:abdbb17680abe59a19bc51089ad122a44"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>move_range</b> = <a class="el" href="../../d9/d68/classbit_1_1stl_1_1range.html">range</a>&lt; std::move_iterator&lt; Iterator &gt;, std::move_iterator&lt; Sentinel &gt; &gt;</td></tr>
<tr class="separator:abdbb17680abe59a19bc51089ad122a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98c5130c14d4534e221dd6b097687fe"><td class="memTemplParams" colspan="2"><a id="ad98c5130c14d4534e221dd6b097687fe"></a>
template&lt;typename Iterator , typename Sentinel  = Iterator&gt; </td></tr>
<tr class="memitem:ad98c5130c14d4534e221dd6b097687fe"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ad98c5130c14d4534e221dd6b097687fe">reverse_range</a> = <a class="el" href="../../d9/d68/classbit_1_1stl_1_1range.html">range</a>&lt; std::reverse_iterator&lt; Iterator &gt;, std::reverse_iterator&lt; Sentinel &gt; &gt;</td></tr>
<tr class="memdesc:ad98c5130c14d4534e221dd6b097687fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range that contains only reverse iterators. <br /></td></tr>
<tr class="separator:ad98c5130c14d4534e221dd6b097687fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a1e88c53d0755d00abb962f7641010"><td class="memTemplParams" colspan="2"><a id="a30a1e88c53d0755d00abb962f7641010"></a>
template&lt;std::size_t N, typename Iterator , typename Sentinel &gt; </td></tr>
<tr class="memitem:a30a1e88c53d0755d00abb962f7641010"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tuple_element_range</b> = <a class="el" href="../../d9/d68/classbit_1_1stl_1_1range.html">range</a>&lt; <a class="el" href="../../de/d9c/classbit_1_1stl_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; N, Iterator &gt;, <a class="el" href="../../de/d9c/classbit_1_1stl_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; N, Sentinel &gt; &gt;</td></tr>
<tr class="separator:a30a1e88c53d0755d00abb962f7641010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352467107e47997c9d293818c04c62e8"><td class="memTemplParams" colspan="2"><a id="a352467107e47997c9d293818c04c62e8"></a>
template&lt;typename... Iterators&gt; </td></tr>
<tr class="memitem:a352467107e47997c9d293818c04c62e8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>zip_range</b> = <a class="el" href="../../d9/d68/classbit_1_1stl_1_1range.html">range</a>&lt; <a class="el" href="../../d3/dc5/classbit_1_1stl_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators &gt;..., <a class="el" href="../../d3/dc5/classbit_1_1stl_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators &gt;... &gt;</td></tr>
<tr class="separator:a352467107e47997c9d293818c04c62e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6963a843faa0d131247e2adc47ac2560"><td class="memItemLeft" align="right" valign="top"><a id="a6963a843faa0d131247e2adc47ac2560"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>string_tokenizer</b> = <a class="el" href="../../d3/d50/classbit_1_1stl_1_1basic__string__tokenizer.html">basic_string_tokenizer</a>&lt; char, std::char_traits&lt; char &gt;, true &gt;</td></tr>
<tr class="separator:a6963a843faa0d131247e2adc47ac2560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d68bc3c1d88143399550f061aee4cf"><td class="memItemLeft" align="right" valign="top"><a id="a24d68bc3c1d88143399550f061aee4cf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>wstring_tokenizer</b> = <a class="el" href="../../d3/d50/classbit_1_1stl_1_1basic__string__tokenizer.html">basic_string_tokenizer</a>&lt; wchar_t, std::char_traits&lt; wchar_t &gt;, true &gt;</td></tr>
<tr class="separator:a24d68bc3c1d88143399550f061aee4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5a9df0c24c2d354847a500febe0331"><td class="memItemLeft" align="right" valign="top"><a id="afe5a9df0c24c2d354847a500febe0331"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u16string_tokenizer</b> = <a class="el" href="../../d3/d50/classbit_1_1stl_1_1basic__string__tokenizer.html">basic_string_tokenizer</a>&lt; char16_t, std::char_traits&lt; char16_t &gt;, true &gt;</td></tr>
<tr class="separator:afe5a9df0c24c2d354847a500febe0331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe2bf118c3a4a953401852907d519dd"><td class="memItemLeft" align="right" valign="top"><a id="a7fe2bf118c3a4a953401852907d519dd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u32string_tokenizer</b> = <a class="el" href="../../d3/d50/classbit_1_1stl_1_1basic__string__tokenizer.html">basic_string_tokenizer</a>&lt; char32_t, std::char_traits&lt; char32_t &gt;, true &gt;</td></tr>
<tr class="separator:a7fe2bf118c3a4a953401852907d519dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8760e105102b02e07f763bb926b41a5a"><td class="memItemLeft" align="right" valign="top"><a id="a8760e105102b02e07f763bb926b41a5a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>string_view_tokenizer</b> = <a class="el" href="../../d3/d50/classbit_1_1stl_1_1basic__string__tokenizer.html">basic_string_tokenizer</a>&lt; char, std::char_traits&lt; char &gt;, false &gt;</td></tr>
<tr class="separator:a8760e105102b02e07f763bb926b41a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbdebdf249664f9ab46f4fb377509c9"><td class="memItemLeft" align="right" valign="top"><a id="a1dbdebdf249664f9ab46f4fb377509c9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>wstring_view_tokenizer</b> = <a class="el" href="../../d3/d50/classbit_1_1stl_1_1basic__string__tokenizer.html">basic_string_tokenizer</a>&lt; wchar_t, std::char_traits&lt; wchar_t &gt;, false &gt;</td></tr>
<tr class="separator:a1dbdebdf249664f9ab46f4fb377509c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370db6d3c570dc26f9a6a4c12d609344"><td class="memItemLeft" align="right" valign="top"><a id="a370db6d3c570dc26f9a6a4c12d609344"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u16string_view_tokenizer</b> = <a class="el" href="../../d3/d50/classbit_1_1stl_1_1basic__string__tokenizer.html">basic_string_tokenizer</a>&lt; char16_t, std::char_traits&lt; char16_t &gt;, false &gt;</td></tr>
<tr class="separator:a370db6d3c570dc26f9a6a4c12d609344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e3f2e0a425d22092336e333f0b3003"><td class="memItemLeft" align="right" valign="top"><a id="a05e3f2e0a425d22092336e333f0b3003"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u32string_view_tokenizer</b> = <a class="el" href="../../d3/d50/classbit_1_1stl_1_1basic__string__tokenizer.html">basic_string_tokenizer</a>&lt; char32_t, std::char_traits&lt; char32_t &gt;, false &gt;</td></tr>
<tr class="separator:a05e3f2e0a425d22092336e333f0b3003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55b248051d5393fe10e6ffe1f7b2143"><td class="memTemplParams" colspan="2">template&lt;bool B&gt; </td></tr>
<tr class="memitem:ab55b248051d5393fe10e6ffe1f7b2143"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ab55b248051d5393fe10e6ffe1f7b2143">bool_constant</a> = integral_constant&lt; bool, B &gt;</td></tr>
<tr class="memdesc:ab55b248051d5393fe10e6ffe1f7b2143"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility metafunction provides compile-time boolean values as an integral constant.  <a href="#ab55b248051d5393fe10e6ffe1f7b2143">More...</a><br /></td></tr>
<tr class="separator:ab55b248051d5393fe10e6ffe1f7b2143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab826b51ed79a37ebc14a8ece5fdacb16"><td class="memItemLeft" align="right" valign="top"><a id="ab826b51ed79a37ebc14a8ece5fdacb16"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>true_type</b> = <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ab55b248051d5393fe10e6ffe1f7b2143">bool_constant</a>&lt; true &gt;</td></tr>
<tr class="separator:ab826b51ed79a37ebc14a8ece5fdacb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66122d036651793adb0dbfb7b69d0855"><td class="memItemLeft" align="right" valign="top"><a id="a66122d036651793adb0dbfb7b69d0855"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>false_type</b> = <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ab55b248051d5393fe10e6ffe1f7b2143">bool_constant</a>&lt; false &gt;</td></tr>
<tr class="separator:a66122d036651793adb0dbfb7b69d0855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf6f0daf674725724a0b300518d1b84"><td class="memTemplParams" colspan="2"><a id="a9bf6f0daf674725724a0b300518d1b84"></a>
template&lt;template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:a9bf6f0daf674725724a0b300518d1b84"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_detected</b> = typename detail::detector&lt; <a class="el" href="../../dc/d64/structbit_1_1stl_1_1nonesuch.html">nonesuch</a>, void, Op, Args... &gt;::value_t</td></tr>
<tr class="separator:a9bf6f0daf674725724a0b300518d1b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d30bd204fae15f666a4a06e3fc1419"><td class="memTemplParams" colspan="2"><a id="a55d30bd204fae15f666a4a06e3fc1419"></a>
template&lt;template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:a55d30bd204fae15f666a4a06e3fc1419"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>detected_t</b> = typename detail::detector&lt; <a class="el" href="../../dc/d64/structbit_1_1stl_1_1nonesuch.html">nonesuch</a>, void, Op, Args... &gt;::type</td></tr>
<tr class="separator:a55d30bd204fae15f666a4a06e3fc1419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177a9aff2a6a93b4c6895ef6a3676691"><td class="memTemplParams" colspan="2"><a id="a177a9aff2a6a93b4c6895ef6a3676691"></a>
template&lt;typename Default , template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:a177a9aff2a6a93b4c6895ef6a3676691"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>detected_or</b> = detail::detector&lt; Default, void, Op, Args... &gt;</td></tr>
<tr class="separator:a177a9aff2a6a93b4c6895ef6a3676691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae93ec8dbcd9465303cc7ccbe15bb332"><td class="memTemplParams" colspan="2"><a id="aae93ec8dbcd9465303cc7ccbe15bb332"></a>
template&lt;typename Default , template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:aae93ec8dbcd9465303cc7ccbe15bb332"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>detected_or_t</b> = typename detected_or&lt; Default, Op, Args... &gt;::type</td></tr>
<tr class="separator:aae93ec8dbcd9465303cc7ccbe15bb332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ff5984c6d328ba3bd5765ea8ea3254"><td class="memTemplParams" colspan="2"><a id="ab4ff5984c6d328ba3bd5765ea8ea3254"></a>
template&lt;typename Expected , template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:ab4ff5984c6d328ba3bd5765ea8ea3254"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_detected_exact</b> = std::is_same&lt; Expected, detected_t&lt; Op, Args... &gt; &gt;</td></tr>
<tr class="separator:ab4ff5984c6d328ba3bd5765ea8ea3254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4baca8625c3170b2581c3e2b433bb5a0"><td class="memTemplParams" colspan="2"><a id="a4baca8625c3170b2581c3e2b433bb5a0"></a>
template&lt;typename To , template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:a4baca8625c3170b2581c3e2b433bb5a0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_detected_convertible</b> = std::is_convertible&lt; detected_t&lt; Op, Args... &gt;, To &gt;</td></tr>
<tr class="separator:a4baca8625c3170b2581c3e2b433bb5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f5507832d9db0668b2b0d96c93be75"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a88f5507832d9db0668b2b0d96c93be75"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a88f5507832d9db0668b2b0d96c93be75">identity_t</a> = typename <a class="el" href="../../df/d46/structbit_1_1stl_1_1identity.html">identity</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a88f5507832d9db0668b2b0d96c93be75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace alias used to extract identity&lt;T&gt;::type.  <a href="#a88f5507832d9db0668b2b0d96c93be75">More...</a><br /></td></tr>
<tr class="separator:a88f5507832d9db0668b2b0d96c93be75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66c42fe9eca29efd6386208653e7980"><td class="memTemplParams" colspan="2"><a id="aa66c42fe9eca29efd6386208653e7980"></a>
template&lt;typename T , T V&gt; </td></tr>
<tr class="memitem:aa66c42fe9eca29efd6386208653e7980"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>integral_constant</b> = std::integral_constant&lt; T, V &gt;</td></tr>
<tr class="separator:aa66c42fe9eca29efd6386208653e7980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728fe5b73fce3848f6b8e876a5694378"><td class="memTemplParams" colspan="2"><a id="a728fe5b73fce3848f6b8e876a5694378"></a>
template&lt;typename T , T V&gt; </td></tr>
<tr class="memitem:a728fe5b73fce3848f6b8e876a5694378"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>integral_constant_t</b> = typename integral_constant&lt; T, V &gt;::type</td></tr>
<tr class="separator:a728fe5b73fce3848f6b8e876a5694378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1d68a35d71b12be9adfc8ced1519aa"><td class="memTemplParams" colspan="2"><a id="ace1d68a35d71b12be9adfc8ced1519aa"></a>
template&lt;bool B, typename T &gt; </td></tr>
<tr class="memitem:ace1d68a35d71b12be9adfc8ced1519aa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enable_if_t</b> = typename <a class="el" href="../../dc/d20/structbit_1_1stl_1_1enable__if.html">enable_if</a>&lt; B, T &gt;::type</td></tr>
<tr class="separator:ace1d68a35d71b12be9adfc8ced1519aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5274853f7ad307160589c5183c4a9521"><td class="memTemplParams" colspan="2"><a id="a5274853f7ad307160589c5183c4a9521"></a>
template&lt;bool B, typename T &gt; </td></tr>
<tr class="memitem:a5274853f7ad307160589c5183c4a9521"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5274853f7ad307160589c5183c4a9521">disable_if_t</a> = typename <a class="el" href="../../dc/d20/structbit_1_1stl_1_1enable__if.html">enable_if</a>&lt; B, T &gt;::type</td></tr>
<tr class="memdesc:a5274853f7ad307160589c5183c4a9521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias to retrieve the <code>::type</code> member of <code>block_if</code>. <br /></td></tr>
<tr class="separator:a5274853f7ad307160589c5183c4a9521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdbe9153ed3d7fffaa5de91a20c3de5"><td class="memTemplParams" colspan="2"><a id="aacdbe9153ed3d7fffaa5de91a20c3de5"></a>
template&lt;bool B, typename T &gt; </td></tr>
<tr class="memitem:aacdbe9153ed3d7fffaa5de91a20c3de5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aacdbe9153ed3d7fffaa5de91a20c3de5">enable_overload_if_t</a> = typename <a class="el" href="../../df/d61/structbit_1_1stl_1_1enable__overload__if.html">enable_overload_if</a>&lt; B, T &gt;::type</td></tr>
<tr class="memdesc:aacdbe9153ed3d7fffaa5de91a20c3de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias to retrieve the <code>::type</code> member of <code>block_if</code>. <br /></td></tr>
<tr class="separator:aacdbe9153ed3d7fffaa5de91a20c3de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0acd352a51048f8d8bc61fd9149fcbd9"><td class="memTemplParams" colspan="2"><a id="a0acd352a51048f8d8bc61fd9149fcbd9"></a>
template&lt;bool B, typename T &gt; </td></tr>
<tr class="memitem:a0acd352a51048f8d8bc61fd9149fcbd9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a0acd352a51048f8d8bc61fd9149fcbd9">disable_overload_if</a> = <a class="el" href="../../df/d61/structbit_1_1stl_1_1enable__overload__if.html">enable_overload_if</a>&lt;!B, T &gt;</td></tr>
<tr class="memdesc:a0acd352a51048f8d8bc61fd9149fcbd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of <code>block_if</code>. <br /></td></tr>
<tr class="separator:a0acd352a51048f8d8bc61fd9149fcbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa157b8bab115b904becb958d15bca61d"><td class="memTemplParams" colspan="2"><a id="aa157b8bab115b904becb958d15bca61d"></a>
template&lt;bool B, typename T &gt; </td></tr>
<tr class="memitem:aa157b8bab115b904becb958d15bca61d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aa157b8bab115b904becb958d15bca61d">disable_overload_if_t</a> = typename <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a0acd352a51048f8d8bc61fd9149fcbd9">disable_overload_if</a>&lt; B, T &gt;::type</td></tr>
<tr class="memdesc:aa157b8bab115b904becb958d15bca61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias to retrieve the <code>::type</code> member of <code>block_unless</code>. <br /></td></tr>
<tr class="separator:aa157b8bab115b904becb958d15bca61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618d89ada20b451c43bf19ab9580409e"><td class="memTemplParams" colspan="2">template&lt;std::size_t Size&gt; </td></tr>
<tr class="memitem:a618d89ada20b451c43bf19ab9580409e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a618d89ada20b451c43bf19ab9580409e">size_constant</a> = std::integral_constant&lt; std::size_t, Size &gt;</td></tr>
<tr class="memdesc:a618d89ada20b451c43bf19ab9580409e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility metafunction provides compile-time size values as an integral constant.  <a href="#a618d89ada20b451c43bf19ab9580409e">More...</a><br /></td></tr>
<tr class="separator:a618d89ada20b451c43bf19ab9580409e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6db0040e1fb483117eb2ddadbfba7a7"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ae6db0040e1fb483117eb2ddadbfba7a7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ae6db0040e1fb483117eb2ddadbfba7a7">void_t</a> = typename detail::voidify&lt; Types... &gt;::type</td></tr>
<tr class="memdesc:ae6db0040e1fb483117eb2ddadbfba7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility metafunction that maps a sequence of any types to the type void.  <a href="#ae6db0040e1fb483117eb2ddadbfba7a7">More...</a><br /></td></tr>
<tr class="separator:ae6db0040e1fb483117eb2ddadbfba7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e9dfcbb6ff31b68f7c7fdbffef5a95"><td class="memTemplParams" colspan="2"><a id="a28e9dfcbb6ff31b68f7c7fdbffef5a95"></a>
template&lt;std::size_t I, typename Fn &gt; </td></tr>
<tr class="memitem:a28e9dfcbb6ff31b68f7c7fdbffef5a95"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a28e9dfcbb6ff31b68f7c7fdbffef5a95">function_argument_t</a> = typename <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d2/db4/structbit_1_1stl_1_1function__argument">function_argument</a>&lt; I, Fn &gt;::type</td></tr>
<tr class="memdesc:a28e9dfcbb6ff31b68f7c7fdbffef5a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract function_argument::type. <br /></td></tr>
<tr class="separator:a28e9dfcbb6ff31b68f7c7fdbffef5a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a758646030d1ddc28beb5ded9284f1"><td class="memTemplParams" colspan="2"><a id="a85a758646030d1ddc28beb5ded9284f1"></a>
template&lt;std::size_t I, typename... Types&gt; </td></tr>
<tr class="memitem:a85a758646030d1ddc28beb5ded9284f1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a85a758646030d1ddc28beb5ded9284f1">nth_type_t</a> = typename <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d2/d69/structbit_1_1stl_1_1nth__type">nth_type</a>&lt; I, Types... &gt;::type</td></tr>
<tr class="memdesc:a85a758646030d1ddc28beb5ded9284f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract nth_type::type. <br /></td></tr>
<tr class="separator:a85a758646030d1ddc28beb5ded9284f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793ba48cdec0344ad6a9dcc1792407dc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a793ba48cdec0344ad6a9dcc1792407dc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a793ba48cdec0344ad6a9dcc1792407dc">pointer_rank</a> = detail::pointer_rank&lt; T, 0 &gt;</td></tr>
<tr class="memdesc:a793ba48cdec0344ad6a9dcc1792407dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the level of indirection of a given type T.  <a href="#a793ba48cdec0344ad6a9dcc1792407dc">More...</a><br /></td></tr>
<tr class="separator:a793ba48cdec0344ad6a9dcc1792407dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada876145f89a8518848ed41709737585"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ada876145f89a8518848ed41709737585"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ada876145f89a8518848ed41709737585">is_same_decay</a> = std::is_same&lt; std::decay_t&lt; T &gt;, std::decay_t&lt; U &gt; &gt;</td></tr>
<tr class="memdesc:ada876145f89a8518848ed41709737585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine whether a type is the same with a different decay type.  <a href="#ada876145f89a8518848ed41709737585">More...</a><br /></td></tr>
<tr class="separator:ada876145f89a8518848ed41709737585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99455422a7c82ef2fd6e5bf3f839ec34"><td class="memTemplParams" colspan="2"><a id="a99455422a7c82ef2fd6e5bf3f839ec34"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a99455422a7c82ef2fd6e5bf3f839ec34"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a99455422a7c82ef2fd6e5bf3f839ec34">base_type_t</a> = typename <a class="el" href="../../d7/de5/structbit_1_1stl_1_1base__type.html">base_type</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a99455422a7c82ef2fd6e5bf3f839ec34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for retrieving the <code>::type</code> field of <a class="el" href="../../d7/de5/structbit_1_1stl_1_1base__type.html" title="Obtains the base type of T without modifiers. ">base_type</a>. <br /></td></tr>
<tr class="separator:a99455422a7c82ef2fd6e5bf3f839ec34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eaac3214ed9b0fd4754c1c880120c8a"><td class="memTemplParams" colspan="2"><a id="a5eaac3214ed9b0fd4754c1c880120c8a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5eaac3214ed9b0fd4754c1c880120c8a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5eaac3214ed9b0fd4754c1c880120c8a">function_signature_t</a> = typename <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#df/d77/structbit_1_1stl_1_1function__signature">function_signature</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a5eaac3214ed9b0fd4754c1c880120c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract function_signature::type. <br /></td></tr>
<tr class="separator:a5eaac3214ed9b0fd4754c1c880120c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077a922f056d7c58abbab9a8634686be"><td class="memTemplParams" colspan="2">template&lt;typename Qualified , typename Unqualified &gt; </td></tr>
<tr class="memitem:a077a922f056d7c58abbab9a8634686be"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a077a922f056d7c58abbab9a8634686be">match_cv_qualifiers</a> = detail::cv_selector&lt; Unqualified, std::is_const&lt; Qualified &gt;::value, std::is_volatile&lt; Qualified &gt;::value &gt;</td></tr>
<tr class="memdesc:a077a922f056d7c58abbab9a8634686be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to match the cv qualifications of <code>Qualified</code> and apply it to <code>Unqualified</code>.  <a href="#a077a922f056d7c58abbab9a8634686be">More...</a><br /></td></tr>
<tr class="separator:a077a922f056d7c58abbab9a8634686be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507e1e3afe6c38acbc7f90c964be956a"><td class="memTemplParams" colspan="2"><a id="a507e1e3afe6c38acbc7f90c964be956a"></a>
template&lt;typename Qualified , typename Unqualified &gt; </td></tr>
<tr class="memitem:a507e1e3afe6c38acbc7f90c964be956a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a507e1e3afe6c38acbc7f90c964be956a">match_cv_qualifiers_t</a> = typename <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a077a922f056d7c58abbab9a8634686be">match_cv_qualifiers</a>&lt; Qualified, Unqualified &gt;::type</td></tr>
<tr class="memdesc:a507e1e3afe6c38acbc7f90c964be956a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for retrieving the <code>::type</code> field of match_cv_qualifiers. <br /></td></tr>
<tr class="separator:a507e1e3afe6c38acbc7f90c964be956a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a79f6cac4e03284e5b37de4066e8195"><td class="memTemplParams" colspan="2">template&lt;typename Qualified , typename Unqualified &gt; </td></tr>
<tr class="memitem:a9a79f6cac4e03284e5b37de4066e8195"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a9a79f6cac4e03284e5b37de4066e8195">match_ref_qualifiers</a> = detail::ref_selector&lt; Unqualified, std::is_lvalue_reference&lt; Qualified &gt;::value, std::is_rvalue_reference&lt; Qualified &gt;::value &gt;</td></tr>
<tr class="memdesc:a9a79f6cac4e03284e5b37de4066e8195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to match the ref qualifications of <code>Qualified</code> and apply it to <code>Unqualified</code>.  <a href="#a9a79f6cac4e03284e5b37de4066e8195">More...</a><br /></td></tr>
<tr class="separator:a9a79f6cac4e03284e5b37de4066e8195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab098e3c1506fea602599f86885cc827d"><td class="memTemplParams" colspan="2"><a id="ab098e3c1506fea602599f86885cc827d"></a>
template&lt;typename Qualified , typename Unqualified &gt; </td></tr>
<tr class="memitem:ab098e3c1506fea602599f86885cc827d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ab098e3c1506fea602599f86885cc827d">match_ref_qualifiers_t</a> = typename <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a9a79f6cac4e03284e5b37de4066e8195">match_ref_qualifiers</a>&lt; Qualified, Unqualified &gt;::type</td></tr>
<tr class="memdesc:ab098e3c1506fea602599f86885cc827d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for retrieving the <code>::type</code> field of match_ref_qualifiers. <br /></td></tr>
<tr class="separator:ab098e3c1506fea602599f86885cc827d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243bc9548267f05aaabf64ce36d3b981"><td class="memTemplParams" colspan="2">template&lt;typename Qualified , typename Unqualified &gt; </td></tr>
<tr class="memitem:a243bc9548267f05aaabf64ce36d3b981"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a243bc9548267f05aaabf64ce36d3b981">match_sign_qualifiers</a> = detail::sign_selector&lt; Unqualified, std::is_signed&lt; Qualified &gt;::value, std::is_unsigned&lt; Qualified &gt;::value &gt;</td></tr>
<tr class="memdesc:a243bc9548267f05aaabf64ce36d3b981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to match the sign qualifications of <code>Qualified</code> and apply it to <code>Unqualified</code>.  <a href="#a243bc9548267f05aaabf64ce36d3b981">More...</a><br /></td></tr>
<tr class="separator:a243bc9548267f05aaabf64ce36d3b981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1a743313566077aafeed58d73a87e9"><td class="memTemplParams" colspan="2"><a id="a4b1a743313566077aafeed58d73a87e9"></a>
template&lt;typename Qualified , typename Unqualified &gt; </td></tr>
<tr class="memitem:a4b1a743313566077aafeed58d73a87e9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a4b1a743313566077aafeed58d73a87e9">match_sign_qualifiers_t</a> = typename <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a243bc9548267f05aaabf64ce36d3b981">match_sign_qualifiers</a>&lt; Qualified, Unqualified &gt;::type</td></tr>
<tr class="memdesc:a4b1a743313566077aafeed58d73a87e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for retrieving the <code>::type</code> field of match_sign_qualifiers. <br /></td></tr>
<tr class="separator:a4b1a743313566077aafeed58d73a87e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0acaac32d4dcd72a5827603ffd2e24"><td class="memTemplParams" colspan="2"><a id="a4e0acaac32d4dcd72a5827603ffd2e24"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4e0acaac32d4dcd72a5827603ffd2e24"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a4e0acaac32d4dcd72a5827603ffd2e24">normalize_char_t</a> = typename <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d9/d75/structbit_1_1stl_1_1normalize__char">normalize_char</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a4e0acaac32d4dcd72a5827603ffd2e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for retrieving the <code>::type</code> field of <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d9/d75/structbit_1_1stl_1_1normalize__char" title="Normalizes character types T to non-signed/unsigned character types. ">normalize_char</a>. <br /></td></tr>
<tr class="separator:a4e0acaac32d4dcd72a5827603ffd2e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd71da8a0eac6e18051cd96cf0acb3d"><td class="memTemplParams" colspan="2"><a id="aecd71da8a0eac6e18051cd96cf0acb3d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aecd71da8a0eac6e18051cd96cf0acb3d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aecd71da8a0eac6e18051cd96cf0acb3d">remove_pointers_t</a> = typename <a class="el" href="../../df/df3/structbit_1_1stl_1_1remove__pointers.html">remove_pointers</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:aecd71da8a0eac6e18051cd96cf0acb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience template to retrieve the <code>::type</code> of <a class="el" href="../../df/df3/structbit_1_1stl_1_1remove__pointers.html" title="Removes all pointers from a given type. ">remove_pointers</a>. <br /></td></tr>
<tr class="separator:aecd71da8a0eac6e18051cd96cf0acb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3d206acdcf2b50cb22ed69eea51152"><td class="memTemplParams" colspan="2"><a id="a2e3d206acdcf2b50cb22ed69eea51152"></a>
template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:a2e3d206acdcf2b50cb22ed69eea51152"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a2e3d206acdcf2b50cb22ed69eea51152">resolved_overload_type_t</a> = typename <a class="el" href="../../d1/d53/structbit_1_1stl_1_1resolves__overload__type.html">resolves_overload_type</a>&lt; T, Types... &gt;::type</td></tr>
<tr class="memdesc:a2e3d206acdcf2b50cb22ed69eea51152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract resolves_overload_type::type. <br /></td></tr>
<tr class="separator:a2e3d206acdcf2b50cb22ed69eea51152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac09cfc87a880a0470296b50ae869cd4"><td class="memTemplParams" colspan="2"><a id="aac09cfc87a880a0470296b50ae869cd4"></a>
template&lt;std::size_t Len, std::size_t Align = max_align&gt; </td></tr>
<tr class="memitem:aac09cfc87a880a0470296b50ae869cd4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aac09cfc87a880a0470296b50ae869cd4">aligned_storage_t</a> = typename <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d2/d55/structbit_1_1stl_1_1aligned__storage">aligned_storage</a>&lt; Len, Align &gt;::type</td></tr>
<tr class="memdesc:aac09cfc87a880a0470296b50ae869cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-alias for extracting <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d4/dba/unionbit_1_1stl_1_1aligned__storage_1_1type">aligned_storage::type</a>. <br /></td></tr>
<tr class="separator:aac09cfc87a880a0470296b50ae869cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129f3fb91f063c824288765df8236f3e"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a129f3fb91f063c824288765df8236f3e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a129f3fb91f063c824288765df8236f3e">aligned_storage_for</a> = <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aac09cfc87a880a0470296b50ae869cd4">aligned_storage_t</a>&lt; detail::aligned_storage_max&lt; sizeof(Types)... &gt;::value, detail::aligned_storage_max&lt; alignof(Types)... &gt;::value &gt;</td></tr>
<tr class="memdesc:a129f3fb91f063c824288765df8236f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-alias for creating <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d2/d55/structbit_1_1stl_1_1aligned__storage" title="Provides the nested type type, which is a PODType suitable for use as uninitialized storage for any o...">aligned_storage</a> large enough and suitably aligned for all specified Types...  <a href="#a129f3fb91f063c824288765df8236f3e">More...</a><br /></td></tr>
<tr class="separator:a129f3fb91f063c824288765df8236f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697802d1a66688c575ae1dbb00f1b510"><td class="memItemLeft" align="right" valign="top"><a id="a697802d1a66688c575ae1dbb00f1b510"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>assert_handler_t</b> = void(*)(const char *, <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html">source_location</a>)</td></tr>
<tr class="separator:a697802d1a66688c575ae1dbb00f1b510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae840ab8e66f9d84c426b90ef8b5076c6"><td class="memTemplParams" colspan="2"><a id="ae840ab8e66f9d84c426b90ef8b5076c6"></a>
template&lt;typename F , typename... Types&gt; </td></tr>
<tr class="memitem:ae840ab8e66f9d84c426b90ef8b5076c6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invoke_result_t</b> = typename <a class="el" href="../../de/d82/structbit_1_1stl_1_1invoke__result.html">invoke_result</a>&lt; F, Types... &gt;::type</td></tr>
<tr class="separator:ae840ab8e66f9d84c426b90ef8b5076c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120d4f65c646a277af6fd9c51ad78381"><td class="memTemplParams" colspan="2">template&lt;typename Fn , typename... Args&gt; </td></tr>
<tr class="memitem:a120d4f65c646a277af6fd9c51ad78381"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a120d4f65c646a277af6fd9c51ad78381">is_invocable</a> = detail::is_invocable&lt; Fn, Args... &gt;</td></tr>
<tr class="memdesc:a120d4f65c646a277af6fd9c51ad78381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine whether <code>Fn</code> is invokable with <code>Args</code>...  <a href="#a120d4f65c646a277af6fd9c51ad78381">More...</a><br /></td></tr>
<tr class="separator:a120d4f65c646a277af6fd9c51ad78381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f47ee038bc1d9539fe2f38cbc00915e"><td class="memTemplParams" colspan="2">template&lt;typename Fn , typename... Args&gt; </td></tr>
<tr class="memitem:a7f47ee038bc1d9539fe2f38cbc00915e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a7f47ee038bc1d9539fe2f38cbc00915e">is_nothrow_invocable</a> = detail::is_nothrow_invocable&lt; Fn, Args... &gt;</td></tr>
<tr class="memdesc:a7f47ee038bc1d9539fe2f38cbc00915e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine whether <code>Fn</code> is nothrow invokable with <code>Args</code>...  <a href="#a7f47ee038bc1d9539fe2f38cbc00915e">More...</a><br /></td></tr>
<tr class="separator:a7f47ee038bc1d9539fe2f38cbc00915e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5853dc716058231d67db9de2a050a251"><td class="memItemLeft" align="right" valign="top"><a id="a5853dc716058231d67db9de2a050a251"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5853dc716058231d67db9de2a050a251">indeterminate_t</a> = bool(*)(const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;, detail::tribool_t)</td></tr>
<tr class="memdesc:a5853dc716058231d67db9de2a050a251"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to mark an indeterminate tribool. <br /></td></tr>
<tr class="separator:a5853dc716058231d67db9de2a050a251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8390303a8a801dece9d6fede385cdec0"><td class="memItemLeft" align="right" valign="top"><a id="a8390303a8a801dece9d6fede385cdec0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a8390303a8a801dece9d6fede385cdec0">word</a> = int</td></tr>
<tr class="memdesc:a8390303a8a801dece9d6fede385cdec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed instruction-sized integer (Word) <br /></td></tr>
<tr class="separator:a8390303a8a801dece9d6fede385cdec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3c962cbbe823654a217c9c7619557f"><td class="memItemLeft" align="right" valign="top"><a id="adb3c962cbbe823654a217c9c7619557f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#adb3c962cbbe823654a217c9c7619557f">uword</a> = unsigned int</td></tr>
<tr class="memdesc:adb3c962cbbe823654a217c9c7619557f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned instruction-sized integer (Word) <br /></td></tr>
<tr class="separator:adb3c962cbbe823654a217c9c7619557f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609b8b83a65779bf425451da2c931bc3"><td class="memItemLeft" align="right" valign="top"><a id="a609b8b83a65779bf425451da2c931bc3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a609b8b83a65779bf425451da2c931bc3">uchar</a> = unsigned char</td></tr>
<tr class="memdesc:a609b8b83a65779bf425451da2c931bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned char type. <br /></td></tr>
<tr class="separator:a609b8b83a65779bf425451da2c931bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d16b03bce173a83cd4ac92ea2a0eeb"><td class="memItemLeft" align="right" valign="top"><a id="ae0d16b03bce173a83cd4ac92ea2a0eeb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ae0d16b03bce173a83cd4ac92ea2a0eeb">ushort</a> = unsigned short</td></tr>
<tr class="memdesc:ae0d16b03bce173a83cd4ac92ea2a0eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned short type. <br /></td></tr>
<tr class="separator:ae0d16b03bce173a83cd4ac92ea2a0eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1960753c0b87695d90d1085df554a54"><td class="memItemLeft" align="right" valign="top"><a id="aa1960753c0b87695d90d1085df554a54"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aa1960753c0b87695d90d1085df554a54">uint</a> = unsigned int</td></tr>
<tr class="memdesc:aa1960753c0b87695d90d1085df554a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned int type. <br /></td></tr>
<tr class="separator:aa1960753c0b87695d90d1085df554a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7213f0de5ec62553f34df797f4517aa9"><td class="memItemLeft" align="right" valign="top"><a id="a7213f0de5ec62553f34df797f4517aa9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a7213f0de5ec62553f34df797f4517aa9">ulong</a> = unsigned long</td></tr>
<tr class="memdesc:a7213f0de5ec62553f34df797f4517aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned long type. <br /></td></tr>
<tr class="separator:a7213f0de5ec62553f34df797f4517aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69cfc1b4ade1a9cc0f03d549d1685b7e"><td class="memItemLeft" align="right" valign="top"><a id="a69cfc1b4ade1a9cc0f03d549d1685b7e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ulonglong</b> = unsigned long long</td></tr>
<tr class="separator:a69cfc1b4ade1a9cc0f03d549d1685b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeda94e73421a165bf182fd7ca5b2e4c"><td class="memItemLeft" align="right" valign="top"><a id="abeda94e73421a165bf182fd7ca5b2e4c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#abeda94e73421a165bf182fd7ca5b2e4c">size_t</a> = std::size_t</td></tr>
<tr class="memdesc:abeda94e73421a165bf182fd7ca5b2e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type representing size of objects. <br /></td></tr>
<tr class="separator:abeda94e73421a165bf182fd7ca5b2e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c43d8849dd1538910e731be6f9b3a2c"><td class="memItemLeft" align="right" valign="top"><a id="a7c43d8849dd1538910e731be6f9b3a2c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a7c43d8849dd1538910e731be6f9b3a2c">align_t</a> = std::size_t</td></tr>
<tr class="memdesc:a7c43d8849dd1538910e731be6f9b3a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type representing alignment of an object. <br /></td></tr>
<tr class="separator:a7c43d8849dd1538910e731be6f9b3a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8843eac8c746fdb52b12036b241ed4e9"><td class="memItemLeft" align="right" valign="top"><a id="a8843eac8c746fdb52b12036b241ed4e9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a8843eac8c746fdb52b12036b241ed4e9">index_t</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:a8843eac8c746fdb52b12036b241ed4e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type representing index of objects. <br /></td></tr>
<tr class="separator:a8843eac8c746fdb52b12036b241ed4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54272c22a7297f1486e189a7ad68a6f9"><td class="memItemLeft" align="right" valign="top"><a id="a54272c22a7297f1486e189a7ad68a6f9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a54272c22a7297f1486e189a7ad68a6f9">hash_t</a> = std::size_t</td></tr>
<tr class="memdesc:a54272c22a7297f1486e189a7ad68a6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for hashes. <br /></td></tr>
<tr class="separator:a54272c22a7297f1486e189a7ad68a6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2379f4e27b53ecf7d9ee5bc39374a4ae"><td class="memTemplParams" colspan="2"><a id="a2379f4e27b53ecf7d9ee5bc39374a4ae"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a2379f4e27b53ecf7d9ee5bc39374a4ae"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a2379f4e27b53ecf7d9ee5bc39374a4ae">array_ref_t</a> = T(&amp;)[N]</td></tr>
<tr class="memdesc:a2379f4e27b53ecf7d9ee5bc39374a4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for lvalue-references to an array of N entries. <br /></td></tr>
<tr class="separator:a2379f4e27b53ecf7d9ee5bc39374a4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c70c898cbadfb2e44ee4f9e8230b98d"><td class="memTemplParams" colspan="2"><a id="a8c70c898cbadfb2e44ee4f9e8230b98d"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a8c70c898cbadfb2e44ee4f9e8230b98d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a8c70c898cbadfb2e44ee4f9e8230b98d">array_rref_t</a> = T(&amp;&amp;)[N]</td></tr>
<tr class="memdesc:a8c70c898cbadfb2e44ee4f9e8230b98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for rvalue-references to an array of N entries. <br /></td></tr>
<tr class="separator:a8c70c898cbadfb2e44ee4f9e8230b98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf455f79e68ed45d131623ae84329b2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R &gt; </td></tr>
<tr class="memitem:aacf455f79e68ed45d131623ae84329b2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aacf455f79e68ed45d131623ae84329b2">member_t</a> = R T::*</td></tr>
<tr class="memdesc:aacf455f79e68ed45d131623ae84329b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type alias for member pointers to make it more readable.  <a href="#aacf455f79e68ed45d131623ae84329b2">More...</a><br /></td></tr>
<tr class="separator:aacf455f79e68ed45d131623ae84329b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8bed7c33c9ca2f16724b85c3a0bb1c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Fn &gt; </td></tr>
<tr class="memitem:add8bed7c33c9ca2f16724b85c3a0bb1c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#add8bed7c33c9ca2f16724b85c3a0bb1c">member_function_t</a> = typename detail::member_function_t&lt; T, Fn &gt;::type</td></tr>
<tr class="memdesc:add8bed7c33c9ca2f16724b85c3a0bb1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type alias for member function pointers to make it more readable.  <a href="#add8bed7c33c9ca2f16724b85c3a0bb1c">More...</a><br /></td></tr>
<tr class="separator:add8bed7c33c9ca2f16724b85c3a0bb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f679456d2b3cd6f3f65577718d97c79"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a8f679456d2b3cd6f3f65577718d97c79"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a8f679456d2b3cd6f3f65577718d97c79">function_t</a> = typename detail::function_t&lt; Fn &gt;::type</td></tr>
<tr class="memdesc:a8f679456d2b3cd6f3f65577718d97c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type alias for function pointers to make it more readable.  <a href="#a8f679456d2b3cd6f3f65577718d97c79">More...</a><br /></td></tr>
<tr class="separator:a8f679456d2b3cd6f3f65577718d97c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5964268b12686a86b6e28490504f6416"><td class="memTemplParams" colspan="2"><a id="a5964268b12686a86b6e28490504f6416"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5964268b12686a86b6e28490504f6416"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>underlying_container_type_t</b> = typename <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#dd/d73/classbit_1_1stl_1_1underlying__container__type">underlying_container_type</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a5964268b12686a86b6e28490504f6416"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a3491ada4c9984f7854f01ad75b62c8b9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a> : unsigned char <tr class="memdesc:a3491ada4c9984f7854f01ad75b62c8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned byte type.  <a href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3491ada4c9984f7854f01ad75b62c8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2befb911f8c8b196b4ba81d50e20fb28"><td class="memTemplParams" colspan="2">template&lt;typename T  = detail::array_autodeduce, typename... Args&gt; </td></tr>
<tr class="memitem:a2befb911f8c8b196b4ba81d50e20fb28"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a2befb911f8c8b196b4ba81d50e20fb28">make_array</a> (Args &amp;&amp;... args) noexcept -&gt; detail::array_return_type_t&lt; T, Args... &gt;</td></tr>
<tr class="memdesc:a2befb911f8c8b196b4ba81d50e20fb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make utility for creating a std::array.  <a href="#a2befb911f8c8b196b4ba81d50e20fb28">More...</a><br /></td></tr>
<tr class="separator:a2befb911f8c8b196b4ba81d50e20fb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c54cd7406cc5388e67323491e900826"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a0c54cd7406cc5388e67323491e900826"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::array&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a0c54cd7406cc5388e67323491e900826">to_array</a> (const T(&amp;array)[N]) noexcept(std::is_nothrow_copy_constructible&lt; T &gt;::value)</td></tr>
<tr class="memdesc:a0c54cd7406cc5388e67323491e900826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to convert raw arrays to std::array.  <a href="#a0c54cd7406cc5388e67323491e900826">More...</a><br /></td></tr>
<tr class="separator:a0c54cd7406cc5388e67323491e900826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966bc186dbddc974625ca051e42d2aed"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a966bc186dbddc974625ca051e42d2aed"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::array&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a966bc186dbddc974625ca051e42d2aed">to_array</a> (T(&amp;&amp;array)[N]) noexcept(std::is_nothrow_move_constructible&lt; T &gt;::value)</td></tr>
<tr class="memdesc:a966bc186dbddc974625ca051e42d2aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to convert raw arrays to std::array.  <a href="#a966bc186dbddc974625ca051e42d2aed">More...</a><br /></td></tr>
<tr class="separator:a966bc186dbddc974625ca051e42d2aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c74ab0d9ab7114d1c9954fdec69491"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a80c74ab0d9ab7114d1c9954fdec69491"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a80c74ab0d9ab7114d1c9954fdec69491">swap</a> (<a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a80c74ab0d9ab7114d1c9954fdec69491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <code>lhs</code> with <code>rhs</code>.  <a href="#a80c74ab0d9ab7114d1c9954fdec69491">More...</a><br /></td></tr>
<tr class="separator:a80c74ab0d9ab7114d1c9954fdec69491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23e5de00eb12c35f7cf1036db07de54"><td class="memTemplParams" colspan="2"><a id="ad23e5de00eb12c35f7cf1036db07de54"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad23e5de00eb12c35f7cf1036db07de54"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:ad23e5de00eb12c35f7cf1036db07de54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268dcaa06fb1aad287b7d9c2b25e153e"><td class="memTemplParams" colspan="2"><a id="a268dcaa06fb1aad287b7d9c2b25e153e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a268dcaa06fb1aad287b7d9c2b25e153e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a268dcaa06fb1aad287b7d9c2b25e153e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c3042007a58db704ae5e159e88fa7d"><td class="memTemplParams" colspan="2"><a id="ab5c3042007a58db704ae5e159e88fa7d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab5c3042007a58db704ae5e159e88fa7d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:ab5c3042007a58db704ae5e159e88fa7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c0bca779bc1f0e57c36a21ba59b58a"><td class="memTemplParams" colspan="2"><a id="ac8c0bca779bc1f0e57c36a21ba59b58a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac8c0bca779bc1f0e57c36a21ba59b58a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:ac8c0bca779bc1f0e57c36a21ba59b58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12dc8b41981cdc6d7bfb37c43d9fdf26"><td class="memTemplParams" colspan="2"><a id="a12dc8b41981cdc6d7bfb37c43d9fdf26"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a12dc8b41981cdc6d7bfb37c43d9fdf26"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a12dc8b41981cdc6d7bfb37c43d9fdf26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb39cc7bf99225132194db4bc572100"><td class="memTemplParams" colspan="2"><a id="a7bb39cc7bf99225132194db4bc572100"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7bb39cc7bf99225132194db4bc572100"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a7bb39cc7bf99225132194db4bc572100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3db2a94cbc183d4423878f39289c44"><td class="memTemplParams" colspan="2"><a id="a6b3db2a94cbc183d4423878f39289c44"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6b3db2a94cbc183d4423878f39289c44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a6b3db2a94cbc183d4423878f39289c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe820e645aa1a0646e2b1b884b62c67"><td class="memTemplParams" colspan="2"><a id="a1fe820e645aa1a0646e2b1b884b62c67"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1fe820e645aa1a0646e2b1b884b62c67"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a1fe820e645aa1a0646e2b1b884b62c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6091a51d5f25be0f1cd42a56324dfc"><td class="memTemplParams" colspan="2"><a id="aea6091a51d5f25be0f1cd42a56324dfc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aea6091a51d5f25be0f1cd42a56324dfc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aea6091a51d5f25be0f1cd42a56324dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953f3766a67ff8585ec097adda9e5b9c"><td class="memTemplParams" colspan="2"><a id="a953f3766a67ff8585ec097adda9e5b9c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a953f3766a67ff8585ec097adda9e5b9c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a953f3766a67ff8585ec097adda9e5b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace573cae3ee1cf89f0106274a4bba8f5"><td class="memTemplParams" colspan="2"><a id="ace573cae3ee1cf89f0106274a4bba8f5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace573cae3ee1cf89f0106274a4bba8f5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ace573cae3ee1cf89f0106274a4bba8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55f8fb8bcd638d5bce26996bdded044"><td class="memTemplParams" colspan="2"><a id="ab55f8fb8bcd638d5bce26996bdded044"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab55f8fb8bcd638d5bce26996bdded044"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ab55f8fb8bcd638d5bce26996bdded044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3218a0470f36a953473ffc7997494b2e"><td class="memTemplParams" colspan="2"><a id="a3218a0470f36a953473ffc7997494b2e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3218a0470f36a953473ffc7997494b2e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a3218a0470f36a953473ffc7997494b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aacd178461ac8159314793a3fa7dee6"><td class="memTemplParams" colspan="2"><a id="a7aacd178461ac8159314793a3fa7dee6"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a7aacd178461ac8159314793a3fa7dee6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a7aacd178461ac8159314793a3fa7dee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9de76842f31be5040cc11a5d14ea85"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a8c9de76842f31be5040cc11a5d14ea85"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a8c9de76842f31be5040cc11a5d14ea85">hash_value</a> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:a8c9de76842f31be5040cc11a5d14ea85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the hash from a given <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html" title="The basic_hashed_string_view is a compile-time hashed wrapper around a non-owning string (basic_strin...">basic_hashed_string_view</a>.  <a href="#a8c9de76842f31be5040cc11a5d14ea85">More...</a><br /></td></tr>
<tr class="separator:a8c9de76842f31be5040cc11a5d14ea85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d7a99fea08d25193e75dbe255fbc32"><td class="memTemplParams" colspan="2"><a id="a72d7a99fea08d25193e75dbe255fbc32"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a72d7a99fea08d25193e75dbe255fbc32"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a72d7a99fea08d25193e75dbe255fbc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59c457ef3d83af771f005057e9b02f9"><td class="memTemplParams" colspan="2"><a id="aa59c457ef3d83af771f005057e9b02f9"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:aa59c457ef3d83af771f005057e9b02f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aa59c457ef3d83af771f005057e9b02f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a171e4e3954c5807fd7b1c4a20b230"><td class="memTemplParams" colspan="2"><a id="ad4a171e4e3954c5807fd7b1c4a20b230"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ad4a171e4e3954c5807fd7b1c4a20b230"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ad4a171e4e3954c5807fd7b1c4a20b230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d2e5dcd1cda5e3e54fc275f92eb058"><td class="memTemplParams" colspan="2"><a id="a40d2e5dcd1cda5e3e54fc275f92eb058"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a40d2e5dcd1cda5e3e54fc275f92eb058"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a40d2e5dcd1cda5e3e54fc275f92eb058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7440a43d60d590f2e53390983851c84e"><td class="memTemplParams" colspan="2"><a id="a7440a43d60d590f2e53390983851c84e"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a7440a43d60d590f2e53390983851c84e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a7440a43d60d590f2e53390983851c84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b16396013aa8c9efde018e9fcd6e707"><td class="memTemplParams" colspan="2"><a id="a8b16396013aa8c9efde018e9fcd6e707"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a8b16396013aa8c9efde018e9fcd6e707"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a8b16396013aa8c9efde018e9fcd6e707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f8ebd27b3739cf9b4c06a2f7a42665"><td class="memTemplParams" colspan="2"><a id="aa9f8ebd27b3739cf9b4c06a2f7a42665"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:aa9f8ebd27b3739cf9b4c06a2f7a42665"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aa9f8ebd27b3739cf9b4c06a2f7a42665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada96c9c62a6993a4cc18644383068624"><td class="memTemplParams" colspan="2"><a id="ada96c9c62a6993a4cc18644383068624"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ada96c9c62a6993a4cc18644383068624"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ada96c9c62a6993a4cc18644383068624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a346165e21cadf8a191e31d4bae73a"><td class="memTemplParams" colspan="2"><a id="a85a346165e21cadf8a191e31d4bae73a"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a85a346165e21cadf8a191e31d4bae73a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a85a346165e21cadf8a191e31d4bae73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7c4ea4c6c5d3a6e11a3d04914d3218"><td class="memTemplParams" colspan="2"><a id="a7c7c4ea4c6c5d3a6e11a3d04914d3218"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a7c7c4ea4c6c5d3a6e11a3d04914d3218"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a7c7c4ea4c6c5d3a6e11a3d04914d3218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253b2fbb26ab5eeb7550c9289169fd02"><td class="memTemplParams" colspan="2"><a id="a253b2fbb26ab5eeb7550c9289169fd02"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a253b2fbb26ab5eeb7550c9289169fd02"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a253b2fbb26ab5eeb7550c9289169fd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaba88fca2574db46e2bb834a874985a"><td class="memTemplParams" colspan="2"><a id="afaba88fca2574db46e2bb834a874985a"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:afaba88fca2574db46e2bb834a874985a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:afaba88fca2574db46e2bb834a874985a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e824c36ab407b906ee383f2ca172e64"><td class="memTemplParams" colspan="2"><a id="a8e824c36ab407b906ee383f2ca172e64"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a8e824c36ab407b906ee383f2ca172e64"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a8e824c36ab407b906ee383f2ca172e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17c80dfeeb5ac7d563fa38f8db0147f"><td class="memTemplParams" colspan="2"><a id="ac17c80dfeeb5ac7d563fa38f8db0147f"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ac17c80dfeeb5ac7d563fa38f8db0147f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ac17c80dfeeb5ac7d563fa38f8db0147f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7cbf835145a81f781e5160ce73d949"><td class="memTemplParams" colspan="2"><a id="aac7cbf835145a81f781e5160ce73d949"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:aac7cbf835145a81f781e5160ce73d949"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aac7cbf835145a81f781e5160ce73d949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d34d469e08b2f602aa58f7b79b070a3"><td class="memTemplParams" colspan="2"><a id="a9d34d469e08b2f602aa58f7b79b070a3"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a9d34d469e08b2f602aa58f7b79b070a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a9d34d469e08b2f602aa58f7b79b070a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d82c6c57f5fa71ea9e9e73891e095f"><td class="memTemplParams" colspan="2"><a id="a14d82c6c57f5fa71ea9e9e73891e095f"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a14d82c6c57f5fa71ea9e9e73891e095f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a14d82c6c57f5fa71ea9e9e73891e095f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c02fbcbed816a95ab5d0d1ba38083e1"><td class="memTemplParams" colspan="2"><a id="a0c02fbcbed816a95ab5d0d1ba38083e1"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a0c02fbcbed816a95ab5d0d1ba38083e1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a0c02fbcbed816a95ab5d0d1ba38083e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48a09e8cd7ce4187908c1b8600bb97c"><td class="memTemplParams" colspan="2"><a id="ae48a09e8cd7ce4187908c1b8600bb97c"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:ae48a09e8cd7ce4187908c1b8600bb97c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ae48a09e8cd7ce4187908c1b8600bb97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab931efe137588922f0e94656ecc1f973"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:ab931efe137588922f0e94656ecc1f973"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ab931efe137588922f0e94656ecc1f973">hash_value</a> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:ab931efe137588922f0e94656ecc1f973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the hash from a given <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html" title="The basic_hashed_string_view is a compile-time hashed wrapper around a non-owning string (basic_strin...">basic_hashed_string_view</a>.  <a href="#ab931efe137588922f0e94656ecc1f973">More...</a><br /></td></tr>
<tr class="separator:ab931efe137588922f0e94656ecc1f973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cfa4752414369777c803a36bc595e8"><td class="memTemplParams" colspan="2"><a id="a16cfa4752414369777c803a36bc595e8"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a16cfa4752414369777c803a36bc595e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a16cfa4752414369777c803a36bc595e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa6ad1568938370a7ff88d2d87a1807"><td class="memTemplParams" colspan="2"><a id="a3fa6ad1568938370a7ff88d2d87a1807"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a3fa6ad1568938370a7ff88d2d87a1807"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a3fa6ad1568938370a7ff88d2d87a1807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521037ed6d846fa9a104b1450ddb0ad1"><td class="memTemplParams" colspan="2"><a id="a521037ed6d846fa9a104b1450ddb0ad1"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a521037ed6d846fa9a104b1450ddb0ad1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a521037ed6d846fa9a104b1450ddb0ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abceacab6bbe4910e8a744ffb1e5df94c"><td class="memTemplParams" colspan="2"><a id="abceacab6bbe4910e8a744ffb1e5df94c"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:abceacab6bbe4910e8a744ffb1e5df94c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:abceacab6bbe4910e8a744ffb1e5df94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16270f0a16b15dddcc04131af27a3dc4"><td class="memTemplParams" colspan="2"><a id="a16270f0a16b15dddcc04131af27a3dc4"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a16270f0a16b15dddcc04131af27a3dc4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a16270f0a16b15dddcc04131af27a3dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac421e4c5ca5f9d9b529fd302c4e0f5d"><td class="memTemplParams" colspan="2"><a id="aac421e4c5ca5f9d9b529fd302c4e0f5d"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:aac421e4c5ca5f9d9b529fd302c4e0f5d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aac421e4c5ca5f9d9b529fd302c4e0f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949bcb6cedbc08ec6aac45fc2ed17e51"><td class="memTemplParams" colspan="2">template&lt;typename T , std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a949bcb6cedbc08ec6aac45fc2ed17e51"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a949bcb6cedbc08ec6aac45fc2ed17e51">operator==</a> (const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;lhs, const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a949bcb6cedbc08ec6aac45fc2ed17e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs equality comparison between all entries in the span.  <a href="#a949bcb6cedbc08ec6aac45fc2ed17e51">More...</a><br /></td></tr>
<tr class="separator:a949bcb6cedbc08ec6aac45fc2ed17e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef95178467c3eb83c8c648eb062333b"><td class="memTemplParams" colspan="2">template&lt;typename T , std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a0ef95178467c3eb83c8c648eb062333b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a0ef95178467c3eb83c8c648eb062333b">operator!=</a> (const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;lhs, const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a0ef95178467c3eb83c8c648eb062333b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs inequality comparison between all entries in the span.  <a href="#a0ef95178467c3eb83c8c648eb062333b">More...</a><br /></td></tr>
<tr class="separator:a0ef95178467c3eb83c8c648eb062333b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af144d9c063aae932355474287ad14759"><td class="memTemplParams" colspan="2">template&lt;typename T , std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:af144d9c063aae932355474287ad14759"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#af144d9c063aae932355474287ad14759">operator&lt;</a> (const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;lhs, const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:af144d9c063aae932355474287ad14759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexographically compares all entries in the span.  <a href="#af144d9c063aae932355474287ad14759">More...</a><br /></td></tr>
<tr class="separator:af144d9c063aae932355474287ad14759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3ac8246dbe309e18132145a226d5f9"><td class="memTemplParams" colspan="2">template&lt;typename T , std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:acc3ac8246dbe309e18132145a226d5f9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#acc3ac8246dbe309e18132145a226d5f9">operator&lt;=</a> (const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;lhs, const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:acc3ac8246dbe309e18132145a226d5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexographically compares all entries in the span.  <a href="#acc3ac8246dbe309e18132145a226d5f9">More...</a><br /></td></tr>
<tr class="separator:acc3ac8246dbe309e18132145a226d5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d826a3a556768ab643121194d3d5d3"><td class="memTemplParams" colspan="2">template&lt;typename T , std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a46d826a3a556768ab643121194d3d5d3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a46d826a3a556768ab643121194d3d5d3">operator&gt;</a> (const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;lhs, const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a46d826a3a556768ab643121194d3d5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexographically compares all entries in the span.  <a href="#a46d826a3a556768ab643121194d3d5d3">More...</a><br /></td></tr>
<tr class="separator:a46d826a3a556768ab643121194d3d5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4850b6a62191725450ad5a4c37dfdbcd"><td class="memTemplParams" colspan="2">template&lt;typename T , std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a4850b6a62191725450ad5a4c37dfdbcd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a4850b6a62191725450ad5a4c37dfdbcd">operator&gt;=</a> (const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;lhs, const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a4850b6a62191725450ad5a4c37dfdbcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexographically compares all entries in the span.  <a href="#a4850b6a62191725450ad5a4c37dfdbcd">More...</a><br /></td></tr>
<tr class="separator:a4850b6a62191725450ad5a4c37dfdbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f350703033effb94b5441aa17bccc02"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a6f350703033effb94b5441aa17bccc02"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a6f350703033effb94b5441aa17bccc02">hash_value</a> (const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:a6f350703033effb94b5441aa17bccc02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes a std::basic_string.  <a href="#a6f350703033effb94b5441aa17bccc02">More...</a><br /></td></tr>
<tr class="separator:a6f350703033effb94b5441aa17bccc02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca339d8647a8939fccfe7e0aef8b9d7"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:adca339d8647a8939fccfe7e0aef8b9d7"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#adca339d8647a8939fccfe7e0aef8b9d7">hash_value</a> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:adca339d8647a8939fccfe7e0aef8b9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the hash from a given <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html" title="A wrapper around non-owned strings. ">basic_string_view</a>.  <a href="#adca339d8647a8939fccfe7e0aef8b9d7">More...</a><br /></td></tr>
<tr class="separator:adca339d8647a8939fccfe7e0aef8b9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1580085f3114393d66c277bc11cb5690"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a1580085f3114393d66c277bc11cb5690"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; CharT, Traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a1580085f3114393d66c277bc11cb5690">operator&lt;&lt;</a> (std::basic_ostream&lt; CharT, Traits &gt; &amp;o, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;str)</td></tr>
<tr class="memdesc:a1580085f3114393d66c277bc11cb5690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for ostream output of <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html" title="A wrapper around non-owned strings. ">basic_string_view</a>.  <a href="#a1580085f3114393d66c277bc11cb5690">More...</a><br /></td></tr>
<tr class="separator:a1580085f3114393d66c277bc11cb5690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b18b47d716b42f23afa68f5b197f97"><td class="memTemplParams" colspan="2"><a id="ae8b18b47d716b42f23afa68f5b197f97"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:ae8b18b47d716b42f23afa68f5b197f97"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ae8b18b47d716b42f23afa68f5b197f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba40e0a952f28127626caa2438700a5c"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:aba40e0a952f28127626caa2438700a5c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aba40e0a952f28127626caa2438700a5c">operator==</a> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aba40e0a952f28127626caa2438700a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares equality between the two basic_string_views.  <a href="#aba40e0a952f28127626caa2438700a5c">More...</a><br /></td></tr>
<tr class="separator:aba40e0a952f28127626caa2438700a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cfdb2919ae50381d788a8eb25bb630"><td class="memTemplParams" colspan="2"><a id="a04cfdb2919ae50381d788a8eb25bb630"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a04cfdb2919ae50381d788a8eb25bb630"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, CharT(&amp;rhs)[N]) noexcept</td></tr>
<tr class="separator:a04cfdb2919ae50381d788a8eb25bb630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76194ef979bd8ac49293cb8c0c210a0"><td class="memTemplParams" colspan="2"><a id="ac76194ef979bd8ac49293cb8c0c210a0"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:ac76194ef979bd8ac49293cb8c0c210a0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (CharT(&amp;lhs)[N], const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ac76194ef979bd8ac49293cb8c0c210a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc0ff5eabe69aadb187f469a107726f"><td class="memTemplParams" colspan="2"><a id="a6cc0ff5eabe69aadb187f469a107726f"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a6cc0ff5eabe69aadb187f469a107726f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, const CharT *rhs) noexcept</td></tr>
<tr class="separator:a6cc0ff5eabe69aadb187f469a107726f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad368a5dbaf54db47d245458ccc64fbf4"><td class="memTemplParams" colspan="2"><a id="ad368a5dbaf54db47d245458ccc64fbf4"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:ad368a5dbaf54db47d245458ccc64fbf4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const CharT *lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ad368a5dbaf54db47d245458ccc64fbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae57d4d7aaba4d6f20bb720ed6b981d"><td class="memTemplParams" colspan="2"><a id="a2ae57d4d7aaba4d6f20bb720ed6b981d"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a2ae57d4d7aaba4d6f20bb720ed6b981d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a2ae57d4d7aaba4d6f20bb720ed6b981d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a21f9661cd4b6cb064189b3f03444db"><td class="memTemplParams" colspan="2"><a id="a2a21f9661cd4b6cb064189b3f03444db"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a2a21f9661cd4b6cb064189b3f03444db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a2a21f9661cd4b6cb064189b3f03444db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf027ebca228450fda5cef3c2c60d3c"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a2bf027ebca228450fda5cef3c2c60d3c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a2bf027ebca228450fda5cef3c2c60d3c">operator!=</a> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a2bf027ebca228450fda5cef3c2c60d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares inequality between the two basic_string_views.  <a href="#a2bf027ebca228450fda5cef3c2c60d3c">More...</a><br /></td></tr>
<tr class="separator:a2bf027ebca228450fda5cef3c2c60d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7dce5eff3ab071fd6f339da0b31018"><td class="memTemplParams" colspan="2"><a id="a6c7dce5eff3ab071fd6f339da0b31018"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a6c7dce5eff3ab071fd6f339da0b31018"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, CharT(&amp;rhs)[N]) noexcept</td></tr>
<tr class="separator:a6c7dce5eff3ab071fd6f339da0b31018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a4a193c01a969387b95851a91a0324"><td class="memTemplParams" colspan="2"><a id="ac9a4a193c01a969387b95851a91a0324"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:ac9a4a193c01a969387b95851a91a0324"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (CharT(&amp;lhs)[N], const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ac9a4a193c01a969387b95851a91a0324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a06bbfb2b9b6eb6ec4365aa52ef899a"><td class="memTemplParams" colspan="2"><a id="a0a06bbfb2b9b6eb6ec4365aa52ef899a"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a0a06bbfb2b9b6eb6ec4365aa52ef899a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const CharT *rhs) noexcept</td></tr>
<tr class="separator:a0a06bbfb2b9b6eb6ec4365aa52ef899a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36ac1a107cb00d968e4fc0ded13e954"><td class="memTemplParams" colspan="2"><a id="af36ac1a107cb00d968e4fc0ded13e954"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:af36ac1a107cb00d968e4fc0ded13e954"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const CharT *lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:af36ac1a107cb00d968e4fc0ded13e954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a640f943a56759d2ceb7245914bd10"><td class="memTemplParams" colspan="2"><a id="a86a640f943a56759d2ceb7245914bd10"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a86a640f943a56759d2ceb7245914bd10"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a86a640f943a56759d2ceb7245914bd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae463892264f6cc2ee3630f5c55a363a2"><td class="memTemplParams" colspan="2"><a id="ae463892264f6cc2ee3630f5c55a363a2"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ae463892264f6cc2ee3630f5c55a363a2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ae463892264f6cc2ee3630f5c55a363a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415444efbcfeefad454cd010cc9b344f"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a415444efbcfeefad454cd010cc9b344f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a415444efbcfeefad454cd010cc9b344f">operator&lt;</a> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a415444efbcfeefad454cd010cc9b344f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the left string is less than the right substring.  <a href="#a415444efbcfeefad454cd010cc9b344f">More...</a><br /></td></tr>
<tr class="separator:a415444efbcfeefad454cd010cc9b344f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6cb30c565041da9ed9c59e954a3ddf"><td class="memTemplParams" colspan="2"><a id="a4d6cb30c565041da9ed9c59e954a3ddf"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a4d6cb30c565041da9ed9c59e954a3ddf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, CharT(&amp;rhs)[N]) noexcept</td></tr>
<tr class="separator:a4d6cb30c565041da9ed9c59e954a3ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd45f38b3f0fb5228de886e6ab35568"><td class="memTemplParams" colspan="2"><a id="a3dd45f38b3f0fb5228de886e6ab35568"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a3dd45f38b3f0fb5228de886e6ab35568"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (CharT(&amp;lhs)[N], const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a3dd45f38b3f0fb5228de886e6ab35568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74ca39e25eaebde57a0244ec1e22f89"><td class="memTemplParams" colspan="2"><a id="af74ca39e25eaebde57a0244ec1e22f89"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:af74ca39e25eaebde57a0244ec1e22f89"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const CharT *rhs) noexcept</td></tr>
<tr class="separator:af74ca39e25eaebde57a0244ec1e22f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1651b7ea5e9e84469ff1a87feba6352d"><td class="memTemplParams" colspan="2"><a id="a1651b7ea5e9e84469ff1a87feba6352d"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a1651b7ea5e9e84469ff1a87feba6352d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const CharT *lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a1651b7ea5e9e84469ff1a87feba6352d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d706a523945548758e85dc1df63764"><td class="memTemplParams" colspan="2"><a id="a19d706a523945548758e85dc1df63764"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a19d706a523945548758e85dc1df63764"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a19d706a523945548758e85dc1df63764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f25173ae7991dd1e66ea68eec4f7955"><td class="memTemplParams" colspan="2"><a id="a9f25173ae7991dd1e66ea68eec4f7955"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a9f25173ae7991dd1e66ea68eec4f7955"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a9f25173ae7991dd1e66ea68eec4f7955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b91bebb63c963188f090691677e815"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a69b91bebb63c963188f090691677e815"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a69b91bebb63c963188f090691677e815">operator&gt;</a> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a69b91bebb63c963188f090691677e815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab738bc42afbf78cb4dbaeb61acc9a3e2"><td class="memTemplParams" colspan="2"><a id="ab738bc42afbf78cb4dbaeb61acc9a3e2"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:ab738bc42afbf78cb4dbaeb61acc9a3e2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, CharT(&amp;rhs)[N]) noexcept</td></tr>
<tr class="separator:ab738bc42afbf78cb4dbaeb61acc9a3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0402cf09f11089c1378ec40199b4de23"><td class="memTemplParams" colspan="2"><a id="a0402cf09f11089c1378ec40199b4de23"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a0402cf09f11089c1378ec40199b4de23"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (CharT(&amp;lhs)[N], const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a0402cf09f11089c1378ec40199b4de23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2575e73f2cb4e5a9b345e083deea646"><td class="memTemplParams" colspan="2"><a id="ab2575e73f2cb4e5a9b345e083deea646"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:ab2575e73f2cb4e5a9b345e083deea646"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const CharT *rhs) noexcept</td></tr>
<tr class="separator:ab2575e73f2cb4e5a9b345e083deea646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e35a2d2ef2cd6322c380eb41e8a0778"><td class="memTemplParams" colspan="2"><a id="a4e35a2d2ef2cd6322c380eb41e8a0778"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a4e35a2d2ef2cd6322c380eb41e8a0778"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const CharT *lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a4e35a2d2ef2cd6322c380eb41e8a0778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539f5f98e11d8b2c8dbc1c0285e833b7"><td class="memTemplParams" colspan="2"><a id="a539f5f98e11d8b2c8dbc1c0285e833b7"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a539f5f98e11d8b2c8dbc1c0285e833b7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a539f5f98e11d8b2c8dbc1c0285e833b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af007b68abef36d1a098334fe7874d2e0"><td class="memTemplParams" colspan="2"><a id="af007b68abef36d1a098334fe7874d2e0"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:af007b68abef36d1a098334fe7874d2e0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:af007b68abef36d1a098334fe7874d2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26180d86b4a63447cb01a783830c132"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:aa26180d86b4a63447cb01a783830c132"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aa26180d86b4a63447cb01a783830c132">operator&lt;=</a> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aa26180d86b4a63447cb01a783830c132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82932b40acc93e5e80787626764fd16"><td class="memTemplParams" colspan="2"><a id="ac82932b40acc93e5e80787626764fd16"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:ac82932b40acc93e5e80787626764fd16"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, CharT(&amp;rhs)[N]) noexcept</td></tr>
<tr class="separator:ac82932b40acc93e5e80787626764fd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ae3dd067e28d330495df20a78694fc"><td class="memTemplParams" colspan="2"><a id="a17ae3dd067e28d330495df20a78694fc"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a17ae3dd067e28d330495df20a78694fc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (CharT(&amp;lhs)[N], const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a17ae3dd067e28d330495df20a78694fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98145429af3ea46b4cf6cb38f119b909"><td class="memTemplParams" colspan="2"><a id="a98145429af3ea46b4cf6cb38f119b909"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a98145429af3ea46b4cf6cb38f119b909"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const CharT *rhs) noexcept</td></tr>
<tr class="separator:a98145429af3ea46b4cf6cb38f119b909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff07010e479b43f73503fcbb76647df"><td class="memTemplParams" colspan="2"><a id="a4ff07010e479b43f73503fcbb76647df"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a4ff07010e479b43f73503fcbb76647df"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const CharT *lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a4ff07010e479b43f73503fcbb76647df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203fbef324541c74f6ecfca523e44f45"><td class="memTemplParams" colspan="2"><a id="a203fbef324541c74f6ecfca523e44f45"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a203fbef324541c74f6ecfca523e44f45"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a203fbef324541c74f6ecfca523e44f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2224c89a580ca38b315d31d9c937f33"><td class="memTemplParams" colspan="2"><a id="ad2224c89a580ca38b315d31d9c937f33"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ad2224c89a580ca38b315d31d9c937f33"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ad2224c89a580ca38b315d31d9c937f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab692e38a5d9027b524c7532b189d8ff1"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:ab692e38a5d9027b524c7532b189d8ff1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ab692e38a5d9027b524c7532b189d8ff1">operator&gt;=</a> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ab692e38a5d9027b524c7532b189d8ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9cd492fc1e8ff479d9877e57224abf"><td class="memTemplParams" colspan="2"><a id="a3c9cd492fc1e8ff479d9877e57224abf"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a3c9cd492fc1e8ff479d9877e57224abf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, CharT(&amp;rhs)[N]) noexcept</td></tr>
<tr class="separator:a3c9cd492fc1e8ff479d9877e57224abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4611a988120f1e8fc340fa8e2ac66282"><td class="memTemplParams" colspan="2"><a id="a4611a988120f1e8fc340fa8e2ac66282"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a4611a988120f1e8fc340fa8e2ac66282"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (CharT(&amp;lhs)[N], const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a4611a988120f1e8fc340fa8e2ac66282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffbf3a347d72e521e5f310e10724251"><td class="memTemplParams" colspan="2"><a id="abffbf3a347d72e521e5f310e10724251"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:abffbf3a347d72e521e5f310e10724251"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const CharT *rhs) noexcept</td></tr>
<tr class="separator:abffbf3a347d72e521e5f310e10724251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3688ab7c84f8b2b6a12cea27882831"><td class="memTemplParams" colspan="2"><a id="a9c3688ab7c84f8b2b6a12cea27882831"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a9c3688ab7c84f8b2b6a12cea27882831"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const CharT *lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a9c3688ab7c84f8b2b6a12cea27882831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf12778606813885b01e3a36e6e3566"><td class="memTemplParams" colspan="2"><a id="aaaf12778606813885b01e3a36e6e3566"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:aaaf12778606813885b01e3a36e6e3566"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aaaf12778606813885b01e3a36e6e3566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d37bde67cc0f72cfa523b8682d0794e"><td class="memTemplParams" colspan="2"><a id="a3d37bde67cc0f72cfa523b8682d0794e"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a3d37bde67cc0f72cfa523b8682d0794e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a3d37bde67cc0f72cfa523b8682d0794e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b7dfdbd963da0f7c8ebf9bccb64a6a"><td class="memTemplParams" colspan="2"><a id="af2b7dfdbd963da0f7c8ebf9bccb64a6a"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:af2b7dfdbd963da0f7c8ebf9bccb64a6a"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; CharT, Traits, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="separator:af2b7dfdbd963da0f7c8ebf9bccb64a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c20018db91ce9a900d2977e48ddfa70"><td class="memTemplParams" colspan="2"><a id="a6c20018db91ce9a900d2977e48ddfa70"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a6c20018db91ce9a900d2977e48ddfa70"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; CharT, Traits, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;rhs)</td></tr>
<tr class="separator:a6c20018db91ce9a900d2977e48ddfa70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360314b0bf0ee3c7b4c684590fa45553"><td class="memTemplParams" colspan="2"><a id="a360314b0bf0ee3c7b4c684590fa45553"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a360314b0bf0ee3c7b4c684590fa45553"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="separator:a360314b0bf0ee3c7b4c684590fa45553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a19a1361516964cca1fd547d475c5d1"><td class="memTemplParams" colspan="2"><a id="a6a19a1361516964cca1fd547d475c5d1"></a>
template&lt;typename Ptr , typename U &gt; </td></tr>
<tr class="memitem:a6a19a1361516964cca1fd547d475c5d1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../dc/d83/classbit_1_1stl_1_1tagged__iterator.html">tagged_iterator</a>&lt; Ptr, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="../../dc/d83/classbit_1_1stl_1_1tagged__iterator.html">tagged_iterator</a>&lt; Ptr, U &gt; &amp;lhs, typename <a class="el" href="../../dc/d83/classbit_1_1stl_1_1tagged__iterator.html">tagged_iterator</a>&lt; Ptr, U &gt;::difference_type rhs) noexcept</td></tr>
<tr class="separator:a6a19a1361516964cca1fd547d475c5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33a4cb0b9a93e3b39c0f4e005d6a518"><td class="memTemplParams" colspan="2"><a id="ae33a4cb0b9a93e3b39c0f4e005d6a518"></a>
template&lt;typename Ptr , typename U &gt; </td></tr>
<tr class="memitem:ae33a4cb0b9a93e3b39c0f4e005d6a518"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../dc/d83/classbit_1_1stl_1_1tagged__iterator.html">tagged_iterator</a>&lt; Ptr, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (typename <a class="el" href="../../dc/d83/classbit_1_1stl_1_1tagged__iterator.html">tagged_iterator</a>&lt; Ptr, U &gt;::difference_type rhs, const <a class="el" href="../../dc/d83/classbit_1_1stl_1_1tagged__iterator.html">tagged_iterator</a>&lt; Ptr, U &gt; &amp;lhs) noexcept</td></tr>
<tr class="separator:ae33a4cb0b9a93e3b39c0f4e005d6a518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2e821632cad3a4658bb16238d708d8"><td class="memTemplParams" colspan="2"><a id="a6f2e821632cad3a4658bb16238d708d8"></a>
template&lt;typename Ptr , typename U &gt; </td></tr>
<tr class="memitem:a6f2e821632cad3a4658bb16238d708d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../dc/d83/classbit_1_1stl_1_1tagged__iterator.html">tagged_iterator</a>&lt; Ptr, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="../../dc/d83/classbit_1_1stl_1_1tagged__iterator.html">tagged_iterator</a>&lt; Ptr, U &gt; &amp;lhs, typename <a class="el" href="../../dc/d83/classbit_1_1stl_1_1tagged__iterator.html">tagged_iterator</a>&lt; Ptr, U &gt;::difference_type rhs) noexcept</td></tr>
<tr class="separator:a6f2e821632cad3a4658bb16238d708d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3858d10559ba8d9064205690c1e26ea3"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename Iterator &gt; </td></tr>
<tr class="memitem:a3858d10559ba8d9064205690c1e26ea3"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../de/d9c/classbit_1_1stl_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; N, Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3858d10559ba8d9064205690c1e26ea3">make_tuple_element_iterator</a> (Iterator it)</td></tr>
<tr class="memdesc:a3858d10559ba8d9064205690c1e26ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to type-deduce and make an iterator for iterating specific tuple elements.  <a href="#a3858d10559ba8d9064205690c1e26ea3">More...</a><br /></td></tr>
<tr class="separator:a3858d10559ba8d9064205690c1e26ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33bddf083a04210702a30106d991b3f"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:aa33bddf083a04210702a30106d991b3f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../de/d9c/classbit_1_1stl_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; 0, Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aa33bddf083a04210702a30106d991b3f">make_key_iterator</a> (Iterator it)</td></tr>
<tr class="memdesc:aa33bddf083a04210702a30106d991b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for making a tuple iterator that only iterates the first tuple element, which is the key in associative containers.  <a href="#aa33bddf083a04210702a30106d991b3f">More...</a><br /></td></tr>
<tr class="separator:aa33bddf083a04210702a30106d991b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643a6bd17072910d8f851d40eeababa7"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a643a6bd17072910d8f851d40eeababa7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../de/d9c/classbit_1_1stl_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; 1, Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a643a6bd17072910d8f851d40eeababa7">make_value_iterator</a> (Iterator it)</td></tr>
<tr class="memdesc:a643a6bd17072910d8f851d40eeababa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for making a tuple iterator that only iterates the second tuple element, which is the value in associative containers.  <a href="#a643a6bd17072910d8f851d40eeababa7">More...</a><br /></td></tr>
<tr class="separator:a643a6bd17072910d8f851d40eeababa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65508369ae89754862b70e7b4b93542"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae65508369ae89754862b70e7b4b93542"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ae65508369ae89754862b70e7b4b93542">swap</a> (<a class="el" href="../../d1/d8c/classbit_1_1stl_1_1clone__ptr.html">clone_ptr</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../d1/d8c/classbit_1_1stl_1_1clone__ptr.html">clone_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ae65508369ae89754862b70e7b4b93542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of two clone_ptrs.  <a href="#ae65508369ae89754862b70e7b4b93542">More...</a><br /></td></tr>
<tr class="separator:ae65508369ae89754862b70e7b4b93542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f68ff633bb58e596cba7f9f040f21a"><td class="memTemplParams" colspan="2"><a id="a85f68ff633bb58e596cba7f9f040f21a"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a85f68ff633bb58e596cba7f9f040f21a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/d8c/classbit_1_1stl_1_1clone__ptr.html">clone_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_clone</b> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:a85f68ff633bb58e596cba7f9f040f21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751ed4d6d28955eef4d88c40e7573851"><td class="memTemplParams" colspan="2"><a id="a751ed4d6d28955eef4d88c40e7573851"></a>
template&lt;typename T , typename Allocator , typename... Args&gt; </td></tr>
<tr class="memitem:a751ed4d6d28955eef4d88c40e7573851"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/d8c/classbit_1_1stl_1_1clone__ptr.html">clone_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>allocate_clone</b> (const Allocator &amp;, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a751ed4d6d28955eef4d88c40e7573851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb3979b1bfe78dd08f8331113ca197e"><td class="memTemplParams" colspan="2">template&lt;typename Deleter , typename T &gt; </td></tr>
<tr class="memitem:afbb3979b1bfe78dd08f8331113ca197e"><td class="memTemplItemLeft" align="right" valign="top">Deleter *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#afbb3979b1bfe78dd08f8331113ca197e">get_deleter</a> (const <a class="el" href="../../d1/d8c/classbit_1_1stl_1_1clone__ptr.html">clone_ptr</a>&lt; T &gt; &amp;p) noexcept</td></tr>
<tr class="memdesc:afbb3979b1bfe78dd08f8331113ca197e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the <code>p's</code> deleter.  <a href="#afbb3979b1bfe78dd08f8331113ca197e">More...</a><br /></td></tr>
<tr class="separator:afbb3979b1bfe78dd08f8331113ca197e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86bf67c78fb7632490d91617b43f2400"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a86bf67c78fb7632490d91617b43f2400"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a86bf67c78fb7632490d91617b43f2400">swap</a> (<a class="el" href="../../d9/d6a/classbit_1_1stl_1_1fat__ptr.html">fat_ptr</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../d9/d6a/classbit_1_1stl_1_1fat__ptr.html">fat_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a86bf67c78fb7632490d91617b43f2400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the instances of two fat_ptrs.  <a href="#a86bf67c78fb7632490d91617b43f2400">More...</a><br /></td></tr>
<tr class="separator:a86bf67c78fb7632490d91617b43f2400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579b291a6b48dec5d3278c1e08170fae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a579b291a6b48dec5d3278c1e08170fae"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a579b291a6b48dec5d3278c1e08170fae">hash_value</a> (const <a class="el" href="../../d9/d6a/classbit_1_1stl_1_1fat__ptr.html">fat_ptr</a>&lt; T &gt; &amp;val) noexcept</td></tr>
<tr class="memdesc:a579b291a6b48dec5d3278c1e08170fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes the <a class="el" href="../../d9/d6a/classbit_1_1stl_1_1fat__ptr.html" title="A fat pointer that contains the pointer and the size. ">fat_ptr</a>.  <a href="#a579b291a6b48dec5d3278c1e08170fae">More...</a><br /></td></tr>
<tr class="separator:a579b291a6b48dec5d3278c1e08170fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f133cf2b1663ebbe681a38cb112071"><td class="memTemplParams" colspan="2"><a id="ac6f133cf2b1663ebbe681a38cb112071"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ac6f133cf2b1663ebbe681a38cb112071"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d9/d6a/classbit_1_1stl_1_1fat__ptr.html">fat_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d9/d6a/classbit_1_1stl_1_1fat__ptr.html">fat_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ac6f133cf2b1663ebbe681a38cb112071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995019d8d49414dd52e4e176cc78da93"><td class="memTemplParams" colspan="2"><a id="a995019d8d49414dd52e4e176cc78da93"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a995019d8d49414dd52e4e176cc78da93"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d9/d6a/classbit_1_1stl_1_1fat__ptr.html">fat_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d9/d6a/classbit_1_1stl_1_1fat__ptr.html">fat_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a995019d8d49414dd52e4e176cc78da93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc2c7fbc892fb87ac565cbc9a29e8fa"><td class="memTemplParams" colspan="2"><a id="abbc2c7fbc892fb87ac565cbc9a29e8fa"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:abbc2c7fbc892fb87ac565cbc9a29e8fa"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d9/d6a/classbit_1_1stl_1_1fat__ptr.html">fat_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d9/d6a/classbit_1_1stl_1_1fat__ptr.html">fat_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:abbc2c7fbc892fb87ac565cbc9a29e8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c879cb398303bee240ad655ae78ab8c"><td class="memTemplParams" colspan="2"><a id="a5c879cb398303bee240ad655ae78ab8c"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a5c879cb398303bee240ad655ae78ab8c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d9/d6a/classbit_1_1stl_1_1fat__ptr.html">fat_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d9/d6a/classbit_1_1stl_1_1fat__ptr.html">fat_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a5c879cb398303bee240ad655ae78ab8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23547096826424ab02896979fbda709a"><td class="memTemplParams" colspan="2"><a id="a23547096826424ab02896979fbda709a"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a23547096826424ab02896979fbda709a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d9/d6a/classbit_1_1stl_1_1fat__ptr.html">fat_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d9/d6a/classbit_1_1stl_1_1fat__ptr.html">fat_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a23547096826424ab02896979fbda709a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7425c087af8dce385bc41417554cd95f"><td class="memTemplParams" colspan="2"><a id="a7425c087af8dce385bc41417554cd95f"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a7425c087af8dce385bc41417554cd95f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d9/d6a/classbit_1_1stl_1_1fat__ptr.html">fat_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d9/d6a/classbit_1_1stl_1_1fat__ptr.html">fat_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a7425c087af8dce385bc41417554cd95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffa940c73f4ad283c6d1bc0042ca46b"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:abffa940c73f4ad283c6d1bc0042ca46b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#abffa940c73f4ad283c6d1bc0042ca46b">address_from</a> (InputIterator &amp;it) noexcept -&gt; typename std::iterator_traits&lt; InputIterator &gt;::value_type *</td></tr>
<tr class="memdesc:abffa940c73f4ad283c6d1bc0042ca46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the actual address of the object referenced through an iterator <code>it</code>.  <a href="#abffa940c73f4ad283c6d1bc0042ca46b">More...</a><br /></td></tr>
<tr class="separator:abffa940c73f4ad283c6d1bc0042ca46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04c12401a97f0afbb5d9863e3454b3a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af04c12401a97f0afbb5d9863e3454b3a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#af04c12401a97f0afbb5d9863e3454b3a">dereference</a> (T &amp;ptr)</td></tr>
<tr class="memdesc:af04c12401a97f0afbb5d9863e3454b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereferences all levels of pointer indirection from the supplied pointer.  <a href="#af04c12401a97f0afbb5d9863e3454b3a">More...</a><br /></td></tr>
<tr class="separator:af04c12401a97f0afbb5d9863e3454b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9807ce838e4fd230b03f9796f2203888"><td class="memItemLeft" align="right" valign="top">std::uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a9807ce838e4fd230b03f9796f2203888">to_address</a> (void *ptr) noexcept</td></tr>
<tr class="memdesc:a9807ce838e4fd230b03f9796f2203888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a pointer <code>ptr</code> into an integral type representing the address.  <a href="#a9807ce838e4fd230b03f9796f2203888">More...</a><br /></td></tr>
<tr class="separator:a9807ce838e4fd230b03f9796f2203888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2bf516ec5150488457255f5b3f63cf"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a9e2bf516ec5150488457255f5b3f63cf">from_address</a> (std::uintptr_t address) noexcept</td></tr>
<tr class="memdesc:a9e2bf516ec5150488457255f5b3f63cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric address <code>address</code> into a pointer pointing to the address location.  <a href="#a9e2bf516ec5150488457255f5b3f63cf">More...</a><br /></td></tr>
<tr class="separator:a9e2bf516ec5150488457255f5b3f63cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f07967eb5d5b849827db763987c8fa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Deleter &gt; </td></tr>
<tr class="memitem:a21f07967eb5d5b849827db763987c8fa"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a21f07967eb5d5b849827db763987c8fa">hash_value</a> (const std::unique_ptr&lt; T, Deleter &gt; &amp;val) noexcept</td></tr>
<tr class="memdesc:a21f07967eb5d5b849827db763987c8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes a unique_ptr.  <a href="#a21f07967eb5d5b849827db763987c8fa">More...</a><br /></td></tr>
<tr class="separator:a21f07967eb5d5b849827db763987c8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbec1aa53918460d5481c91354848547"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acbec1aa53918460d5481c91354848547"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#acbec1aa53918460d5481c91354848547">hash_value</a> (const std::shared_ptr&lt; T &gt; &amp;val) noexcept</td></tr>
<tr class="memdesc:acbec1aa53918460d5481c91354848547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes a shared_ptr.  <a href="#acbec1aa53918460d5481c91354848547">More...</a><br /></td></tr>
<tr class="separator:acbec1aa53918460d5481c91354848547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1aac54f3c941e37118dd7091628d2b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac1aac54f3c941e37118dd7091628d2b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ac1aac54f3c941e37118dd7091628d2b8">swap</a> (<a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ac1aac54f3c941e37118dd7091628d2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> <code>lhs</code> with <code>rhs</code>.  <a href="#ac1aac54f3c941e37118dd7091628d2b8">More...</a><br /></td></tr>
<tr class="separator:ac1aac54f3c941e37118dd7091628d2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3b83a4b60aa7cc9b67201bdf733341"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8f3b83a4b60aa7cc9b67201bdf733341"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a8f3b83a4b60aa7cc9b67201bdf733341">hash_value</a> (const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;val) noexcept</td></tr>
<tr class="memdesc:a8f3b83a4b60aa7cc9b67201bdf733341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes this <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a>.  <a href="#a8f3b83a4b60aa7cc9b67201bdf733341">More...</a><br /></td></tr>
<tr class="separator:a8f3b83a4b60aa7cc9b67201bdf733341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd9da49e3cb4e053b125e324336be8a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abdd9da49e3cb4e053b125e324336be8a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#abdd9da49e3cb4e053b125e324336be8a">make_observer</a> (T *ptr) noexcept</td></tr>
<tr class="memdesc:abdd9da49e3cb4e053b125e324336be8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> from a raw pointer.  <a href="#abdd9da49e3cb4e053b125e324336be8a">More...</a><br /></td></tr>
<tr class="separator:abdd9da49e3cb4e053b125e324336be8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3a7cdb4778675a5d49b02a7f01a02e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , std::enable_if_t&lt;!std::is_same&lt; T, U &gt;::value &amp;&amp;std::is_convertible&lt; U *, T *&gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afe3a7cdb4778675a5d49b02a7f01a02e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#afe3a7cdb4778675a5d49b02a7f01a02e">make_observer</a> (U *ptr) noexcept</td></tr>
<tr class="memdesc:afe3a7cdb4778675a5d49b02a7f01a02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> from a raw pointer, and coerces it to the specified type.  <a href="#afe3a7cdb4778675a5d49b02a7f01a02e">More...</a><br /></td></tr>
<tr class="separator:afe3a7cdb4778675a5d49b02a7f01a02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf64affbaa7d1b456ae4be240ec6fc1c"><td class="memTemplParams" colspan="2">template&lt;typename Pointer &gt; </td></tr>
<tr class="memitem:aaf64affbaa7d1b456ae4be240ec6fc1c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aaf64affbaa7d1b456ae4be240ec6fc1c">make_observer</a> (const Pointer &amp;ptr) noexcept -&gt; decltype(make_observer(ptr.get()))</td></tr>
<tr class="memdesc:aaf64affbaa7d1b456ae4be240ec6fc1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> from a smart pointer.  <a href="#aaf64affbaa7d1b456ae4be240ec6fc1c">More...</a><br /></td></tr>
<tr class="separator:aaf64affbaa7d1b456ae4be240ec6fc1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5430a6c4a3f1cbe97bbc798b5eac11"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Pointer , std::enable_if&lt; detail::is_ptr_observable&lt; Pointer &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aca5430a6c4a3f1cbe97bbc798b5eac11"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aca5430a6c4a3f1cbe97bbc798b5eac11">make_observer</a> (const Pointer &amp;ptr) noexcept</td></tr>
<tr class="memdesc:aca5430a6c4a3f1cbe97bbc798b5eac11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> from a smart pointer.  <a href="#aca5430a6c4a3f1cbe97bbc798b5eac11">More...</a><br /></td></tr>
<tr class="separator:aca5430a6c4a3f1cbe97bbc798b5eac11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bad859d0d5552bdf32a1ed1c6e034da"><td class="memTemplParams" colspan="2"><a id="a1bad859d0d5552bdf32a1ed1c6e034da"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a1bad859d0d5552bdf32a1ed1c6e034da"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a1bad859d0d5552bdf32a1ed1c6e034da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1e8451cad6e4bac12e07c963dc83dc"><td class="memTemplParams" colspan="2"><a id="aba1e8451cad6e4bac12e07c963dc83dc"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aba1e8451cad6e4bac12e07c963dc83dc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aba1e8451cad6e4bac12e07c963dc83dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cce6a0756d4c74079d087b896bb3cab"><td class="memTemplParams" colspan="2"><a id="a4cce6a0756d4c74079d087b896bb3cab"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a4cce6a0756d4c74079d087b896bb3cab"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a4cce6a0756d4c74079d087b896bb3cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889a44529085df989f79daf6a213110f"><td class="memTemplParams" colspan="2"><a id="a889a44529085df989f79daf6a213110f"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a889a44529085df989f79daf6a213110f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a889a44529085df989f79daf6a213110f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd63b2fa541146db8a8c3f107f2335d"><td class="memTemplParams" colspan="2"><a id="a1cd63b2fa541146db8a8c3f107f2335d"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a1cd63b2fa541146db8a8c3f107f2335d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a1cd63b2fa541146db8a8c3f107f2335d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f00386098b190c53bd3d40610a0a53"><td class="memTemplParams" colspan="2"><a id="a75f00386098b190c53bd3d40610a0a53"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a75f00386098b190c53bd3d40610a0a53"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a75f00386098b190c53bd3d40610a0a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a5c1f676ca6f02570fe5336fc19518"><td class="memTemplParams" colspan="2"><a id="af0a5c1f676ca6f02570fe5336fc19518"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af0a5c1f676ca6f02570fe5336fc19518"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (std::nullptr_t, const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:af0a5c1f676ca6f02570fe5336fc19518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1feb9301ac84b2567e5b016a271327bf"><td class="memTemplParams" colspan="2"><a id="a1feb9301ac84b2567e5b016a271327bf"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1feb9301ac84b2567e5b016a271327bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a1feb9301ac84b2567e5b016a271327bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a775c4e3cfd1421aa75c5daf738272"><td class="memTemplParams" colspan="2"><a id="ad0a775c4e3cfd1421aa75c5daf738272"></a>
template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_convertible&lt;T*,U*&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ad0a775c4e3cfd1421aa75c5daf738272"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const T *lhs, const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ad0a775c4e3cfd1421aa75c5daf738272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2618ec0bb42d90a47e839b3e0ea6d5e5"><td class="memTemplParams" colspan="2"><a id="a2618ec0bb42d90a47e839b3e0ea6d5e5"></a>
template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_convertible&lt;U*,T*&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a2618ec0bb42d90a47e839b3e0ea6d5e5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, const U *rhs) noexcept</td></tr>
<tr class="separator:a2618ec0bb42d90a47e839b3e0ea6d5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16bd5c9ebe250ddc50b386ca7fc8f4d"><td class="memTemplParams" colspan="2"><a id="af16bd5c9ebe250ddc50b386ca7fc8f4d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af16bd5c9ebe250ddc50b386ca7fc8f4d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (std::nullptr_t, const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:af16bd5c9ebe250ddc50b386ca7fc8f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b665a4ecf001cca8e41d1e1707ab2be"><td class="memTemplParams" colspan="2"><a id="a4b665a4ecf001cca8e41d1e1707ab2be"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b665a4ecf001cca8e41d1e1707ab2be"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a4b665a4ecf001cca8e41d1e1707ab2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e2c4d147400d007e62867c0009c41c"><td class="memTemplParams" colspan="2"><a id="a97e2c4d147400d007e62867c0009c41c"></a>
template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_convertible&lt;T*,U*&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a97e2c4d147400d007e62867c0009c41c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const T *lhs, const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a97e2c4d147400d007e62867c0009c41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7074109c59ad3ff3a7b7d996866cb2"><td class="memTemplParams" colspan="2"><a id="a3c7074109c59ad3ff3a7b7d996866cb2"></a>
template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_convertible&lt;U*,T*&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a3c7074109c59ad3ff3a7b7d996866cb2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, const U *rhs) noexcept</td></tr>
<tr class="separator:a3c7074109c59ad3ff3a7b7d996866cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754def8047d98fd272c07d1e058772c8"><td class="memTemplParams" colspan="2"><a id="a754def8047d98fd272c07d1e058772c8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a754def8047d98fd272c07d1e058772c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (std::nullptr_t, const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a754def8047d98fd272c07d1e058772c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7126d2a21b0e757193b301f61ffbcbae"><td class="memTemplParams" colspan="2"><a id="a7126d2a21b0e757193b301f61ffbcbae"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7126d2a21b0e757193b301f61ffbcbae"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a7126d2a21b0e757193b301f61ffbcbae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5877f4276b3605be4e8bc8e18f16f1"><td class="memTemplParams" colspan="2"><a id="adf5877f4276b3605be4e8bc8e18f16f1"></a>
template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_convertible&lt;T*,U*&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:adf5877f4276b3605be4e8bc8e18f16f1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const T *lhs, const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:adf5877f4276b3605be4e8bc8e18f16f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f251a033a7d6f2b581df5f16907c93b"><td class="memTemplParams" colspan="2"><a id="a0f251a033a7d6f2b581df5f16907c93b"></a>
template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_convertible&lt;U*,T*&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a0f251a033a7d6f2b581df5f16907c93b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, const U *rhs) noexcept</td></tr>
<tr class="separator:a0f251a033a7d6f2b581df5f16907c93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb61260bf4f81896ef307c9d104cef78"><td class="memTemplParams" colspan="2"><a id="aeb61260bf4f81896ef307c9d104cef78"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb61260bf4f81896ef307c9d104cef78"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (std::nullptr_t, const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aeb61260bf4f81896ef307c9d104cef78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397dd84a1af21363696c4219f421774f"><td class="memTemplParams" colspan="2"><a id="a397dd84a1af21363696c4219f421774f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a397dd84a1af21363696c4219f421774f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a397dd84a1af21363696c4219f421774f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79636c2929b9668012832e34e96f40cc"><td class="memTemplParams" colspan="2"><a id="a79636c2929b9668012832e34e96f40cc"></a>
template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_convertible&lt;T*,U*&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a79636c2929b9668012832e34e96f40cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const T *lhs, const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a79636c2929b9668012832e34e96f40cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62db1a9bab9cfdc46b4690d389e1b5dc"><td class="memTemplParams" colspan="2"><a id="a62db1a9bab9cfdc46b4690d389e1b5dc"></a>
template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_convertible&lt;U*,T*&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a62db1a9bab9cfdc46b4690d389e1b5dc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, const U *rhs) noexcept</td></tr>
<tr class="separator:a62db1a9bab9cfdc46b4690d389e1b5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace323be1cd7b0cd2e1b19e618685f2a3"><td class="memTemplParams" colspan="2"><a id="ace323be1cd7b0cd2e1b19e618685f2a3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace323be1cd7b0cd2e1b19e618685f2a3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (std::nullptr_t, const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ace323be1cd7b0cd2e1b19e618685f2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3707357b97d1a0f1f3c48e297efb8f"><td class="memTemplParams" colspan="2"><a id="a0c3707357b97d1a0f1f3c48e297efb8f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0c3707357b97d1a0f1f3c48e297efb8f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a0c3707357b97d1a0f1f3c48e297efb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ce3d2264137d41905206ca9dec6b41"><td class="memTemplParams" colspan="2"><a id="af3ce3d2264137d41905206ca9dec6b41"></a>
template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_convertible&lt;T*,U*&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:af3ce3d2264137d41905206ca9dec6b41"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const T *lhs, const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:af3ce3d2264137d41905206ca9dec6b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bedb0842545eca4c08d4b3aeb026ae3"><td class="memTemplParams" colspan="2"><a id="a3bedb0842545eca4c08d4b3aeb026ae3"></a>
template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_convertible&lt;U*,T*&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a3bedb0842545eca4c08d4b3aeb026ae3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, const U *rhs) noexcept</td></tr>
<tr class="separator:a3bedb0842545eca4c08d4b3aeb026ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed504d6fc0bfed73a1e1af59516fb2ad"><td class="memTemplParams" colspan="2"><a id="aed504d6fc0bfed73a1e1af59516fb2ad"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aed504d6fc0bfed73a1e1af59516fb2ad"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (std::nullptr_t, const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aed504d6fc0bfed73a1e1af59516fb2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3cdbac2680da8745b01e44e045c7ca"><td class="memTemplParams" colspan="2"><a id="aac3cdbac2680da8745b01e44e045c7ca"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aac3cdbac2680da8745b01e44e045c7ca"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:aac3cdbac2680da8745b01e44e045c7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a096860f7e082874ff6dcfd757f215d"><td class="memTemplParams" colspan="2"><a id="a5a096860f7e082874ff6dcfd757f215d"></a>
template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_convertible&lt;T*,U*&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a5a096860f7e082874ff6dcfd757f215d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const T *lhs, const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a5a096860f7e082874ff6dcfd757f215d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de54c67bcac78066167965ff4efbcbd"><td class="memTemplParams" colspan="2"><a id="a3de54c67bcac78066167965ff4efbcbd"></a>
template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_convertible&lt;U*,T*&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a3de54c67bcac78066167965ff4efbcbd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;lhs, const U *rhs) noexcept</td></tr>
<tr class="separator:a3de54c67bcac78066167965ff4efbcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c1f4f2eb32c378cd04c5fb57cf7329"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a88c1f4f2eb32c378cd04c5fb57cf7329"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a88c1f4f2eb32c378cd04c5fb57cf7329">swap</a> (<a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a88c1f4f2eb32c378cd04c5fb57cf7329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the instances of two <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html" title="An offset pointer based on boost::offset_ptr. ">offset_ptr</a>.  <a href="#a88c1f4f2eb32c378cd04c5fb57cf7329">More...</a><br /></td></tr>
<tr class="separator:a88c1f4f2eb32c378cd04c5fb57cf7329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7241d90920683074f44ebf4023aa040"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af7241d90920683074f44ebf4023aa040"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#af7241d90920683074f44ebf4023aa040">hash_value</a> (const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;val) noexcept</td></tr>
<tr class="memdesc:af7241d90920683074f44ebf4023aa040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes a <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html" title="An offset pointer based on boost::offset_ptr. ">offset_ptr</a>.  <a href="#af7241d90920683074f44ebf4023aa040">More...</a><br /></td></tr>
<tr class="separator:af7241d90920683074f44ebf4023aa040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232731b8435855364032113294e5957d"><td class="memTemplParams" colspan="2"><a id="a232731b8435855364032113294e5957d"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a232731b8435855364032113294e5957d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a232731b8435855364032113294e5957d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269068591da86b3f54c184d466acc1e2"><td class="memTemplParams" colspan="2"><a id="a269068591da86b3f54c184d466acc1e2"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a269068591da86b3f54c184d466acc1e2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, const U *rhs) noexcept</td></tr>
<tr class="separator:a269068591da86b3f54c184d466acc1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04af501a3e8862c33186580d52605f9"><td class="memTemplParams" colspan="2"><a id="ac04af501a3e8862c33186580d52605f9"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ac04af501a3e8862c33186580d52605f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const T *lhs, const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ac04af501a3e8862c33186580d52605f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80eb591f79d588f669347348bd1cabc5"><td class="memTemplParams" colspan="2"><a id="a80eb591f79d588f669347348bd1cabc5"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a80eb591f79d588f669347348bd1cabc5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a80eb591f79d588f669347348bd1cabc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c31e1f77866586222c55966875e0e6"><td class="memTemplParams" colspan="2"><a id="ae9c31e1f77866586222c55966875e0e6"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ae9c31e1f77866586222c55966875e0e6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, const U *rhs) noexcept</td></tr>
<tr class="separator:ae9c31e1f77866586222c55966875e0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323cfb19d9a30a629b3abee75d7b6b68"><td class="memTemplParams" colspan="2"><a id="a323cfb19d9a30a629b3abee75d7b6b68"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a323cfb19d9a30a629b3abee75d7b6b68"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const T *lhs, const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a323cfb19d9a30a629b3abee75d7b6b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4892cfb99012b97d3ef15e20e68e06e"><td class="memTemplParams" colspan="2"><a id="ae4892cfb99012b97d3ef15e20e68e06e"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ae4892cfb99012b97d3ef15e20e68e06e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ae4892cfb99012b97d3ef15e20e68e06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e714b25f7336c64bc1778fc74c5a2d"><td class="memTemplParams" colspan="2"><a id="a38e714b25f7336c64bc1778fc74c5a2d"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a38e714b25f7336c64bc1778fc74c5a2d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, const U *rhs) noexcept</td></tr>
<tr class="separator:a38e714b25f7336c64bc1778fc74c5a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299846e1853360108fb45bae2000136f"><td class="memTemplParams" colspan="2"><a id="a299846e1853360108fb45bae2000136f"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a299846e1853360108fb45bae2000136f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const T *lhs, const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a299846e1853360108fb45bae2000136f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8f58b15f5507de68f79ed042198f0d"><td class="memTemplParams" colspan="2"><a id="a8d8f58b15f5507de68f79ed042198f0d"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a8d8f58b15f5507de68f79ed042198f0d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a8d8f58b15f5507de68f79ed042198f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409d3811637f86a6208200e5a9af1ee9"><td class="memTemplParams" colspan="2"><a id="a409d3811637f86a6208200e5a9af1ee9"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a409d3811637f86a6208200e5a9af1ee9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, const U *rhs) noexcept</td></tr>
<tr class="separator:a409d3811637f86a6208200e5a9af1ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed275a800b0190063a198346882d62db"><td class="memTemplParams" colspan="2"><a id="aed275a800b0190063a198346882d62db"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aed275a800b0190063a198346882d62db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const T *lhs, const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aed275a800b0190063a198346882d62db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3932bbc8f2d6760d28b83fddcc19ea"><td class="memTemplParams" colspan="2"><a id="a8a3932bbc8f2d6760d28b83fddcc19ea"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a8a3932bbc8f2d6760d28b83fddcc19ea"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a8a3932bbc8f2d6760d28b83fddcc19ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62db962a14e3e53c8d920b2d83d874e8"><td class="memTemplParams" colspan="2"><a id="a62db962a14e3e53c8d920b2d83d874e8"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a62db962a14e3e53c8d920b2d83d874e8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, const U *rhs) noexcept</td></tr>
<tr class="separator:a62db962a14e3e53c8d920b2d83d874e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59a6dc1b568906813441a51853c5aa4"><td class="memTemplParams" colspan="2"><a id="ab59a6dc1b568906813441a51853c5aa4"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ab59a6dc1b568906813441a51853c5aa4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const T *lhs, const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ab59a6dc1b568906813441a51853c5aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79040559289bfa96f2f9dcd54fe13f51"><td class="memTemplParams" colspan="2"><a id="a79040559289bfa96f2f9dcd54fe13f51"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a79040559289bfa96f2f9dcd54fe13f51"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a79040559289bfa96f2f9dcd54fe13f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefe2db6de7ab8570a926607c0eecb36"><td class="memTemplParams" colspan="2"><a id="acefe2db6de7ab8570a926607c0eecb36"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:acefe2db6de7ab8570a926607c0eecb36"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;lhs, const U *rhs) noexcept</td></tr>
<tr class="separator:acefe2db6de7ab8570a926607c0eecb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed96444f8c3e908add7c4d00f4eb943"><td class="memTemplParams" colspan="2"><a id="a1ed96444f8c3e908add7c4d00f4eb943"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a1ed96444f8c3e908add7c4d00f4eb943"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const T *lhs, const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a1ed96444f8c3e908add7c4d00f4eb943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab14bdab0f8db5a38279e406d88fde38"><td class="memTemplParams" colspan="2"><a id="aab14bdab0f8db5a38279e406d88fde38"></a>
template&lt;typename T , typename Deleter &gt; </td></tr>
<tr class="memitem:aab14bdab0f8db5a38279e406d88fde38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; T, Deleter &gt; &amp;lhs, <a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; T, Deleter &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aab14bdab0f8db5a38279e406d88fde38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812a0d73efb12eaaae9ce8ac8626ca1b"><td class="memTemplParams" colspan="2"><a id="a812a0d73efb12eaaae9ce8ac8626ca1b"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a812a0d73efb12eaaae9ce8ac8626ca1b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a812a0d73efb12eaaae9ce8ac8626ca1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65df47bd913ef2a21ca75ff89e40db8"><td class="memTemplParams" colspan="2"><a id="ad65df47bd913ef2a21ca75ff89e40db8"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ad65df47bd913ef2a21ca75ff89e40db8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ad65df47bd913ef2a21ca75ff89e40db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e5f52f44c5b62e148be98b34deb60c"><td class="memTemplParams" colspan="2"><a id="a10e5f52f44c5b62e148be98b34deb60c"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a10e5f52f44c5b62e148be98b34deb60c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a10e5f52f44c5b62e148be98b34deb60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c72027ae12a10c43dc34aa1ea334503"><td class="memTemplParams" colspan="2"><a id="a0c72027ae12a10c43dc34aa1ea334503"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a0c72027ae12a10c43dc34aa1ea334503"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a0c72027ae12a10c43dc34aa1ea334503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280d1959ad5f44b81007c6a1b03ba0df"><td class="memTemplParams" colspan="2"><a id="a280d1959ad5f44b81007c6a1b03ba0df"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a280d1959ad5f44b81007c6a1b03ba0df"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a280d1959ad5f44b81007c6a1b03ba0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b93f5e9621fd785c8472cd8d6ffdc6"><td class="memTemplParams" colspan="2"><a id="ad8b93f5e9621fd785c8472cd8d6ffdc6"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ad8b93f5e9621fd785c8472cd8d6ffdc6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ad8b93f5e9621fd785c8472cd8d6ffdc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4a414cf147d6da52794717a432fa1f"><td class="memTemplParams" colspan="2"><a id="a4e4a414cf147d6da52794717a432fa1f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4e4a414cf147d6da52794717a432fa1f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (std::nullptr_t, const <a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a4e4a414cf147d6da52794717a432fa1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66b572efb1e4e9d6f1a7dc11fff5039"><td class="memTemplParams" colspan="2"><a id="ac66b572efb1e4e9d6f1a7dc11fff5039"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac66b572efb1e4e9d6f1a7dc11fff5039"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:ac66b572efb1e4e9d6f1a7dc11fff5039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec20491289e6ed484566eff07b53781"><td class="memTemplParams" colspan="2"><a id="acec20491289e6ed484566eff07b53781"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acec20491289e6ed484566eff07b53781"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (std::nullptr_t, const <a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:acec20491289e6ed484566eff07b53781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22495b8c712fbad7748f7574a8218d70"><td class="memTemplParams" colspan="2"><a id="a22495b8c712fbad7748f7574a8218d70"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a22495b8c712fbad7748f7574a8218d70"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a22495b8c712fbad7748f7574a8218d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41a6213b0b86603c791c118fde7156e"><td class="memTemplParams" colspan="2"><a id="ae41a6213b0b86603c791c118fde7156e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae41a6213b0b86603c791c118fde7156e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (std::nullptr_t, const <a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ae41a6213b0b86603c791c118fde7156e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c33055c7ba9ac864b108daec815af2"><td class="memTemplParams" colspan="2"><a id="a61c33055c7ba9ac864b108daec815af2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a61c33055c7ba9ac864b108daec815af2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a61c33055c7ba9ac864b108daec815af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf12faefa6fdb58e6feb44e01396f29b"><td class="memTemplParams" colspan="2"><a id="abf12faefa6fdb58e6feb44e01396f29b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abf12faefa6fdb58e6feb44e01396f29b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (std::nullptr_t, const <a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:abf12faefa6fdb58e6feb44e01396f29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85352b9175cd79225ce0ce71b6bd457"><td class="memTemplParams" colspan="2"><a id="ac85352b9175cd79225ce0ce71b6bd457"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac85352b9175cd79225ce0ce71b6bd457"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:ac85352b9175cd79225ce0ce71b6bd457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f57d7218e553acb5813a444ed12142"><td class="memTemplParams" colspan="2"><a id="a97f57d7218e553acb5813a444ed12142"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a97f57d7218e553acb5813a444ed12142"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (std::nullptr_t, const <a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a97f57d7218e553acb5813a444ed12142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6536f5e9c22ac32aedcba92c5ea13bda"><td class="memTemplParams" colspan="2"><a id="a6536f5e9c22ac32aedcba92c5ea13bda"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6536f5e9c22ac32aedcba92c5ea13bda"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a6536f5e9c22ac32aedcba92c5ea13bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b84053b796294457167d3c29a531395"><td class="memTemplParams" colspan="2"><a id="a6b84053b796294457167d3c29a531395"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6b84053b796294457167d3c29a531395"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (std::nullptr_t, const <a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a6b84053b796294457167d3c29a531395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a4adee8630d3a43921ad2d8e6e72b5"><td class="memTemplParams" colspan="2"><a id="ab5a4adee8630d3a43921ad2d8e6e72b5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab5a4adee8630d3a43921ad2d8e6e72b5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d0/d96/classbit_1_1stl_1_1scoped__ptr.html">scoped_ptr</a>&lt; T &gt; &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="separator:ab5a4adee8630d3a43921ad2d8e6e72b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c0ed1fbd40262a8ea362a934dec70f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a87c0ed1fbd40262a8ea362a934dec70f"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::common_type_t&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a87c0ed1fbd40262a8ea362a934dec70f">gcd</a> (const T &amp;a, const U &amp;b) noexcept</td></tr>
<tr class="memdesc:a87c0ed1fbd40262a8ea362a934dec70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common divisor of the integers <code>m</code> and <code>n</code>.  <a href="#a87c0ed1fbd40262a8ea362a934dec70f">More...</a><br /></td></tr>
<tr class="separator:a87c0ed1fbd40262a8ea362a934dec70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064c1a74dad23ef09ef9eaf423532596"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a064c1a74dad23ef09ef9eaf423532596"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::common_type_t&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a064c1a74dad23ef09ef9eaf423532596">lcm</a> (const T &amp;a, const U &amp;b) noexcept</td></tr>
<tr class="memdesc:a064c1a74dad23ef09ef9eaf423532596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the least common multiple of the integers <code>m</code> and <code>n</code>.  <a href="#a064c1a74dad23ef09ef9eaf423532596">More...</a><br /></td></tr>
<tr class="separator:a064c1a74dad23ef09ef9eaf423532596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5f09d0db15bc976086708151cad4e7"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Sentinel &gt; </td></tr>
<tr class="memitem:add5f09d0db15bc976086708151cad4e7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d68/classbit_1_1stl_1_1range.html">move_range</a>&lt; Iterator, Sentinel &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#add5f09d0db15bc976086708151cad4e7">make_move_range</a> (Iterator iterator, Sentinel sentinel)</td></tr>
<tr class="memdesc:add5f09d0db15bc976086708151cad4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a movable range from a given <code>iterator</code> <code>sentinal</code> pair.  <a href="#add5f09d0db15bc976086708151cad4e7">More...</a><br /></td></tr>
<tr class="separator:add5f09d0db15bc976086708151cad4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd4d204c6360d55e80c63411164decb"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:a6fd4d204c6360d55e80c63411164decb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a6fd4d204c6360d55e80c63411164decb">make_move_range</a> (Range &amp;&amp;r) -&gt; decltype(make_move_range(r.begin(), r.end()))</td></tr>
<tr class="memdesc:a6fd4d204c6360d55e80c63411164decb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a reverse range from a given <code>iterator</code> <code>sentinal</code> pair.  <a href="#a6fd4d204c6360d55e80c63411164decb">More...</a><br /></td></tr>
<tr class="separator:a6fd4d204c6360d55e80c63411164decb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f242f7df14fb4961730a553e96084b2"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S &gt; </td></tr>
<tr class="memitem:a0f242f7df14fb4961730a553e96084b2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d68/classbit_1_1stl_1_1range.html">range</a>&lt; I, S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a0f242f7df14fb4961730a553e96084b2">make_range</a> (I iterator, S sentinel)</td></tr>
<tr class="memdesc:a0f242f7df14fb4961730a553e96084b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a range from a given <code>iterator</code> <code>sentinel</code> pair.  <a href="#a0f242f7df14fb4961730a553e96084b2">More...</a><br /></td></tr>
<tr class="separator:a0f242f7df14fb4961730a553e96084b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e28a7d1651dd558116d848caaab0ef"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:a10e28a7d1651dd558116d848caaab0ef"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d68/classbit_1_1stl_1_1range.html">detail::reverse_range_t</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a10e28a7d1651dd558116d848caaab0ef">make_reverse_range</a> (Range &amp;&amp;<a class="el" href="../../d9/d68/classbit_1_1stl_1_1range.html">range</a>)</td></tr>
<tr class="memdesc:a10e28a7d1651dd558116d848caaab0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a reverse range from a given range.  <a href="#a10e28a7d1651dd558116d848caaab0ef">More...</a><br /></td></tr>
<tr class="separator:a10e28a7d1651dd558116d848caaab0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb836366eb9312a050e71090d0d0ab18"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename Iterator , typename Sentinel &gt; </td></tr>
<tr class="memitem:aeb836366eb9312a050e71090d0d0ab18"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d9/d68/classbit_1_1stl_1_1range.html">tuple_element_range</a>&lt; N, Iterator, Sentinel &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aeb836366eb9312a050e71090d0d0ab18">make_tuple_element_range</a> (Iterator iterator, Sentinel sentinel)</td></tr>
<tr class="memdesc:aeb836366eb9312a050e71090d0d0ab18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a range from a given <code>iterator</code> <code>sentinel</code> pair iterating values of a given tuple.  <a href="#aeb836366eb9312a050e71090d0d0ab18">More...</a><br /></td></tr>
<tr class="separator:aeb836366eb9312a050e71090d0d0ab18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9755799c88fc44a9721b20f5f9ad2d26"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename Range &gt; </td></tr>
<tr class="memitem:a9755799c88fc44a9721b20f5f9ad2d26"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a9755799c88fc44a9721b20f5f9ad2d26">make_tuple_element_range</a> (Range &amp;&amp;r) -&gt; decltype(make_tuple_element_range&lt; N &gt;(r.begin(), r.end()))</td></tr>
<tr class="memdesc:a9755799c88fc44a9721b20f5f9ad2d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a tuple element range from a range.  <a href="#a9755799c88fc44a9721b20f5f9ad2d26">More...</a><br /></td></tr>
<tr class="separator:a9755799c88fc44a9721b20f5f9ad2d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa998a5df14df29d0930831c718ef1a25"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Sentinel &gt; </td></tr>
<tr class="memitem:aa998a5df14df29d0930831c718ef1a25"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aa998a5df14df29d0930831c718ef1a25">make_key_range</a> (Iterator iterator, Sentinel sentinel) -&gt; <a class="el" href="../../d9/d68/classbit_1_1stl_1_1range.html">range</a>&lt; <a class="el" href="../../de/d9c/classbit_1_1stl_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; 0, Iterator &gt;, <a class="el" href="../../de/d9c/classbit_1_1stl_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; 0, Sentinel &gt;&gt;</td></tr>
<tr class="memdesc:aa998a5df14df29d0930831c718ef1a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a range from a given <code>iterator</code> <code>sentinel</code> pair iterating the first value of a given tuple.  <a href="#aa998a5df14df29d0930831c718ef1a25">More...</a><br /></td></tr>
<tr class="separator:aa998a5df14df29d0930831c718ef1a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b291d11c52d94444f2625dcefb69da"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:a44b291d11c52d94444f2625dcefb69da"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a44b291d11c52d94444f2625dcefb69da">make_key_range</a> (Range &amp;&amp;r) -&gt; decltype(make_key_range(r.begin(), r.end()))</td></tr>
<tr class="memdesc:a44b291d11c52d94444f2625dcefb69da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a key range from another range.  <a href="#a44b291d11c52d94444f2625dcefb69da">More...</a><br /></td></tr>
<tr class="separator:a44b291d11c52d94444f2625dcefb69da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6cca0b51b9a9be22b42f7dcdef6aaaf"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Sentinel &gt; </td></tr>
<tr class="memitem:ad6cca0b51b9a9be22b42f7dcdef6aaaf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ad6cca0b51b9a9be22b42f7dcdef6aaaf">make_value_range</a> (Iterator iterator, Sentinel sentinel) -&gt; <a class="el" href="../../d9/d68/classbit_1_1stl_1_1range.html">range</a>&lt; <a class="el" href="../../de/d9c/classbit_1_1stl_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; 1, Iterator &gt;, <a class="el" href="../../de/d9c/classbit_1_1stl_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; 1, Sentinel &gt;&gt;</td></tr>
<tr class="memdesc:ad6cca0b51b9a9be22b42f7dcdef6aaaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a range from a given <code>iterator</code> <code>sentinel</code> pair iterating the second value of a given tuple.  <a href="#ad6cca0b51b9a9be22b42f7dcdef6aaaf">More...</a><br /></td></tr>
<tr class="separator:ad6cca0b51b9a9be22b42f7dcdef6aaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b8bd09adc8ff6908217ee5b913628b"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:a90b8bd09adc8ff6908217ee5b913628b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a90b8bd09adc8ff6908217ee5b913628b">make_value_range</a> (Range &amp;&amp;r) -&gt; decltype(make_value_range(r.begin(), r.end()))</td></tr>
<tr class="memdesc:a90b8bd09adc8ff6908217ee5b913628b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a value range from another range.  <a href="#a90b8bd09adc8ff6908217ee5b913628b">More...</a><br /></td></tr>
<tr class="separator:a90b8bd09adc8ff6908217ee5b913628b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18841cb6f87b8d466adb47fee8d88c02"><td class="memTemplParams" colspan="2">template&lt;typename Range0 , typename... RangeN&gt; </td></tr>
<tr class="memitem:a18841cb6f87b8d466adb47fee8d88c02"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a18841cb6f87b8d466adb47fee8d88c02">make_zip_range</a> (Range0 &amp;&amp;r0, RangeN &amp;&amp;...rn) -&gt; <a class="el" href="../../d9/d68/classbit_1_1stl_1_1range.html">range</a>&lt; <a class="el" href="../../d3/dc5/classbit_1_1stl_1_1zip__iterator.html">zip_iterator</a>&lt; decltype(r0.begin()), decltype(rn.begin())... &gt;, <a class="el" href="../../d3/dc5/classbit_1_1stl_1_1zip__iterator.html">zip_iterator</a>&lt; decltype(r0.end()), decltype(rn.end())... &gt;&gt;</td></tr>
<tr class="memdesc:a18841cb6f87b8d466adb47fee8d88c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a zip range from a selection of zip iterators.  <a href="#a18841cb6f87b8d466adb47fee8d88c02">More...</a><br /></td></tr>
<tr class="separator:a18841cb6f87b8d466adb47fee8d88c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e445241b494aa7aa950f4ca4ff2d5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a36e445241b494aa7aa950f4ca4ff2d5c">default_assert</a> (const char *message, <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html">source_location</a> source)</td></tr>
<tr class="memdesc:a36e445241b494aa7aa950f4ca4ff2d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default assert handler. Prints a message, then triggers a breakpoint.  <a href="#a36e445241b494aa7aa950f4ca4ff2d5c">More...</a><br /></td></tr>
<tr class="separator:a36e445241b494aa7aa950f4ca4ff2d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61f3c4de60623e376e8625aaeec2e8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#af61f3c4de60623e376e8625aaeec2e8d">throwing_assert</a> (const char *message, <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html">source_location</a> source)</td></tr>
<tr class="memdesc:af61f3c4de60623e376e8625aaeec2e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception-throwing assert handler. Throws an <a class="el" href="../../d5/de8/classbit_1_1stl_1_1assertion__failure.html" title="An exception thrown from assertion failures when BIT_COMPILER_EXCEPTIONS_ENABLED is defined...">assertion_failure</a> exception.  <a href="#af61f3c4de60623e376e8625aaeec2e8d">More...</a><br /></td></tr>
<tr class="separator:af61f3c4de60623e376e8625aaeec2e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422888e8bf759070c079f4ae2b699a3d"><td class="memItemLeft" align="right" valign="top">assert_handler_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a422888e8bf759070c079f4ae2b699a3d">set_assert_handler</a> (assert_handler_t f)</td></tr>
<tr class="memdesc:a422888e8bf759070c079f4ae2b699a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the assertion handler, returning the previous assertion handler.  <a href="#a422888e8bf759070c079f4ae2b699a3d">More...</a><br /></td></tr>
<tr class="separator:a422888e8bf759070c079f4ae2b699a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4bce747381dc857bde640ed77ba843"><td class="memItemLeft" align="right" valign="top">assert_handler_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a1d4bce747381dc857bde640ed77ba843">get_assert_handler</a> ()</td></tr>
<tr class="memdesc:a1d4bce747381dc857bde640ed77ba843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the currently active assertion handler.  <a href="#a1d4bce747381dc857bde640ed77ba843">More...</a><br /></td></tr>
<tr class="separator:a1d4bce747381dc857bde640ed77ba843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76542c6ccf67a02d7019356cb8add12"><td class="memTemplParams" colspan="2"><a id="ad76542c6ccf67a02d7019356cb8add12"></a>
template&lt;typename IntT &gt; </td></tr>
<tr class="memitem:ad76542c6ccf67a02d7019356cb8add12"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;=</b> (<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a> &amp;lhs, IntT shift) noexcept</td></tr>
<tr class="separator:ad76542c6ccf67a02d7019356cb8add12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e85585ba8f0bdba55a7b57445120757"><td class="memTemplParams" colspan="2"><a id="a0e85585ba8f0bdba55a7b57445120757"></a>
template&lt;typename IntT &gt; </td></tr>
<tr class="memitem:a0e85585ba8f0bdba55a7b57445120757"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a> lhs, IntT shift) noexcept</td></tr>
<tr class="separator:a0e85585ba8f0bdba55a7b57445120757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7775b7b2d8535e94376e2efa15a78973"><td class="memTemplParams" colspan="2"><a id="a7775b7b2d8535e94376e2efa15a78973"></a>
template&lt;typename IntT &gt; </td></tr>
<tr class="memitem:a7775b7b2d8535e94376e2efa15a78973"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;=</b> (<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a> &amp;lhs, IntT shift) noexcept</td></tr>
<tr class="separator:a7775b7b2d8535e94376e2efa15a78973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036bdfbe937597f1676ca883bdef83f8"><td class="memTemplParams" colspan="2"><a id="a036bdfbe937597f1676ca883bdef83f8"></a>
template&lt;typename IntT &gt; </td></tr>
<tr class="memitem:a036bdfbe937597f1676ca883bdef83f8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a> lhs, IntT shift) noexcept</td></tr>
<tr class="separator:a036bdfbe937597f1676ca883bdef83f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ec76c4e9ff161c6cc1fa657c8cfe84"><td class="memItemLeft" align="right" valign="top"><a id="a95ec76c4e9ff161c6cc1fa657c8cfe84"></a>
<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator|=</b> (<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a> &amp;lhs, <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a> rhs) noexcept</td></tr>
<tr class="separator:a95ec76c4e9ff161c6cc1fa657c8cfe84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc48387ce2c9f2124573dba9fa1f3cd1"><td class="memItemLeft" align="right" valign="top"><a id="abc48387ce2c9f2124573dba9fa1f3cd1"></a>
constexpr <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator|</b> (<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a> lhs, <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a> rhs) noexcept</td></tr>
<tr class="separator:abc48387ce2c9f2124573dba9fa1f3cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2028bb02f9d7f70029325a010047c8"><td class="memItemLeft" align="right" valign="top"><a id="aea2028bb02f9d7f70029325a010047c8"></a>
<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator &amp;=</b> (<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a> &amp;lhs, <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a> rhs) noexcept</td></tr>
<tr class="separator:aea2028bb02f9d7f70029325a010047c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfd9c4018823d47687baa77ce9d98a0"><td class="memItemLeft" align="right" valign="top"><a id="afbfd9c4018823d47687baa77ce9d98a0"></a>
constexpr <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator &amp;</b> (<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a> lhs, <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a> rhs) noexcept</td></tr>
<tr class="separator:afbfd9c4018823d47687baa77ce9d98a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8d43e906757cad86b3806ea79e72af"><td class="memItemLeft" align="right" valign="top"><a id="afb8d43e906757cad86b3806ea79e72af"></a>
<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator^=</b> (<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a> &amp;lhs, <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a> rhs) noexcept</td></tr>
<tr class="separator:afb8d43e906757cad86b3806ea79e72af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd8eb7bffa63f3f8204ba291f0e5479"><td class="memItemLeft" align="right" valign="top"><a id="a9cd8eb7bffa63f3f8204ba291f0e5479"></a>
constexpr <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator^</b> (<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a> lhs, <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a> rhs) noexcept</td></tr>
<tr class="separator:a9cd8eb7bffa63f3f8204ba291f0e5479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa9acc17e0ae7276bbf3f0794e8411c"><td class="memItemLeft" align="right" valign="top"><a id="a2aa9acc17e0ae7276bbf3f0794e8411c"></a>
constexpr <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator~</b> (<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">byte</a> lhs) noexcept</td></tr>
<tr class="separator:a2aa9acc17e0ae7276bbf3f0794e8411c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889cce0c0e6dd8da86d6ed018e66d9de"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a889cce0c0e6dd8da86d6ed018e66d9de"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a889cce0c0e6dd8da86d6ed018e66d9de">hash_value</a> (const <a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; T, U &gt; &amp;pair)</td></tr>
<tr class="memdesc:a889cce0c0e6dd8da86d6ed018e66d9de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes a std::pair.  <a href="#a889cce0c0e6dd8da86d6ed018e66d9de">More...</a><br /></td></tr>
<tr class="separator:a889cce0c0e6dd8da86d6ed018e66d9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7870c066ad0f83c5a615058855cf99ab"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a7870c066ad0f83c5a615058855cf99ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a7870c066ad0f83c5a615058855cf99ab">swap</a> (<a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;lhs, <a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7870c066ad0f83c5a615058855cf99ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of two compressed_pairs.  <a href="#a7870c066ad0f83c5a615058855cf99ab">More...</a><br /></td></tr>
<tr class="separator:a7870c066ad0f83c5a615058855cf99ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c5bd1f2d6824c7fafd21e9621add0f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ab9c5bd1f2d6824c7fafd21e9621add0f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; std::decay_t&lt; T1 &gt;, std::decay_t&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ab9c5bd1f2d6824c7fafd21e9621add0f">make_compressed_pair</a> (T1 &amp;&amp;x, T2 &amp;&amp;y)</td></tr>
<tr class="memdesc:ab9c5bd1f2d6824c7fafd21e9621add0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make utility to create a type-deduced compressed pair.  <a href="#ab9c5bd1f2d6824c7fafd21e9621add0f">More...</a><br /></td></tr>
<tr class="separator:ab9c5bd1f2d6824c7fafd21e9621add0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f8dd60fc19ec588b7e24e64adbcf97"><td class="memTemplParams" colspan="2"><a id="a68f8dd60fc19ec588b7e24e64adbcf97"></a>
template&lt;std::size_t Idx, typename U1 , typename U2 &gt; </td></tr>
<tr class="memitem:a68f8dd60fc19ec588b7e24e64adbcf97"><td class="memTemplItemLeft" align="right" valign="top">constexpr tuple_element_t&lt; Idx, <a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; U1, U2 &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (<a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; U1, U2 &gt; &amp;p) noexcept</td></tr>
<tr class="separator:a68f8dd60fc19ec588b7e24e64adbcf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7eb2cf27e0e8a1591a9dd7323e2f3e6"><td class="memTemplParams" colspan="2"><a id="aa7eb2cf27e0e8a1591a9dd7323e2f3e6"></a>
template&lt;std::size_t Idx, typename U1 , typename U2 &gt; </td></tr>
<tr class="memitem:aa7eb2cf27e0e8a1591a9dd7323e2f3e6"><td class="memTemplItemLeft" align="right" valign="top">constexpr const tuple_element_t&lt; Idx, <a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; U1, U2 &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; U1, U2 &gt; &amp;p) noexcept</td></tr>
<tr class="separator:aa7eb2cf27e0e8a1591a9dd7323e2f3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e3e19ac5ec10b2a0af31d691aae548"><td class="memTemplParams" colspan="2"><a id="af7e3e19ac5ec10b2a0af31d691aae548"></a>
template&lt;std::size_t Idx, typename U1 , typename U2 &gt; </td></tr>
<tr class="memitem:af7e3e19ac5ec10b2a0af31d691aae548"><td class="memTemplItemLeft" align="right" valign="top">constexpr tuple_element_t&lt; Idx, <a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; U1, U2 &gt; &gt; &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (<a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; U1, U2 &gt; &amp;&amp;p) noexcept</td></tr>
<tr class="separator:af7e3e19ac5ec10b2a0af31d691aae548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad511e2bc71cfb1aafb6c8c49df9647e2"><td class="memTemplParams" colspan="2"><a id="ad511e2bc71cfb1aafb6c8c49df9647e2"></a>
template&lt;std::size_t Idx, typename U1 , typename U2 &gt; </td></tr>
<tr class="memitem:ad511e2bc71cfb1aafb6c8c49df9647e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr const tuple_element_t&lt; Idx, <a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; U1, U2 &gt; &gt; &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; U1, U2 &gt; &amp;&amp;p) noexcept</td></tr>
<tr class="separator:ad511e2bc71cfb1aafb6c8c49df9647e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e9464a35f2384d1505746a7a951e5a"><td class="memTemplParams" colspan="2"><a id="a07e9464a35f2384d1505746a7a951e5a"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a07e9464a35f2384d1505746a7a951e5a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;lhs, const <a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a07e9464a35f2384d1505746a7a951e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213d19d3999f17aee79e54dc44e7a1b4"><td class="memTemplParams" colspan="2"><a id="a213d19d3999f17aee79e54dc44e7a1b4"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a213d19d3999f17aee79e54dc44e7a1b4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;lhs, const <a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a213d19d3999f17aee79e54dc44e7a1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b3f454f63a47e0620e57a82b7c079f"><td class="memTemplParams" colspan="2"><a id="ad7b3f454f63a47e0620e57a82b7c079f"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ad7b3f454f63a47e0620e57a82b7c079f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;lhs, const <a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr class="separator:ad7b3f454f63a47e0620e57a82b7c079f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75def2ad7f1320026fa76634fd63ad8e"><td class="memTemplParams" colspan="2"><a id="a75def2ad7f1320026fa76634fd63ad8e"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a75def2ad7f1320026fa76634fd63ad8e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;lhs, const <a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a75def2ad7f1320026fa76634fd63ad8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2528d2dbc0feaa34218e08043a49b3ad"><td class="memTemplParams" colspan="2"><a id="a2528d2dbc0feaa34218e08043a49b3ad"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a2528d2dbc0feaa34218e08043a49b3ad"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;lhs, const <a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a2528d2dbc0feaa34218e08043a49b3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb0770ad5950f2c59e337341fcda6df"><td class="memTemplParams" colspan="2"><a id="a7bb0770ad5950f2c59e337341fcda6df"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a7bb0770ad5950f2c59e337341fcda6df"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;lhs, const <a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr class="separator:a7bb0770ad5950f2c59e337341fcda6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb4f203fe86f1a48383f075c95d79dd"><td class="memTemplParams" colspan="2"><a id="a4fb4f203fe86f1a48383f075c95d79dd"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a4fb4f203fe86f1a48383f075c95d79dd"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="../../d6/df1/classbit_1_1stl_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;lhs, <a class="el" href="../../d6/df1/classbit_1_1stl_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;rhs)</td></tr>
<tr class="separator:a4fb4f203fe86f1a48383f075c95d79dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfbf8eb9f2f2156152b1d83362fcf65"><td class="memTemplParams" colspan="2"><a id="a4bfbf8eb9f2f2156152b1d83362fcf65"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a4bfbf8eb9f2f2156152b1d83362fcf65"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d6/df1/classbit_1_1stl_1_1compressed__tuple.html">compressed_tuple</a>&lt; std::decay_t&lt; Args &gt;... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_compressed_tuple</b> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:a4bfbf8eb9f2f2156152b1d83362fcf65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f727477c6673ff5b1e794f80139a177"><td class="memTemplParams" colspan="2"><a id="a8f727477c6673ff5b1e794f80139a177"></a>
template&lt;std::size_t I, typename... UTypes&gt; </td></tr>
<tr class="memitem:a8f727477c6673ff5b1e794f80139a177"><td class="memTemplItemLeft" align="right" valign="top">constexpr tuple_element_t&lt; I, <a class="el" href="../../d6/df1/classbit_1_1stl_1_1compressed__tuple.html">compressed_tuple</a>&lt; UTypes... &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (<a class="el" href="../../d6/df1/classbit_1_1stl_1_1compressed__tuple.html">compressed_tuple</a>&lt; UTypes... &gt; &amp;tuple) noexcept</td></tr>
<tr class="separator:a8f727477c6673ff5b1e794f80139a177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7af5ae5e45cba30dd0fb4168c2555b6"><td class="memTemplParams" colspan="2"><a id="ad7af5ae5e45cba30dd0fb4168c2555b6"></a>
template&lt;std::size_t I, typename... UTypes&gt; </td></tr>
<tr class="memitem:ad7af5ae5e45cba30dd0fb4168c2555b6"><td class="memTemplItemLeft" align="right" valign="top">constexpr tuple_element_t&lt; I, <a class="el" href="../../d6/df1/classbit_1_1stl_1_1compressed__tuple.html">compressed_tuple</a>&lt; UTypes... &gt; &gt; &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (<a class="el" href="../../d6/df1/classbit_1_1stl_1_1compressed__tuple.html">compressed_tuple</a>&lt; UTypes... &gt; &amp;&amp;tuple) noexcept</td></tr>
<tr class="separator:ad7af5ae5e45cba30dd0fb4168c2555b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df53f673437ccd21433c454443f7fa0"><td class="memTemplParams" colspan="2"><a id="a9df53f673437ccd21433c454443f7fa0"></a>
template&lt;std::size_t I, typename... UTypes&gt; </td></tr>
<tr class="memitem:a9df53f673437ccd21433c454443f7fa0"><td class="memTemplItemLeft" align="right" valign="top">constexpr const tuple_element_t&lt; I, <a class="el" href="../../d6/df1/classbit_1_1stl_1_1compressed__tuple.html">compressed_tuple</a>&lt; UTypes... &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="../../d6/df1/classbit_1_1stl_1_1compressed__tuple.html">compressed_tuple</a>&lt; UTypes... &gt; &amp;tuple) noexcept</td></tr>
<tr class="separator:a9df53f673437ccd21433c454443f7fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7be633af1edc06389b6a1adb0468643"><td class="memTemplParams" colspan="2"><a id="ae7be633af1edc06389b6a1adb0468643"></a>
template&lt;std::size_t I, typename... UTypes&gt; </td></tr>
<tr class="memitem:ae7be633af1edc06389b6a1adb0468643"><td class="memTemplItemLeft" align="right" valign="top">constexpr const tuple_element_t&lt; I, <a class="el" href="../../d6/df1/classbit_1_1stl_1_1compressed__tuple.html">compressed_tuple</a>&lt; UTypes... &gt; &gt; &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="../../d6/df1/classbit_1_1stl_1_1compressed__tuple.html">compressed_tuple</a>&lt; UTypes... &gt; &amp;&amp;tuple) noexcept</td></tr>
<tr class="separator:ae7be633af1edc06389b6a1adb0468643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af317f78885f3400ab97a6dbbd3f6f90d"><td class="memTemplParams" colspan="2"><a id="af317f78885f3400ab97a6dbbd3f6f90d"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:af317f78885f3400ab97a6dbbd3f6f90d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d6/df1/classbit_1_1stl_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;lhs, const <a class="el" href="../../d6/df1/classbit_1_1stl_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:af317f78885f3400ab97a6dbbd3f6f90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ada29dd1da7984c9ed6f38c8f35567"><td class="memTemplParams" colspan="2"><a id="a79ada29dd1da7984c9ed6f38c8f35567"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a79ada29dd1da7984c9ed6f38c8f35567"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d6/df1/classbit_1_1stl_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;lhs, const <a class="el" href="../../d6/df1/classbit_1_1stl_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a79ada29dd1da7984c9ed6f38c8f35567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f726f6b56dc4c7432362ce65593984"><td class="memTemplParams" colspan="2"><a id="a07f726f6b56dc4c7432362ce65593984"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a07f726f6b56dc4c7432362ce65593984"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d6/df1/classbit_1_1stl_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;lhs, const <a class="el" href="../../d6/df1/classbit_1_1stl_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a07f726f6b56dc4c7432362ce65593984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9efeb2a8ddf5b88290da8648aaf24e"><td class="memTemplParams" colspan="2"><a id="a8a9efeb2a8ddf5b88290da8648aaf24e"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a8a9efeb2a8ddf5b88290da8648aaf24e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d6/df1/classbit_1_1stl_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;lhs, const <a class="el" href="../../d6/df1/classbit_1_1stl_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a8a9efeb2a8ddf5b88290da8648aaf24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15fe3c98676e83a2543d800502f2472"><td class="memTemplParams" colspan="2"><a id="ae15fe3c98676e83a2543d800502f2472"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ae15fe3c98676e83a2543d800502f2472"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d6/df1/classbit_1_1stl_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;lhs, const <a class="el" href="../../d6/df1/classbit_1_1stl_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ae15fe3c98676e83a2543d800502f2472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17668889f20273ce175937f4e54d9bdd"><td class="memTemplParams" colspan="2"><a id="a17668889f20273ce175937f4e54d9bdd"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a17668889f20273ce175937f4e54d9bdd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d6/df1/classbit_1_1stl_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;lhs, const <a class="el" href="../../d6/df1/classbit_1_1stl_1_1compressed__tuple.html">compressed_tuple</a>&lt; Types... &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a17668889f20273ce175937f4e54d9bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85fa7266c81294abadd9b2a636274387"><td class="memTemplParams" colspan="2"><a id="a85fa7266c81294abadd9b2a636274387"></a>
template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a85fa7266c81294abadd9b2a636274387"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a>&lt; Fn &gt; &amp;lhs, const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a>&lt; Fn &gt; &amp;rhs)</td></tr>
<tr class="separator:a85fa7266c81294abadd9b2a636274387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c91eeacbdcb55de0dda9517d41434a7"><td class="memTemplParams" colspan="2"><a id="a7c91eeacbdcb55de0dda9517d41434a7"></a>
template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a7c91eeacbdcb55de0dda9517d41434a7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a>&lt; Fn &gt; &amp;lhs, const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a>&lt; Fn &gt; &amp;rhs)</td></tr>
<tr class="separator:a7c91eeacbdcb55de0dda9517d41434a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa374c754addf788f926ccf3a6885c927"><td class="memTemplParams" colspan="2"><a id="aa374c754addf788f926ccf3a6885c927"></a>
template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:aa374c754addf788f926ccf3a6885c927"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a>&lt; Fn &gt; &amp;lhs, const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a>&lt; Fn &gt; &amp;rhs)</td></tr>
<tr class="separator:aa374c754addf788f926ccf3a6885c927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015674f342f7ec51e5e739c1a45d9af0"><td class="memTemplParams" colspan="2"><a id="a015674f342f7ec51e5e739c1a45d9af0"></a>
template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a015674f342f7ec51e5e739c1a45d9af0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a>&lt; Fn &gt; &amp;lhs, const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a>&lt; Fn &gt; &amp;rhs)</td></tr>
<tr class="separator:a015674f342f7ec51e5e739c1a45d9af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a737915f1b6d8aaf20c67dd3bcc583"><td class="memTemplParams" colspan="2"><a id="a54a737915f1b6d8aaf20c67dd3bcc583"></a>
template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a54a737915f1b6d8aaf20c67dd3bcc583"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a>&lt; Fn &gt; &amp;lhs, const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a>&lt; Fn &gt; &amp;rhs)</td></tr>
<tr class="separator:a54a737915f1b6d8aaf20c67dd3bcc583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17f78ee07e24f5a14d0de207c8f8b0c"><td class="memTemplParams" colspan="2"><a id="ac17f78ee07e24f5a14d0de207c8f8b0c"></a>
template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:ac17f78ee07e24f5a14d0de207c8f8b0c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a>&lt; Fn &gt; &amp;lhs, const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a>&lt; Fn &gt; &amp;rhs)</td></tr>
<tr class="separator:ac17f78ee07e24f5a14d0de207c8f8b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e8cff3ee1637db01fb2e8c04a4a9a0"><td class="memTemplParams" colspan="2">template&lt;typename Enum &gt; </td></tr>
<tr class="memitem:a14e8cff3ee1637db01fb2e8c04a4a9a0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d5/d36/classbit_1_1stl_1_1enum__range.html">enum_range</a>&lt; Enum &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a14e8cff3ee1637db01fb2e8c04a4a9a0">make_enum_range</a> ()</td></tr>
<tr class="memdesc:a14e8cff3ee1637db01fb2e8c04a4a9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an enum range from a given.  <a href="#a14e8cff3ee1637db01fb2e8c04a4a9a0">More...</a><br /></td></tr>
<tr class="separator:a14e8cff3ee1637db01fb2e8c04a4a9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31279bc7e0ea43b6d0815518eb4eb205"><td class="memTemplParams" colspan="2">template&lt;typename E , typename... Args&gt; </td></tr>
<tr class="memitem:a31279bc7e0ea43b6d0815518eb4eb205"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a31279bc7e0ea43b6d0815518eb4eb205">make_unexpected</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a31279bc7e0ea43b6d0815518eb4eb205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an unexpected type <code>E</code>.  <a href="#a31279bc7e0ea43b6d0815518eb4eb205">More...</a><br /></td></tr>
<tr class="separator:a31279bc7e0ea43b6d0815518eb4eb205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6c5510347f01baa4bc775e5f0a8e60"><td class="memTemplParams" colspan="2"><a id="a3b6c5510347f01baa4bc775e5f0a8e60"></a>
template&lt;typename E &gt; </td></tr>
<tr class="memitem:a3b6c5510347f01baa4bc775e5f0a8e60"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;lhs, const <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;rhs)</td></tr>
<tr class="separator:a3b6c5510347f01baa4bc775e5f0a8e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af661c7a7373e9d9ca48caf28f6713704"><td class="memTemplParams" colspan="2"><a id="af661c7a7373e9d9ca48caf28f6713704"></a>
template&lt;typename E &gt; </td></tr>
<tr class="memitem:af661c7a7373e9d9ca48caf28f6713704"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;lhs, const <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;rhs)</td></tr>
<tr class="separator:af661c7a7373e9d9ca48caf28f6713704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7894f24afd1c005c74f2eaaed532c1a9"><td class="memTemplParams" colspan="2"><a id="a7894f24afd1c005c74f2eaaed532c1a9"></a>
template&lt;typename E &gt; </td></tr>
<tr class="memitem:a7894f24afd1c005c74f2eaaed532c1a9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;lhs, const <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;rhs)</td></tr>
<tr class="separator:a7894f24afd1c005c74f2eaaed532c1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e1497d9879c987553f0b1a900184a8"><td class="memTemplParams" colspan="2"><a id="ac0e1497d9879c987553f0b1a900184a8"></a>
template&lt;typename E &gt; </td></tr>
<tr class="memitem:ac0e1497d9879c987553f0b1a900184a8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;lhs, const <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;rhs)</td></tr>
<tr class="separator:ac0e1497d9879c987553f0b1a900184a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9201f54187755ef7ddc63601d59096"><td class="memTemplParams" colspan="2"><a id="a4a9201f54187755ef7ddc63601d59096"></a>
template&lt;typename E &gt; </td></tr>
<tr class="memitem:a4a9201f54187755ef7ddc63601d59096"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;lhs, const <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;rhs)</td></tr>
<tr class="separator:a4a9201f54187755ef7ddc63601d59096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8a8ac4adbc69ab8064d2b3bf76dc34"><td class="memTemplParams" colspan="2"><a id="a0f8a8ac4adbc69ab8064d2b3bf76dc34"></a>
template&lt;typename E &gt; </td></tr>
<tr class="memitem:a0f8a8ac4adbc69ab8064d2b3bf76dc34"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;lhs, const <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt; E &gt; &amp;rhs)</td></tr>
<tr class="separator:a0f8a8ac4adbc69ab8064d2b3bf76dc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82bba08b983e2ffe1b64e7d5d9d7fc39"><td class="memTemplParams" colspan="2"><a id="a82bba08b983e2ffe1b64e7d5d9d7fc39"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:a82bba08b983e2ffe1b64e7d5d9d7fc39"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;rhs)</td></tr>
<tr class="separator:a82bba08b983e2ffe1b64e7d5d9d7fc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd27880d8a0303c15e5104557073ff5"><td class="memTemplParams" colspan="2"><a id="a7bd27880d8a0303c15e5104557073ff5"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:a7bd27880d8a0303c15e5104557073ff5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;rhs)</td></tr>
<tr class="separator:a7bd27880d8a0303c15e5104557073ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6343f5dff44a5f0a99d076dad8e85a"><td class="memTemplParams" colspan="2"><a id="a4b6343f5dff44a5f0a99d076dad8e85a"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:a4b6343f5dff44a5f0a99d076dad8e85a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;rhs)</td></tr>
<tr class="separator:a4b6343f5dff44a5f0a99d076dad8e85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1018c68bcc7c46bfd559c44e0690e615"><td class="memTemplParams" colspan="2"><a id="a1018c68bcc7c46bfd559c44e0690e615"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:a1018c68bcc7c46bfd559c44e0690e615"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;rhs)</td></tr>
<tr class="separator:a1018c68bcc7c46bfd559c44e0690e615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac232f2031db4879c226794adf9478023"><td class="memTemplParams" colspan="2"><a id="ac232f2031db4879c226794adf9478023"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:ac232f2031db4879c226794adf9478023"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;rhs)</td></tr>
<tr class="separator:ac232f2031db4879c226794adf9478023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36b3abf888bf767facaf3a30c6c3888"><td class="memTemplParams" colspan="2"><a id="ad36b3abf888bf767facaf3a30c6c3888"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:ad36b3abf888bf767facaf3a30c6c3888"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;rhs)</td></tr>
<tr class="separator:ad36b3abf888bf767facaf3a30c6c3888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9fcf904e9aac7ca0917d899cf04a56"><td class="memTemplParams" colspan="2"><a id="aac9fcf904e9aac7ca0917d899cf04a56"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:aac9fcf904e9aac7ca0917d899cf04a56"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:aac9fcf904e9aac7ca0917d899cf04a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7e9b325bd9a945c626872e128ea022"><td class="memTemplParams" colspan="2"><a id="a9d7e9b325bd9a945c626872e128ea022"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:a9d7e9b325bd9a945c626872e128ea022"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const T &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;rhs)</td></tr>
<tr class="separator:a9d7e9b325bd9a945c626872e128ea022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80efbf047baeddd45362c6c561e18c81"><td class="memTemplParams" colspan="2"><a id="a80efbf047baeddd45362c6c561e18c81"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:a80efbf047baeddd45362c6c561e18c81"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:a80efbf047baeddd45362c6c561e18c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ecad4f4cfce58e401c28386928b573e"><td class="memTemplParams" colspan="2"><a id="a3ecad4f4cfce58e401c28386928b573e"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:a3ecad4f4cfce58e401c28386928b573e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const T &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;rhs)</td></tr>
<tr class="separator:a3ecad4f4cfce58e401c28386928b573e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea6652b0f4bec94b780a32bb850e383"><td class="memTemplParams" colspan="2"><a id="aaea6652b0f4bec94b780a32bb850e383"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:aaea6652b0f4bec94b780a32bb850e383"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:aaea6652b0f4bec94b780a32bb850e383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1582ca152f6338cc1870308453aa04"><td class="memTemplParams" colspan="2"><a id="a7c1582ca152f6338cc1870308453aa04"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:a7c1582ca152f6338cc1870308453aa04"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const T &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;rhs)</td></tr>
<tr class="separator:a7c1582ca152f6338cc1870308453aa04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee119c738793b9cdcc7c91d66c54f830"><td class="memTemplParams" colspan="2"><a id="aee119c738793b9cdcc7c91d66c54f830"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:aee119c738793b9cdcc7c91d66c54f830"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:aee119c738793b9cdcc7c91d66c54f830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f33c548bdddeae9434db7ffb0da1c4"><td class="memTemplParams" colspan="2"><a id="ad0f33c548bdddeae9434db7ffb0da1c4"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:ad0f33c548bdddeae9434db7ffb0da1c4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const T &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;rhs)</td></tr>
<tr class="separator:ad0f33c548bdddeae9434db7ffb0da1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2b42d6014867a8940c046c7139477a"><td class="memTemplParams" colspan="2"><a id="aef2b42d6014867a8940c046c7139477a"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:aef2b42d6014867a8940c046c7139477a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:aef2b42d6014867a8940c046c7139477a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617e24b78eaa787041ce13d39762f666"><td class="memTemplParams" colspan="2"><a id="a617e24b78eaa787041ce13d39762f666"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:a617e24b78eaa787041ce13d39762f666"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const T &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;rhs)</td></tr>
<tr class="separator:a617e24b78eaa787041ce13d39762f666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac215f2fcd7dd84457ff27921f9da280b"><td class="memTemplParams" colspan="2"><a id="ac215f2fcd7dd84457ff27921f9da280b"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:ac215f2fcd7dd84457ff27921f9da280b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:ac215f2fcd7dd84457ff27921f9da280b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9274e96bf7a7607ed24ded45b33d0e"><td class="memTemplParams" colspan="2"><a id="a5a9274e96bf7a7607ed24ded45b33d0e"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:a5a9274e96bf7a7607ed24ded45b33d0e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const T &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;rhs)</td></tr>
<tr class="separator:a5a9274e96bf7a7607ed24ded45b33d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf27bb2b2158c21f3ec39eedb403e00"><td class="memTemplParams" colspan="2"><a id="acbf27bb2b2158c21f3ec39eedb403e00"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:acbf27bb2b2158c21f3ec39eedb403e00"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;lhs, const <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt; Error &gt; &amp;rhs)</td></tr>
<tr class="separator:acbf27bb2b2158c21f3ec39eedb403e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea6ff1e7a47bec2a850cd532c2b0021"><td class="memTemplParams" colspan="2"><a id="a1ea6ff1e7a47bec2a850cd532c2b0021"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:a1ea6ff1e7a47bec2a850cd532c2b0021"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt; Error &gt; &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;rhs)</td></tr>
<tr class="separator:a1ea6ff1e7a47bec2a850cd532c2b0021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8acf5f0b5e1f98da9761ddaedd50b8e8"><td class="memTemplParams" colspan="2"><a id="a8acf5f0b5e1f98da9761ddaedd50b8e8"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:a8acf5f0b5e1f98da9761ddaedd50b8e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;lhs, const <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt; Error &gt; &amp;rhs)</td></tr>
<tr class="separator:a8acf5f0b5e1f98da9761ddaedd50b8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b7690dca08df31922e6415b42de889"><td class="memTemplParams" colspan="2"><a id="a48b7690dca08df31922e6415b42de889"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:a48b7690dca08df31922e6415b42de889"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt; Error &gt; &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;rhs)</td></tr>
<tr class="separator:a48b7690dca08df31922e6415b42de889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78691355d1309249e39dee6c74c44766"><td class="memTemplParams" colspan="2"><a id="a78691355d1309249e39dee6c74c44766"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:a78691355d1309249e39dee6c74c44766"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;lhs, const <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt; Error &gt; &amp;rhs)</td></tr>
<tr class="separator:a78691355d1309249e39dee6c74c44766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281edc706b5288bd8292a0ab509f8a99"><td class="memTemplParams" colspan="2"><a id="a281edc706b5288bd8292a0ab509f8a99"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:a281edc706b5288bd8292a0ab509f8a99"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt; Error &gt; &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;rhs)</td></tr>
<tr class="separator:a281edc706b5288bd8292a0ab509f8a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ed003937af6fa491d141161c961539"><td class="memTemplParams" colspan="2"><a id="ab2ed003937af6fa491d141161c961539"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:ab2ed003937af6fa491d141161c961539"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;lhs, const <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt; Error &gt; &amp;rhs)</td></tr>
<tr class="separator:ab2ed003937af6fa491d141161c961539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34faa458b4c69b357c4310bedd9f09d6"><td class="memTemplParams" colspan="2"><a id="a34faa458b4c69b357c4310bedd9f09d6"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:a34faa458b4c69b357c4310bedd9f09d6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt; Error &gt; &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;rhs)</td></tr>
<tr class="separator:a34faa458b4c69b357c4310bedd9f09d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51112bc659c299f85a9c362b7c86f39b"><td class="memTemplParams" colspan="2"><a id="a51112bc659c299f85a9c362b7c86f39b"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:a51112bc659c299f85a9c362b7c86f39b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;lhs, const <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt; Error &gt; &amp;rhs)</td></tr>
<tr class="separator:a51112bc659c299f85a9c362b7c86f39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5810f464351cfbbcd40321fb95191956"><td class="memTemplParams" colspan="2"><a id="a5810f464351cfbbcd40321fb95191956"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:a5810f464351cfbbcd40321fb95191956"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt; Error &gt; &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;rhs)</td></tr>
<tr class="separator:a5810f464351cfbbcd40321fb95191956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff9340a636f14bf08c6dfc25d314976"><td class="memTemplParams" colspan="2"><a id="a3ff9340a636f14bf08c6dfc25d314976"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:a3ff9340a636f14bf08c6dfc25d314976"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;lhs, const <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt; Error &gt; &amp;rhs)</td></tr>
<tr class="separator:a3ff9340a636f14bf08c6dfc25d314976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c0df6bcb5836cc09c23a7bc87a45ec"><td class="memTemplParams" colspan="2"><a id="a10c0df6bcb5836cc09c23a7bc87a45ec"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:a10c0df6bcb5836cc09c23a7bc87a45ec"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt; Error &gt; &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;rhs)</td></tr>
<tr class="separator:a10c0df6bcb5836cc09c23a7bc87a45ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589627b6c0f91f04ef71e55088d3c25d"><td class="memTemplParams" colspan="2"><a id="a589627b6c0f91f04ef71e55088d3c25d"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:a589627b6c0f91f04ef71e55088d3c25d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;lhs, <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt; &amp;rhs)</td></tr>
<tr class="separator:a589627b6c0f91f04ef71e55088d3c25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552ec8cdb9b3ffe801ee72bed11e45a8"><td class="memTemplParams" colspan="2"><a id="a552ec8cdb9b3ffe801ee72bed11e45a8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a552ec8cdb9b3ffe801ee72bed11e45a8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; std::decay_t&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_expected</b> (T &amp;&amp;v)</td></tr>
<tr class="separator:a552ec8cdb9b3ffe801ee72bed11e45a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e67c34b573cb342bd7539bd5e15057"><td class="memItemLeft" align="right" valign="top"><a id="a20e67c34b573cb342bd7539bd5e15057"></a>
<a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>make_expected</b> ()</td></tr>
<tr class="separator:a20e67c34b573cb342bd7539bd5e15057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e449a8b98fa6042d5bfc4b41efa864"><td class="memTemplParams" colspan="2"><a id="a55e449a8b98fa6042d5bfc4b41efa864"></a>
template&lt;typename T , typename Error &gt; </td></tr>
<tr class="memitem:a55e449a8b98fa6042d5bfc4b41efa864"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, std::decay_t&lt; Error &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_expected_from_error</b> (Error &amp;&amp;e)</td></tr>
<tr class="separator:a55e449a8b98fa6042d5bfc4b41efa864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e852678f91d75a6dd3bfaaa5936e8d"><td class="memTemplParams" colspan="2"><a id="a39e852678f91d75a6dd3bfaaa5936e8d"></a>
template&lt;typename T , typename Error , typename U &gt; </td></tr>
<tr class="memitem:a39e852678f91d75a6dd3bfaaa5936e8d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T, Error &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_expected_from_error</b> (U &amp;&amp;u)</td></tr>
<tr class="separator:a39e852678f91d75a6dd3bfaaa5936e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632d1227a400c86e7217c6e8a5022668"><td class="memTemplParams" colspan="2"><a id="a632d1227a400c86e7217c6e8a5022668"></a>
template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a632d1227a400c86e7217c6e8a5022668"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; invoke_result_t&lt; std::decay_t&lt; Fn &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_expected_from_call</b> (Fn &amp;&amp;f)</td></tr>
<tr class="separator:a632d1227a400c86e7217c6e8a5022668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc07be03c7b93e780e6b6369cfb5c718"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:acc07be03c7b93e780e6b6369cfb5c718"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../db/dc4/classbit_1_1stl_1_1final__act.html">final_act</a>&lt; Func &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#acc07be03c7b93e780e6b6369cfb5c718">finally</a> (Func &amp;&amp;function) noexcept</td></tr>
<tr class="memdesc:acc07be03c7b93e780e6b6369cfb5c718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to generate a <a class="el" href="../../db/dc4/classbit_1_1stl_1_1final__act.html" title="This class leverages RAII to perform cleanup actions at the end of a scope. ">final_act</a>.  <a href="#acc07be03c7b93e780e6b6369cfb5c718">More...</a><br /></td></tr>
<tr class="separator:acc07be03c7b93e780e6b6369cfb5c718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f49b109d7088448b46673cb58124764"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2f49b109d7088448b46673cb58124764"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a2f49b109d7088448b46673cb58124764">hash_combine</a> (std::size_t &amp;seed, const T &amp;v)</td></tr>
<tr class="memdesc:a2f49b109d7088448b46673cb58124764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines the hash with another hash.  <a href="#a2f49b109d7088448b46673cb58124764">More...</a><br /></td></tr>
<tr class="separator:a2f49b109d7088448b46673cb58124764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9693facf6e039e9742d25bb169b13b23"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a9693facf6e039e9742d25bb169b13b23"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a9693facf6e039e9742d25bb169b13b23">hash_range</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a9693facf6e039e9742d25bb169b13b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes a range of entries, returning the result.  <a href="#a9693facf6e039e9742d25bb169b13b23">More...</a><br /></td></tr>
<tr class="separator:a9693facf6e039e9742d25bb169b13b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fcd550eed18391c0c378c3c1dcd802"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a30fcd550eed18391c0c378c3c1dcd802"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a30fcd550eed18391c0c378c3c1dcd802">hash_range</a> (std::size_t &amp;seed, InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a30fcd550eed18391c0c378c3c1dcd802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes a range of entries.  <a href="#a30fcd550eed18391c0c378c3c1dcd802">More...</a><br /></td></tr>
<tr class="separator:a30fcd550eed18391c0c378c3c1dcd802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584a27d0ea529578cfc11814176d3c77"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a584a27d0ea529578cfc11814176d3c77">hash_value</a> (std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:a584a27d0ea529578cfc11814176d3c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of a null pointer.  <a href="#a584a27d0ea529578cfc11814176d3c77">More...</a><br /></td></tr>
<tr class="separator:a584a27d0ea529578cfc11814176d3c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9403b1d1333c84854974c3a26930c43e"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a9403b1d1333c84854974c3a26930c43e">hash_value</a> (bool val) noexcept</td></tr>
<tr class="memdesc:a9403b1d1333c84854974c3a26930c43e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given bool.  <a href="#a9403b1d1333c84854974c3a26930c43e">More...</a><br /></td></tr>
<tr class="separator:a9403b1d1333c84854974c3a26930c43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63eb167c6e9f2f72cb951d98e6b524aa"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a63eb167c6e9f2f72cb951d98e6b524aa">hash_value</a> (char val) noexcept</td></tr>
<tr class="memdesc:a63eb167c6e9f2f72cb951d98e6b524aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given char.  <a href="#a63eb167c6e9f2f72cb951d98e6b524aa">More...</a><br /></td></tr>
<tr class="separator:a63eb167c6e9f2f72cb951d98e6b524aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0659afd18943b4b40ce92861a91508"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aec0659afd18943b4b40ce92861a91508">hash_value</a> (signed char val) noexcept</td></tr>
<tr class="memdesc:aec0659afd18943b4b40ce92861a91508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given signed char.  <a href="#aec0659afd18943b4b40ce92861a91508">More...</a><br /></td></tr>
<tr class="separator:aec0659afd18943b4b40ce92861a91508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66ae1724a126027297374c374b6ef6a"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aa66ae1724a126027297374c374b6ef6a">hash_value</a> (unsigned char val) noexcept</td></tr>
<tr class="memdesc:aa66ae1724a126027297374c374b6ef6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given unsigned char.  <a href="#aa66ae1724a126027297374c374b6ef6a">More...</a><br /></td></tr>
<tr class="separator:aa66ae1724a126027297374c374b6ef6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72f61cc97f25653194a936ee6b7dcf7"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ad72f61cc97f25653194a936ee6b7dcf7">hash_value</a> (wchar_t val) noexcept</td></tr>
<tr class="memdesc:ad72f61cc97f25653194a936ee6b7dcf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given wchar_t.  <a href="#ad72f61cc97f25653194a936ee6b7dcf7">More...</a><br /></td></tr>
<tr class="separator:ad72f61cc97f25653194a936ee6b7dcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c975f2d74a9235b487048cdf8379cc"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a71c975f2d74a9235b487048cdf8379cc">hash_value</a> (char16_t val) noexcept</td></tr>
<tr class="memdesc:a71c975f2d74a9235b487048cdf8379cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given char16_t.  <a href="#a71c975f2d74a9235b487048cdf8379cc">More...</a><br /></td></tr>
<tr class="separator:a71c975f2d74a9235b487048cdf8379cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d397ddf0317c66df2bfc01f46f8a5cf"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5d397ddf0317c66df2bfc01f46f8a5cf">hash_value</a> (char32_t val) noexcept</td></tr>
<tr class="memdesc:a5d397ddf0317c66df2bfc01f46f8a5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given char32_t.  <a href="#a5d397ddf0317c66df2bfc01f46f8a5cf">More...</a><br /></td></tr>
<tr class="separator:a5d397ddf0317c66df2bfc01f46f8a5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7154f4d7363372961d1e1994fa5bb7c7"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a7154f4d7363372961d1e1994fa5bb7c7">hash_value</a> (short val) noexcept</td></tr>
<tr class="memdesc:a7154f4d7363372961d1e1994fa5bb7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given short.  <a href="#a7154f4d7363372961d1e1994fa5bb7c7">More...</a><br /></td></tr>
<tr class="separator:a7154f4d7363372961d1e1994fa5bb7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a525d7be855171985a7193ecaecab76"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a4a525d7be855171985a7193ecaecab76">hash_value</a> (unsigned short val) noexcept</td></tr>
<tr class="memdesc:a4a525d7be855171985a7193ecaecab76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given unsigned short.  <a href="#a4a525d7be855171985a7193ecaecab76">More...</a><br /></td></tr>
<tr class="separator:a4a525d7be855171985a7193ecaecab76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f0ceba5bc16b60258fbf0506bcae35"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ae0f0ceba5bc16b60258fbf0506bcae35">hash_value</a> (int val) noexcept</td></tr>
<tr class="memdesc:ae0f0ceba5bc16b60258fbf0506bcae35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given int.  <a href="#ae0f0ceba5bc16b60258fbf0506bcae35">More...</a><br /></td></tr>
<tr class="separator:ae0f0ceba5bc16b60258fbf0506bcae35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a377050372166907861b21ab4b56c8"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a40a377050372166907861b21ab4b56c8">hash_value</a> (unsigned int val) noexcept</td></tr>
<tr class="memdesc:a40a377050372166907861b21ab4b56c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given unsigned int.  <a href="#a40a377050372166907861b21ab4b56c8">More...</a><br /></td></tr>
<tr class="separator:a40a377050372166907861b21ab4b56c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596483385fd40c05411995fb76e8cfa5"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a596483385fd40c05411995fb76e8cfa5">hash_value</a> (long val) noexcept</td></tr>
<tr class="memdesc:a596483385fd40c05411995fb76e8cfa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given long.  <a href="#a596483385fd40c05411995fb76e8cfa5">More...</a><br /></td></tr>
<tr class="separator:a596483385fd40c05411995fb76e8cfa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c2924b2f3e21ee85f0f514f59848e4"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a45c2924b2f3e21ee85f0f514f59848e4">hash_value</a> (unsigned long val) noexcept</td></tr>
<tr class="memdesc:a45c2924b2f3e21ee85f0f514f59848e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given unsigned long.  <a href="#a45c2924b2f3e21ee85f0f514f59848e4">More...</a><br /></td></tr>
<tr class="separator:a45c2924b2f3e21ee85f0f514f59848e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a97a54533bc83393bc21f5155c8f331"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5a97a54533bc83393bc21f5155c8f331">hash_value</a> (long long val) noexcept</td></tr>
<tr class="memdesc:a5a97a54533bc83393bc21f5155c8f331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given long long.  <a href="#a5a97a54533bc83393bc21f5155c8f331">More...</a><br /></td></tr>
<tr class="separator:a5a97a54533bc83393bc21f5155c8f331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f32f66345d679e5031c7e7197dadc4"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a16f32f66345d679e5031c7e7197dadc4">hash_value</a> (unsigned long long val) noexcept</td></tr>
<tr class="memdesc:a16f32f66345d679e5031c7e7197dadc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given unsigned long long.  <a href="#a16f32f66345d679e5031c7e7197dadc4">More...</a><br /></td></tr>
<tr class="separator:a16f32f66345d679e5031c7e7197dadc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fd58ad444420cb8b01a2832fdf496c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a77fd58ad444420cb8b01a2832fdf496c">hash_value</a> (float val) noexcept</td></tr>
<tr class="memdesc:a77fd58ad444420cb8b01a2832fdf496c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given float.  <a href="#a77fd58ad444420cb8b01a2832fdf496c">More...</a><br /></td></tr>
<tr class="separator:a77fd58ad444420cb8b01a2832fdf496c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8add61aed3531d951d4e8cce1013363"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aa8add61aed3531d951d4e8cce1013363">hash_value</a> (double val) noexcept</td></tr>
<tr class="memdesc:aa8add61aed3531d951d4e8cce1013363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given double.  <a href="#aa8add61aed3531d951d4e8cce1013363">More...</a><br /></td></tr>
<tr class="separator:aa8add61aed3531d951d4e8cce1013363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e06a2ef7ee4eb339d240272fa4a3eeb"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a4e06a2ef7ee4eb339d240272fa4a3eeb">hash_value</a> (long double val) noexcept</td></tr>
<tr class="memdesc:a4e06a2ef7ee4eb339d240272fa4a3eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given long double.  <a href="#a4e06a2ef7ee4eb339d240272fa4a3eeb">More...</a><br /></td></tr>
<tr class="separator:a4e06a2ef7ee4eb339d240272fa4a3eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcde1a36bf0d2e13786387e2b0150f1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4fcde1a36bf0d2e13786387e2b0150f1"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a4fcde1a36bf0d2e13786387e2b0150f1">hash_value</a> (T *const &amp;val) noexcept</td></tr>
<tr class="memdesc:a4fcde1a36bf0d2e13786387e2b0150f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given pointer.  <a href="#a4fcde1a36bf0d2e13786387e2b0150f1">More...</a><br /></td></tr>
<tr class="separator:a4fcde1a36bf0d2e13786387e2b0150f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20db1218b612cc2ab37f8dcd38615a72"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned N&gt; </td></tr>
<tr class="memitem:a20db1218b612cc2ab37f8dcd38615a72"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a20db1218b612cc2ab37f8dcd38615a72">hash_value</a> (T(&amp;val)[N])</td></tr>
<tr class="memdesc:a20db1218b612cc2ab37f8dcd38615a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given T array.  <a href="#a20db1218b612cc2ab37f8dcd38615a72">More...</a><br /></td></tr>
<tr class="separator:a20db1218b612cc2ab37f8dcd38615a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad849248942ee4fdca3f4d0c9f5ecb2ee"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned N&gt; </td></tr>
<tr class="memitem:ad849248942ee4fdca3f4d0c9f5ecb2ee"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ad849248942ee4fdca3f4d0c9f5ecb2ee">hash_value</a> (const T(&amp;val)[N])</td></tr>
<tr class="memdesc:ad849248942ee4fdca3f4d0c9f5ecb2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given T array.  <a href="#ad849248942ee4fdca3f4d0c9f5ecb2ee">More...</a><br /></td></tr>
<tr class="separator:ad849248942ee4fdca3f4d0c9f5ecb2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034adf6da7e194b42f547fd9893c7eb8"><td class="memTemplParams" colspan="2">template&lt;typename Enum &gt; </td></tr>
<tr class="memitem:a034adf6da7e194b42f547fd9893c7eb8"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a034adf6da7e194b42f547fd9893c7eb8">hash_value</a> (Enum val) noexcept</td></tr>
<tr class="memdesc:a034adf6da7e194b42f547fd9893c7eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes enum values.  <a href="#a034adf6da7e194b42f547fd9893c7eb8">More...</a><br /></td></tr>
<tr class="separator:a034adf6da7e194b42f547fd9893c7eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdef9b2830203ce585db5d761edd266"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a2fdef9b2830203ce585db5d761edd266"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a2fdef9b2830203ce585db5d761edd266">hash_value</a> (const Container &amp;container) noexcept</td></tr>
<tr class="memdesc:a2fdef9b2830203ce585db5d761edd266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes any given container.  <a href="#a2fdef9b2830203ce585db5d761edd266">More...</a><br /></td></tr>
<tr class="separator:a2fdef9b2830203ce585db5d761edd266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4b0d5342a805f542d824ef4348b9af"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a5f4b0d5342a805f542d824ef4348b9af"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5f4b0d5342a805f542d824ef4348b9af">hash_value</a> (const std::pair&lt; T, U &gt; &amp;pair)</td></tr>
<tr class="memdesc:a5f4b0d5342a805f542d824ef4348b9af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes a std::pair.  <a href="#a5f4b0d5342a805f542d824ef4348b9af">More...</a><br /></td></tr>
<tr class="separator:a5f4b0d5342a805f542d824ef4348b9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3887964130579e473a8c9ba19497f6"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a1d3887964130579e473a8c9ba19497f6"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a1d3887964130579e473a8c9ba19497f6">hash_value</a> (const std::tuple&lt; Args... &gt; &amp;tuple)</td></tr>
<tr class="memdesc:a1d3887964130579e473a8c9ba19497f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes a tuple of entries.  <a href="#a1d3887964130579e473a8c9ba19497f6">More...</a><br /></td></tr>
<tr class="separator:a1d3887964130579e473a8c9ba19497f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095457d6a448fa63db72891dda7ff055"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a095457d6a448fa63db72891dda7ff055"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a095457d6a448fa63db72891dda7ff055">hash_value</a> (const std::initializer_list&lt; T &gt; &amp;il)</td></tr>
<tr class="memdesc:a095457d6a448fa63db72891dda7ff055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes an initializer_list.  <a href="#a095457d6a448fa63db72891dda7ff055">More...</a><br /></td></tr>
<tr class="separator:a095457d6a448fa63db72891dda7ff055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ce9fdc997ce1f3c58f1c246ef65c21"><td class="memTemplParams" colspan="2">template&lt;typename Func , typename... Args&gt; </td></tr>
<tr class="memitem:a48ce9fdc997ce1f3c58f1c246ef65c21"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a48ce9fdc997ce1f3c58f1c246ef65c21">invoke</a> (Func &amp;&amp;function, Args &amp;&amp;... args) noexcept(noexcept(detail::invoke_impl(std::forward&lt; Func &gt;(function), std::forward&lt; Args &gt;(args)...))) -&gt; decltype(detail::invoke_impl(std::forward&lt; Func &gt;(function), std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="memdesc:a48ce9fdc997ce1f3c58f1c246ef65c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the Callable object <code>function</code> with the parameters <code>args</code>.  <a href="#a48ce9fdc997ce1f3c58f1c246ef65c21">More...</a><br /></td></tr>
<tr class="separator:a48ce9fdc997ce1f3c58f1c246ef65c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b254b21c3e850abecc2b128cb236b3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a83b254b21c3e850abecc2b128cb236b3"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a83b254b21c3e850abecc2b128cb236b3">hash_value</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;val)</td></tr>
<tr class="memdesc:a83b254b21c3e850abecc2b128cb236b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a hash of the underlying lazy, instantiating it if not already instantiated.  <a href="#a83b254b21c3e850abecc2b128cb236b3">More...</a><br /></td></tr>
<tr class="separator:a83b254b21c3e850abecc2b128cb236b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea22e81640ef84b40a63a3aa0280a2f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a9ea22e81640ef84b40a63a3aa0280a2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a9ea22e81640ef84b40a63a3aa0280a2f">make_lazy</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a9ea22e81640ef84b40a63a3aa0280a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a lazy type from the given arguments.  <a href="#a9ea22e81640ef84b40a63a3aa0280a2f">More...</a><br /></td></tr>
<tr class="separator:a9ea22e81640ef84b40a63a3aa0280a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769c3379a597a59899d35d552c8a14a2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename... Args&gt; </td></tr>
<tr class="memitem:a769c3379a597a59899d35d552c8a14a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a769c3379a597a59899d35d552c8a14a2">make_lazy</a> (std::initializer_list&lt; U &gt; ilist, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a769c3379a597a59899d35d552c8a14a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a lazy type from the given arguments.  <a href="#a769c3379a597a59899d35d552c8a14a2">More...</a><br /></td></tr>
<tr class="separator:a769c3379a597a59899d35d552c8a14a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7844a4592038b7ba6cf898167d593d4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Ctor &gt; </td></tr>
<tr class="memitem:ad7844a4592038b7ba6cf898167d593d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ad7844a4592038b7ba6cf898167d593d4">make_lazy_generator</a> (Ctor &amp;&amp;ctor)</td></tr>
<tr class="memdesc:ad7844a4592038b7ba6cf898167d593d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a lazy type that uses a generator function to generate the arguments that will be forwarded to T's constructor.  <a href="#ad7844a4592038b7ba6cf898167d593d4">More...</a><br /></td></tr>
<tr class="separator:ad7844a4592038b7ba6cf898167d593d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2212f7f9bb1f2ffa862da0cbcd2301"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e2212f7f9bb1f2ffa862da0cbcd2301"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a0e2212f7f9bb1f2ffa862da0cbcd2301">swap</a> (<a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a0e2212f7f9bb1f2ffa862da0cbcd2301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the lazy from <code>lhs</code> and <code>rhs</code>.  <a href="#a0e2212f7f9bb1f2ffa862da0cbcd2301">More...</a><br /></td></tr>
<tr class="separator:a0e2212f7f9bb1f2ffa862da0cbcd2301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c2c4bcf46f871a44c4d39ae1f829c4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69c2c4bcf46f871a44c4d39ae1f829c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a69c2c4bcf46f871a44c4d39ae1f829c4">operator==</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a69c2c4bcf46f871a44c4d39ae1f829c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the left and right lazy elements together for equality, using the underlying type's operator==.  <a href="#a69c2c4bcf46f871a44c4d39ae1f829c4">More...</a><br /></td></tr>
<tr class="separator:a69c2c4bcf46f871a44c4d39ae1f829c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7b385636356ef469ca965df7b6372c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef7b385636356ef469ca965df7b6372c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aef7b385636356ef469ca965df7b6372c">operator==</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:aef7b385636356ef469ca965df7b6372c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the left and right lazy elements together for equality, using the underlying type's operator==.  <a href="#aef7b385636356ef469ca965df7b6372c">More...</a><br /></td></tr>
<tr class="separator:aef7b385636356ef469ca965df7b6372c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3a169fb3e7d89f16f12ea8d5ccd0a9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaa3a169fb3e7d89f16f12ea8d5ccd0a9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aaa3a169fb3e7d89f16f12ea8d5ccd0a9">operator==</a> (const T &amp;lhs, const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aaa3a169fb3e7d89f16f12ea8d5ccd0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the left and right lazy elements together for equality, using the underlying type's operator==.  <a href="#aaa3a169fb3e7d89f16f12ea8d5ccd0a9">More...</a><br /></td></tr>
<tr class="separator:aaa3a169fb3e7d89f16f12ea8d5ccd0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ace58348d55a83f9d4b81df99724d33"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ace58348d55a83f9d4b81df99724d33"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a0ace58348d55a83f9d4b81df99724d33">operator!=</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a0ace58348d55a83f9d4b81df99724d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the left and right lazy elements together for inequality, using the underlying type's operator!=.  <a href="#a0ace58348d55a83f9d4b81df99724d33">More...</a><br /></td></tr>
<tr class="separator:a0ace58348d55a83f9d4b81df99724d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e9db0b731c0f094b5fa4b5a248d46e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a23e9db0b731c0f094b5fa4b5a248d46e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a23e9db0b731c0f094b5fa4b5a248d46e">operator!=</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:a23e9db0b731c0f094b5fa4b5a248d46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the left and right lazy elements together for inequality, using the underlying type's operator!=.  <a href="#a23e9db0b731c0f094b5fa4b5a248d46e">More...</a><br /></td></tr>
<tr class="separator:a23e9db0b731c0f094b5fa4b5a248d46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3aa6b26006dfe792cf209e7705a192"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e3aa6b26006dfe792cf209e7705a192"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a9e3aa6b26006dfe792cf209e7705a192">operator!=</a> (const T &amp;lhs, const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9e3aa6b26006dfe792cf209e7705a192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the left and right lazy elements together for inequality, using the underlying type's operator!=.  <a href="#a9e3aa6b26006dfe792cf209e7705a192">More...</a><br /></td></tr>
<tr class="separator:a9e3aa6b26006dfe792cf209e7705a192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec221617391931c78569a3d2702b288"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2ec221617391931c78569a3d2702b288"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a2ec221617391931c78569a3d2702b288">operator&lt;</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2ec221617391931c78569a3d2702b288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>lhs</code> &lt; <code>rhs</code>, using the underlying type's <code>operator&lt;</code>.  <a href="#a2ec221617391931c78569a3d2702b288">More...</a><br /></td></tr>
<tr class="separator:a2ec221617391931c78569a3d2702b288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1aef677a777630f327620d039ec22bd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac1aef677a777630f327620d039ec22bd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ac1aef677a777630f327620d039ec22bd">operator&lt;</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ac1aef677a777630f327620d039ec22bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>lhs</code> &lt; <code>rhs</code>, using the underlying type's <code>operator&lt;</code>.  <a href="#ac1aef677a777630f327620d039ec22bd">More...</a><br /></td></tr>
<tr class="separator:ac1aef677a777630f327620d039ec22bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65343987a73506a66147635c970ce0af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a65343987a73506a66147635c970ce0af"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a65343987a73506a66147635c970ce0af">operator&lt;</a> (const T &amp;lhs, const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a65343987a73506a66147635c970ce0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>lhs</code> &lt; <code>rhs</code>, using the underlying type's <code>operator&lt;</code>.  <a href="#a65343987a73506a66147635c970ce0af">More...</a><br /></td></tr>
<tr class="separator:a65343987a73506a66147635c970ce0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2694a1ebe40355527138a693adb98b3b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2694a1ebe40355527138a693adb98b3b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a2694a1ebe40355527138a693adb98b3b">operator&lt;=</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2694a1ebe40355527138a693adb98b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>lhs</code> &lt;= <code>rhs</code>, using the underlying type's <code>operator&lt;=</code>.  <a href="#a2694a1ebe40355527138a693adb98b3b">More...</a><br /></td></tr>
<tr class="separator:a2694a1ebe40355527138a693adb98b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbabcb48392e608812339f0f57526efb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afbabcb48392e608812339f0f57526efb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#afbabcb48392e608812339f0f57526efb">operator&lt;=</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:afbabcb48392e608812339f0f57526efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>lhs</code> &lt;= <code>rhs</code>, using the underlying type's <code>operator&lt;=</code>.  <a href="#afbabcb48392e608812339f0f57526efb">More...</a><br /></td></tr>
<tr class="separator:afbabcb48392e608812339f0f57526efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f0f2791bf66cf30bdf5311f48f6f3e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a92f0f2791bf66cf30bdf5311f48f6f3e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a92f0f2791bf66cf30bdf5311f48f6f3e">operator&lt;=</a> (const T &amp;lhs, const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a92f0f2791bf66cf30bdf5311f48f6f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>lhs</code> &lt;= <code>rhs</code>, using the underlying type's <code>operator&lt;=</code>.  <a href="#a92f0f2791bf66cf30bdf5311f48f6f3e">More...</a><br /></td></tr>
<tr class="separator:a92f0f2791bf66cf30bdf5311f48f6f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746813e83ffff1853ff45291ea291a8b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a746813e83ffff1853ff45291ea291a8b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a746813e83ffff1853ff45291ea291a8b">operator&gt;</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a746813e83ffff1853ff45291ea291a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>lhs</code> &gt; <code>rhs</code>, using the underlying type's <code>operator&gt;</code>  <a href="#a746813e83ffff1853ff45291ea291a8b">More...</a><br /></td></tr>
<tr class="separator:a746813e83ffff1853ff45291ea291a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f76db3bf68fa12d31cefd4888223bf9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9f76db3bf68fa12d31cefd4888223bf9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a9f76db3bf68fa12d31cefd4888223bf9">operator&gt;</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:a9f76db3bf68fa12d31cefd4888223bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>lhs</code> &gt; <code>rhs</code>, using the underlying type's <code>operator&gt;</code>  <a href="#a9f76db3bf68fa12d31cefd4888223bf9">More...</a><br /></td></tr>
<tr class="separator:a9f76db3bf68fa12d31cefd4888223bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775f362ae0a51d2f0125e1168a2fc590"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a775f362ae0a51d2f0125e1168a2fc590"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a775f362ae0a51d2f0125e1168a2fc590">operator&gt;</a> (const T &amp;lhs, const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a775f362ae0a51d2f0125e1168a2fc590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>lhs</code> &gt; <code>rhs</code>, using the underlying type's <code>operator&gt;</code>  <a href="#a775f362ae0a51d2f0125e1168a2fc590">More...</a><br /></td></tr>
<tr class="separator:a775f362ae0a51d2f0125e1168a2fc590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8e6565cc41cde9536df9c09e51d778"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c8e6565cc41cde9536df9c09e51d778"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a7c8e6565cc41cde9536df9c09e51d778">operator&gt;=</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7c8e6565cc41cde9536df9c09e51d778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>lhs</code> &gt;= <code>rhs</code>, using the underlying type's <code>operator&gt;=</code>.  <a href="#a7c8e6565cc41cde9536df9c09e51d778">More...</a><br /></td></tr>
<tr class="separator:a7c8e6565cc41cde9536df9c09e51d778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436993f5969646f1923b2f6f6f8e8c11"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a436993f5969646f1923b2f6f6f8e8c11"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a436993f5969646f1923b2f6f6f8e8c11">operator&gt;=</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:a436993f5969646f1923b2f6f6f8e8c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>lhs</code> &gt;= <code>rhs</code>, using the underlying type's <code>operator&gt;=</code>.  <a href="#a436993f5969646f1923b2f6f6f8e8c11">More...</a><br /></td></tr>
<tr class="separator:a436993f5969646f1923b2f6f6f8e8c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a001b72215d0b5e3721b12564542d95"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5a001b72215d0b5e3721b12564542d95"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5a001b72215d0b5e3721b12564542d95">operator&gt;=</a> (const T &amp;lhs, const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5a001b72215d0b5e3721b12564542d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>lhs</code> &gt;= <code>rhs</code>, using the underlying type's <code>operator&gt;=</code>.  <a href="#a5a001b72215d0b5e3721b12564542d95">More...</a><br /></td></tr>
<tr class="separator:a5a001b72215d0b5e3721b12564542d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902fc7c0580a1e72f4a126290f57f56a"><td class="memItemLeft" align="right" valign="top"><a id="a902fc7c0580a1e72f4a126290f57f56a"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/db2/structbit_1_1stl_1_1monostate">monostate</a>, <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/db2/structbit_1_1stl_1_1monostate">monostate</a>) noexcept</td></tr>
<tr class="separator:a902fc7c0580a1e72f4a126290f57f56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdf013f088b0d67b92da8affe239ea5"><td class="memItemLeft" align="right" valign="top"><a id="aecdf013f088b0d67b92da8affe239ea5"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/db2/structbit_1_1stl_1_1monostate">monostate</a>, <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/db2/structbit_1_1stl_1_1monostate">monostate</a>) noexcept</td></tr>
<tr class="separator:aecdf013f088b0d67b92da8affe239ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcb53834f73b4f22c04eae915f7b3d8"><td class="memItemLeft" align="right" valign="top"><a id="adbcb53834f73b4f22c04eae915f7b3d8"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/db2/structbit_1_1stl_1_1monostate">monostate</a>, <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/db2/structbit_1_1stl_1_1monostate">monostate</a>) noexcept</td></tr>
<tr class="separator:adbcb53834f73b4f22c04eae915f7b3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137fe888e460f6e6d3fb1b8ab4217e3c"><td class="memItemLeft" align="right" valign="top"><a id="a137fe888e460f6e6d3fb1b8ab4217e3c"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/db2/structbit_1_1stl_1_1monostate">monostate</a>, <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/db2/structbit_1_1stl_1_1monostate">monostate</a>) noexcept</td></tr>
<tr class="separator:a137fe888e460f6e6d3fb1b8ab4217e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce305df7a66bca34ae0ff1c8f209f11"><td class="memItemLeft" align="right" valign="top"><a id="a8ce305df7a66bca34ae0ff1c8f209f11"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/db2/structbit_1_1stl_1_1monostate">monostate</a>, <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/db2/structbit_1_1stl_1_1monostate">monostate</a>) noexcept</td></tr>
<tr class="separator:a8ce305df7a66bca34ae0ff1c8f209f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7eca25256ab10ec3893d811d863b96f"><td class="memItemLeft" align="right" valign="top"><a id="af7eca25256ab10ec3893d811d863b96f"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/db2/structbit_1_1stl_1_1monostate">monostate</a>, <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/db2/structbit_1_1stl_1_1monostate">monostate</a>) noexcept</td></tr>
<tr class="separator:af7eca25256ab10ec3893d811d863b96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ea8727fd45f88a76ad6f9831623f0b"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a02ea8727fd45f88a76ad6f9831623f0b">hash_value</a> (const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/db2/structbit_1_1stl_1_1monostate">monostate</a> &amp;)</td></tr>
<tr class="memdesc:a02ea8727fd45f88a76ad6f9831623f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes the monostate.  <a href="#a02ea8727fd45f88a76ad6f9831623f0b">More...</a><br /></td></tr>
<tr class="separator:a02ea8727fd45f88a76ad6f9831623f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaaba5e942c77826b17b02c17b1b11de"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaaaba5e942c77826b17b02c17b1b11de"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aaaaba5e942c77826b17b02c17b1b11de">operator==</a> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aaaaba5e942c77826b17b02c17b1b11de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs equality operation on two optionals.  <a href="#aaaaba5e942c77826b17b02c17b1b11de">More...</a><br /></td></tr>
<tr class="separator:aaaaba5e942c77826b17b02c17b1b11de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7369b94edb1aa30603f6a4295280f810"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7369b94edb1aa30603f6a4295280f810"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a7369b94edb1aa30603f6a4295280f810">operator!=</a> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7369b94edb1aa30603f6a4295280f810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs inequality operation on two optionals.  <a href="#a7369b94edb1aa30603f6a4295280f810">More...</a><br /></td></tr>
<tr class="separator:a7369b94edb1aa30603f6a4295280f810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3e384d5ee5018ce420f7282e1d6992"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaf3e384d5ee5018ce420f7282e1d6992"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aaf3e384d5ee5018ce420f7282e1d6992">operator&lt;</a> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aaf3e384d5ee5018ce420f7282e1d6992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs less-than operation on two optionals.  <a href="#aaf3e384d5ee5018ce420f7282e1d6992">More...</a><br /></td></tr>
<tr class="separator:aaf3e384d5ee5018ce420f7282e1d6992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa00301df0b90006322ef8fd5fc4f7d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9fa00301df0b90006322ef8fd5fc4f7d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a9fa00301df0b90006322ef8fd5fc4f7d">operator&gt;</a> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9fa00301df0b90006322ef8fd5fc4f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs greater-than operation on two optionals.  <a href="#a9fa00301df0b90006322ef8fd5fc4f7d">More...</a><br /></td></tr>
<tr class="separator:a9fa00301df0b90006322ef8fd5fc4f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab66a890e7dea7249c4f81241f15753"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adab66a890e7dea7249c4f81241f15753"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#adab66a890e7dea7249c4f81241f15753">operator&lt;=</a> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:adab66a890e7dea7249c4f81241f15753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs less-than or equal operation on two optionals.  <a href="#adab66a890e7dea7249c4f81241f15753">More...</a><br /></td></tr>
<tr class="separator:adab66a890e7dea7249c4f81241f15753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba083b0665196f2dab5de18013deed76"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba083b0665196f2dab5de18013deed76"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aba083b0665196f2dab5de18013deed76">operator&gt;=</a> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aba083b0665196f2dab5de18013deed76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs greater-than or equal operation on two optionals.  <a href="#aba083b0665196f2dab5de18013deed76">More...</a><br /></td></tr>
<tr class="separator:aba083b0665196f2dab5de18013deed76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d468ebd21c10de843bf66b67bb62651"><td class="memTemplParams" colspan="2"><a id="a8d468ebd21c10de843bf66b67bb62651"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d468ebd21c10de843bf66b67bb62651"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, <a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="separator:a8d468ebd21c10de843bf66b67bb62651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51a1322aca1335eb7c30958a9f922e3"><td class="memTemplParams" colspan="2"><a id="ad51a1322aca1335eb7c30958a9f922e3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad51a1322aca1335eb7c30958a9f922e3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt) noexcept</td></tr>
<tr class="separator:ad51a1322aca1335eb7c30958a9f922e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0743d43e39ea47c58e450d43d3c99f"><td class="memTemplParams" colspan="2"><a id="a9c0743d43e39ea47c58e450d43d3c99f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9c0743d43e39ea47c58e450d43d3c99f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, <a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="separator:a9c0743d43e39ea47c58e450d43d3c99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7429fed1de43b0a99218e8df8f7bc84d"><td class="memTemplParams" colspan="2"><a id="a7429fed1de43b0a99218e8df8f7bc84d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7429fed1de43b0a99218e8df8f7bc84d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt) noexcept</td></tr>
<tr class="separator:a7429fed1de43b0a99218e8df8f7bc84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21838e498bbc3b46b470f6a0d1d577b6"><td class="memTemplParams" colspan="2"><a id="a21838e498bbc3b46b470f6a0d1d577b6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a21838e498bbc3b46b470f6a0d1d577b6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, <a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="separator:a21838e498bbc3b46b470f6a0d1d577b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1745c626ec88eb59f3a74ceb9b07854a"><td class="memTemplParams" colspan="2"><a id="a1745c626ec88eb59f3a74ceb9b07854a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1745c626ec88eb59f3a74ceb9b07854a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (<a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt) noexcept</td></tr>
<tr class="separator:a1745c626ec88eb59f3a74ceb9b07854a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d97b22733867e49e2c2d4f08acbc2c"><td class="memTemplParams" colspan="2"><a id="a44d97b22733867e49e2c2d4f08acbc2c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a44d97b22733867e49e2c2d4f08acbc2c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, <a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="separator:a44d97b22733867e49e2c2d4f08acbc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c817ef96b40431e90522aec5497b30"><td class="memTemplParams" colspan="2"><a id="ad6c817ef96b40431e90522aec5497b30"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad6c817ef96b40431e90522aec5497b30"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (<a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt) noexcept</td></tr>
<tr class="separator:ad6c817ef96b40431e90522aec5497b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89ecfb5d05172a7b52e27bcdc6afae0"><td class="memTemplParams" colspan="2"><a id="af89ecfb5d05172a7b52e27bcdc6afae0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af89ecfb5d05172a7b52e27bcdc6afae0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, <a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="separator:af89ecfb5d05172a7b52e27bcdc6afae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89e286747f45b323c53c977331c5c18"><td class="memTemplParams" colspan="2"><a id="af89e286747f45b323c53c977331c5c18"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af89e286747f45b323c53c977331c5c18"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (<a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt) noexcept</td></tr>
<tr class="separator:af89e286747f45b323c53c977331c5c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171b376a8a6730142c6a1cd5112d81ca"><td class="memTemplParams" colspan="2"><a id="a171b376a8a6730142c6a1cd5112d81ca"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a171b376a8a6730142c6a1cd5112d81ca"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, <a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="separator:a171b376a8a6730142c6a1cd5112d81ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad213ee2af8b22973824008ad9e854f51"><td class="memTemplParams" colspan="2"><a id="ad213ee2af8b22973824008ad9e854f51"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad213ee2af8b22973824008ad9e854f51"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (<a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt) noexcept</td></tr>
<tr class="separator:ad213ee2af8b22973824008ad9e854f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10161d16c7af018164476d9c6376fbdf"><td class="memTemplParams" colspan="2"><a id="a10161d16c7af018164476d9c6376fbdf"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a10161d16c7af018164476d9c6376fbdf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, const T &amp;value)</td></tr>
<tr class="separator:a10161d16c7af018164476d9c6376fbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa708b85854276fe0c7ee60857abc57a0"><td class="memTemplParams" colspan="2"><a id="aa708b85854276fe0c7ee60857abc57a0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa708b85854276fe0c7ee60857abc57a0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const T &amp;value, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt)</td></tr>
<tr class="separator:aa708b85854276fe0c7ee60857abc57a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec705ac977aafbb2d61936df90db0011"><td class="memTemplParams" colspan="2"><a id="aec705ac977aafbb2d61936df90db0011"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec705ac977aafbb2d61936df90db0011"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, const T &amp;value)</td></tr>
<tr class="separator:aec705ac977aafbb2d61936df90db0011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084d90c38a8295362eeaad9845527c77"><td class="memTemplParams" colspan="2"><a id="a084d90c38a8295362eeaad9845527c77"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a084d90c38a8295362eeaad9845527c77"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const T &amp;value, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt)</td></tr>
<tr class="separator:a084d90c38a8295362eeaad9845527c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a5690de559eedd892b5835a3b64730"><td class="memTemplParams" colspan="2"><a id="a34a5690de559eedd892b5835a3b64730"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a34a5690de559eedd892b5835a3b64730"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, const T &amp;value)</td></tr>
<tr class="separator:a34a5690de559eedd892b5835a3b64730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96f5dfd64a567b611e278dad6e130c6"><td class="memTemplParams" colspan="2"><a id="ae96f5dfd64a567b611e278dad6e130c6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae96f5dfd64a567b611e278dad6e130c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const T &amp;value, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt)</td></tr>
<tr class="separator:ae96f5dfd64a567b611e278dad6e130c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65708fafc93c59842f0c5c612ea8ece"><td class="memTemplParams" colspan="2"><a id="aa65708fafc93c59842f0c5c612ea8ece"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa65708fafc93c59842f0c5c612ea8ece"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, const T &amp;value)</td></tr>
<tr class="separator:aa65708fafc93c59842f0c5c612ea8ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa956802d5615065acf18021fc03a63e8"><td class="memTemplParams" colspan="2"><a id="aa956802d5615065acf18021fc03a63e8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa956802d5615065acf18021fc03a63e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const T &amp;value, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt)</td></tr>
<tr class="separator:aa956802d5615065acf18021fc03a63e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f5db6b83313d46213f05358da1936b"><td class="memTemplParams" colspan="2"><a id="ad5f5db6b83313d46213f05358da1936b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad5f5db6b83313d46213f05358da1936b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, const T &amp;value)</td></tr>
<tr class="separator:ad5f5db6b83313d46213f05358da1936b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0e944f121c45962d6ad972f3948480"><td class="memTemplParams" colspan="2"><a id="aca0e944f121c45962d6ad972f3948480"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca0e944f121c45962d6ad972f3948480"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const T &amp;value, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt)</td></tr>
<tr class="separator:aca0e944f121c45962d6ad972f3948480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2967a4e7a60a01d4a0eb053a27b3b1"><td class="memTemplParams" colspan="2"><a id="abf2967a4e7a60a01d4a0eb053a27b3b1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abf2967a4e7a60a01d4a0eb053a27b3b1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, const T &amp;value)</td></tr>
<tr class="separator:abf2967a4e7a60a01d4a0eb053a27b3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44347c35d9b6f432ba1b5c90075b7edc"><td class="memTemplParams" colspan="2"><a id="a44347c35d9b6f432ba1b5c90075b7edc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a44347c35d9b6f432ba1b5c90075b7edc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const T &amp;value, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt)</td></tr>
<tr class="separator:a44347c35d9b6f432ba1b5c90075b7edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1685414ab5b9729175258024c1f034a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad1685414ab5b9729175258024c1f034a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; std::decay_t&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ad1685414ab5b9729175258024c1f034a">make_optional</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:ad1685414ab5b9729175258024c1f034a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an optional object from <code>value</code>.  <a href="#ad1685414ab5b9729175258024c1f034a">More...</a><br /></td></tr>
<tr class="separator:ad1685414ab5b9729175258024c1f034a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c586d69708cf2aa3d6196f5c38e5edd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a4c586d69708cf2aa3d6196f5c38e5edd"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a4c586d69708cf2aa3d6196f5c38e5edd">make_optional</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a4c586d69708cf2aa3d6196f5c38e5edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an optional object of type <code>T</code> from the given <code>args</code>.  <a href="#a4c586d69708cf2aa3d6196f5c38e5edd">More...</a><br /></td></tr>
<tr class="separator:a4c586d69708cf2aa3d6196f5c38e5edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcc7a61cae2e21593e248e3996eac0c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename... Args&gt; </td></tr>
<tr class="memitem:abdcc7a61cae2e21593e248e3996eac0c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#abdcc7a61cae2e21593e248e3996eac0c">make_optional</a> (std::initializer_list&lt; U &gt; il, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:abdcc7a61cae2e21593e248e3996eac0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an optional object of type <code>T</code> from the given <code>il</code> <code>args</code>.  <a href="#abdcc7a61cae2e21593e248e3996eac0c">More...</a><br /></td></tr>
<tr class="separator:abdcc7a61cae2e21593e248e3996eac0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fc15967879a2d062e81cf59e4b80c5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a39fc15967879a2d062e81cf59e4b80c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a39fc15967879a2d062e81cf59e4b80c5">swap</a> (<a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a39fc15967879a2d062e81cf59e4b80c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <code>lhs</code> and <code>rhs</code>.  <a href="#a39fc15967879a2d062e81cf59e4b80c5">More...</a><br /></td></tr>
<tr class="separator:a39fc15967879a2d062e81cf59e4b80c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4f9bef5f51b8b9fde39f5ab1b29212"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0d4f9bef5f51b8b9fde39f5ab1b29212"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a0d4f9bef5f51b8b9fde39f5ab1b29212">hash_value</a> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;s) noexcept</td></tr>
<tr class="memdesc:a0d4f9bef5f51b8b9fde39f5ab1b29212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the hash from a given optional.  <a href="#a0d4f9bef5f51b8b9fde39f5ab1b29212">More...</a><br /></td></tr>
<tr class="separator:a0d4f9bef5f51b8b9fde39f5ab1b29212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44311fa8af9c4066b4aff80158e37429"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a44311fa8af9c4066b4aff80158e37429"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/dde/classbit_1_1stl_1_1pointer__wrapper.html">pointer_wrapper</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a44311fa8af9c4066b4aff80158e37429">make_pointer_wrapper</a> (Args &amp;&amp;...args) noexcept(std::is_nothrow_constructible&lt; T, Args... &gt;::value)</td></tr>
<tr class="memdesc:a44311fa8af9c4066b4aff80158e37429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a <a class="el" href="../../d6/dde/classbit_1_1stl_1_1pointer__wrapper.html" title="A wrapper type around a given type that allows it to be treated with pointer-semantics instead of ref...">pointer_wrapper</a> of the underlying type.  <a href="#a44311fa8af9c4066b4aff80158e37429">More...</a><br /></td></tr>
<tr class="separator:a44311fa8af9c4066b4aff80158e37429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1108cce7da03dc43b2e4db96604ccca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af1108cce7da03dc43b2e4db96604ccca"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#af1108cce7da03dc43b2e4db96604ccca">swap</a> (<a class="el" href="../../d6/d6a/classbit_1_1stl_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../d6/d6a/classbit_1_1stl_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:af1108cce7da03dc43b2e4db96604ccca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the two propagate_consts.  <a href="#af1108cce7da03dc43b2e4db96604ccca">More...</a><br /></td></tr>
<tr class="separator:af1108cce7da03dc43b2e4db96604ccca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c483265cee8b59be7c053f892262432"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8c483265cee8b59be7c053f892262432"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a8c483265cee8b59be7c053f892262432">hash_value</a> (const <a class="el" href="../../d6/d6a/classbit_1_1stl_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:a8c483265cee8b59be7c053f892262432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes the value of the underlying type of the <a class="el" href="../../d6/d6a/classbit_1_1stl_1_1propagate__const.html" title="A wrapper to propagate the const qualifier. ">propagate_const</a>.  <a href="#a8c483265cee8b59be7c053f892262432">More...</a><br /></td></tr>
<tr class="separator:a8c483265cee8b59be7c053f892262432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2a34d2c6d7bbb220c7d8ac2a79c458"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a4f2a34d2c6d7bbb220c7d8ac2a79c458">operator==</a> (const <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html">source_location</a> &amp;lhs, const <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html">source_location</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a4f2a34d2c6d7bbb220c7d8ac2a79c458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines equality between two source_locations.  <a href="#a4f2a34d2c6d7bbb220c7d8ac2a79c458">More...</a><br /></td></tr>
<tr class="separator:a4f2a34d2c6d7bbb220c7d8ac2a79c458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae180be04635d8455a78ecd80b67ffe55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ae180be04635d8455a78ecd80b67ffe55">operator!=</a> (const <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html">source_location</a> &amp;lhs, const <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html">source_location</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ae180be04635d8455a78ecd80b67ffe55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines inequality between two source_locations.  <a href="#ae180be04635d8455a78ecd80b67ffe55">More...</a><br /></td></tr>
<tr class="separator:ae180be04635d8455a78ecd80b67ffe55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0dbaaca037aad1973f344bc1f6bbd81"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ad0dbaaca037aad1973f344bc1f6bbd81">indeterminate</a> (const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:ad0dbaaca037aad1973f344bc1f6bbd81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tribool is indeterminate.  <a href="#ad0dbaaca037aad1973f344bc1f6bbd81">More...</a><br /></td></tr>
<tr class="separator:ad0dbaaca037aad1973f344bc1f6bbd81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968683d715c2057ccd509693daac42de"><td class="memItemLeft" align="right" valign="top"><a id="a968683d715c2057ccd509693daac42de"></a>
constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>hash_value</b> (<a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> t) noexcept</td></tr>
<tr class="separator:a968683d715c2057ccd509693daac42de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8dec5bd2fc486c8d2144b3d7f17943"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a1f8dec5bd2fc486c8d2144b3d7f17943">operator==</a> (const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;lhs, const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a1f8dec5bd2fc486c8d2144b3d7f17943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two tribooleans.  <a href="#a1f8dec5bd2fc486c8d2144b3d7f17943">More...</a><br /></td></tr>
<tr class="separator:a1f8dec5bd2fc486c8d2144b3d7f17943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a4151c0d15bef2c65b5d64a2ec2975"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a83a4151c0d15bef2c65b5d64a2ec2975">operator==</a> (<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5853dc716058231d67db9de2a050a251">indeterminate_t</a>, const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a83a4151c0d15bef2c65b5d64a2ec2975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two tribooleans.  <a href="#a83a4151c0d15bef2c65b5d64a2ec2975">More...</a><br /></td></tr>
<tr class="separator:a83a4151c0d15bef2c65b5d64a2ec2975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894b424c1fe9bf6f27b776ecefd8300f"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a894b424c1fe9bf6f27b776ecefd8300f">operator==</a> (const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;lhs, <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5853dc716058231d67db9de2a050a251">indeterminate_t</a>) noexcept</td></tr>
<tr class="memdesc:a894b424c1fe9bf6f27b776ecefd8300f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two tribooleans.  <a href="#a894b424c1fe9bf6f27b776ecefd8300f">More...</a><br /></td></tr>
<tr class="separator:a894b424c1fe9bf6f27b776ecefd8300f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f719bc2f88ec95bdce7ac3bddaca536"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3f719bc2f88ec95bdce7ac3bddaca536">operator!=</a> (const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;lhs, const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a3f719bc2f88ec95bdce7ac3bddaca536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two tribooleans.  <a href="#a3f719bc2f88ec95bdce7ac3bddaca536">More...</a><br /></td></tr>
<tr class="separator:a3f719bc2f88ec95bdce7ac3bddaca536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8cacd7e1ce32b5e367aba95145f0c87"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#af8cacd7e1ce32b5e367aba95145f0c87">operator!=</a> (<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5853dc716058231d67db9de2a050a251">indeterminate_t</a>, const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:af8cacd7e1ce32b5e367aba95145f0c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two tribooleans.  <a href="#af8cacd7e1ce32b5e367aba95145f0c87">More...</a><br /></td></tr>
<tr class="separator:af8cacd7e1ce32b5e367aba95145f0c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0377caf58e0deaa3a8b13d34c398e3"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aea0377caf58e0deaa3a8b13d34c398e3">operator!=</a> (const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;lhs, <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5853dc716058231d67db9de2a050a251">indeterminate_t</a>) noexcept</td></tr>
<tr class="memdesc:aea0377caf58e0deaa3a8b13d34c398e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two tribooleans.  <a href="#aea0377caf58e0deaa3a8b13d34c398e3">More...</a><br /></td></tr>
<tr class="separator:aea0377caf58e0deaa3a8b13d34c398e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e63ae8d7d9b72fc44d5760c28e3460e"><td class="memItemLeft" align="right" valign="top"><a id="a7e63ae8d7d9b72fc44d5760c28e3460e"></a>
constexpr <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&amp;&amp;</b> (const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;lhs, const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:a7e63ae8d7d9b72fc44d5760c28e3460e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605691fbded7f41dc94ded59772265e8"><td class="memItemLeft" align="right" valign="top"><a id="a605691fbded7f41dc94ded59772265e8"></a>
constexpr <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator||</b> (const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;lhs, const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:a605691fbded7f41dc94ded59772265e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767ceaa1de7727dadc2a6523b37ffa5b"><td class="memTemplParams" colspan="2">template&lt;typename Func , typename Tuple &gt; </td></tr>
<tr class="memitem:a767ceaa1de7727dadc2a6523b37ffa5b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a767ceaa1de7727dadc2a6523b37ffa5b">apply</a> (Func &amp;&amp;function, Tuple &amp;&amp;tuple)</td></tr>
<tr class="memdesc:a767ceaa1de7727dadc2a6523b37ffa5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the Callable object <code>function</code> with a <code>tuple</code> of arguments.  <a href="#a767ceaa1de7727dadc2a6523b37ffa5b">More...</a><br /></td></tr>
<tr class="separator:a767ceaa1de7727dadc2a6523b37ffa5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a49f6f584ffbee6b67c31087a95e03"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tuple &gt; </td></tr>
<tr class="memitem:af9a49f6f584ffbee6b67c31087a95e03"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#af9a49f6f584ffbee6b67c31087a95e03">make_from_tuple</a> (Tuple &amp;&amp;tuple)</td></tr>
<tr class="memdesc:af9a49f6f584ffbee6b67c31087a95e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an object of type  T, using the elements of the tuple t as the arguments to the constructor.  <a href="#af9a49f6f584ffbee6b67c31087a95e03">More...</a><br /></td></tr>
<tr class="separator:af9a49f6f584ffbee6b67c31087a95e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c81704abd3426d4a4f8d644bc9cca9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a29c81704abd3426d4a4f8d644bc9cca9"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a29c81704abd3426d4a4f8d644bc9cca9">uninitialized_default_construct_at</a> (void *ptr)</td></tr>
<tr class="memdesc:a29c81704abd3426d4a4f8d644bc9cca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructs an instance of type <code>T</code> in the given memory.  <a href="#a29c81704abd3426d4a4f8d644bc9cca9">More...</a><br /></td></tr>
<tr class="separator:a29c81704abd3426d4a4f8d644bc9cca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada62bae66a9ed451d9d7078146d9a8b1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada62bae66a9ed451d9d7078146d9a8b1"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ada62bae66a9ed451d9d7078146d9a8b1">uninitialized_copy_at</a> (void *ptr, const T &amp;other)</td></tr>
<tr class="memdesc:ada62bae66a9ed451d9d7078146d9a8b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructs an instance of type <code>T</code> in the given memory.  <a href="#ada62bae66a9ed451d9d7078146d9a8b1">More...</a><br /></td></tr>
<tr class="separator:ada62bae66a9ed451d9d7078146d9a8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc02d5f264a6272ee144f7d279f6cedc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abc02d5f264a6272ee144f7d279f6cedc"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#abc02d5f264a6272ee144f7d279f6cedc">uninitialized_move_at</a> (void *ptr, T &amp;&amp;other)</td></tr>
<tr class="memdesc:abc02d5f264a6272ee144f7d279f6cedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructs an instance of type <code>T</code> in the given memory.  <a href="#abc02d5f264a6272ee144f7d279f6cedc">More...</a><br /></td></tr>
<tr class="separator:abc02d5f264a6272ee144f7d279f6cedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0dcea6d5a9e100bea41a7fdc6ef7d2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a8d0dcea6d5a9e100bea41a7fdc6ef7d2"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a8d0dcea6d5a9e100bea41a7fdc6ef7d2">uninitialized_construct_at</a> (void *ptr, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a8d0dcea6d5a9e100bea41a7fdc6ef7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an instance of type <code>T</code> with the given <code>args</code> at the memory location specified in <code>ptr</code>.  <a href="#a8d0dcea6d5a9e100bea41a7fdc6ef7d2">More...</a><br /></td></tr>
<tr class="separator:a8d0dcea6d5a9e100bea41a7fdc6ef7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c4467d16ff80fbabb5ac8bb35f8975"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tuple &gt; </td></tr>
<tr class="memitem:a24c4467d16ff80fbabb5ac8bb35f8975"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a24c4467d16ff80fbabb5ac8bb35f8975">uninitialized_tuple_construct_at</a> (void *ptr, Tuple &amp;&amp;tuple)</td></tr>
<tr class="memdesc:a24c4467d16ff80fbabb5ac8bb35f8975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an instance of type <code>T</code> with the given <code>tuple</code> at the memory location specified in <code>ptr</code>.  <a href="#a24c4467d16ff80fbabb5ac8bb35f8975">More...</a><br /></td></tr>
<tr class="separator:a24c4467d16ff80fbabb5ac8bb35f8975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ceda0466f45a09b16591ccb2de29ab4"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename... Args&gt; </td></tr>
<tr class="memitem:a5ceda0466f45a09b16591ccb2de29ab4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5ceda0466f45a09b16591ccb2de29ab4">uninitialized_construct</a> (ForwardIterator first, ForwardIterator last, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a5ceda0466f45a09b16591ccb2de29ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an instance of type <code>T</code> with the given <code>args</code> at the memory addresses in the given range [<code>first</code>, <code>last</code> )  <a href="#a5ceda0466f45a09b16591ccb2de29ab4">More...</a><br /></td></tr>
<tr class="separator:a5ceda0466f45a09b16591ccb2de29ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504a3790a931e2137cecd7bc9f53deb2"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Size , typename... Args&gt; </td></tr>
<tr class="memitem:a504a3790a931e2137cecd7bc9f53deb2"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a504a3790a931e2137cecd7bc9f53deb2">uninitialized_construct_n</a> (ForwardIterator first, Size n, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a504a3790a931e2137cecd7bc9f53deb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an instance of type <code>T</code> with the given <code>args</code> at the memory addresses in the given range [<code>first</code>, <code>first</code> + <code>n</code> )  <a href="#a504a3790a931e2137cecd7bc9f53deb2">More...</a><br /></td></tr>
<tr class="separator:a504a3790a931e2137cecd7bc9f53deb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9c14044feb39441c88d133e6f94bf9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d9c14044feb39441c88d133e6f94bf9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a6d9c14044feb39441c88d133e6f94bf9">destroy_at</a> (T *p)</td></tr>
<tr class="memdesc:a6d9c14044feb39441c88d133e6f94bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the destructor of the object pointed to by p, as if by p-&gt;~T().  <a href="#a6d9c14044feb39441c88d133e6f94bf9">More...</a><br /></td></tr>
<tr class="separator:a6d9c14044feb39441c88d133e6f94bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1691dc7bcc77311536263be8d1273d7b"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a1691dc7bcc77311536263be8d1273d7b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a1691dc7bcc77311536263be8d1273d7b">destroy</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="memdesc:a1691dc7bcc77311536263be8d1273d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the objects in the range <code></code>[first, <code>last</code>)  <a href="#a1691dc7bcc77311536263be8d1273d7b">More...</a><br /></td></tr>
<tr class="separator:a1691dc7bcc77311536263be8d1273d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bf67710219534b12e99dec573c4802"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a63bf67710219534b12e99dec573c4802"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a63bf67710219534b12e99dec573c4802">destroy_n</a> (ForwardIterator first, std::size_t n)</td></tr>
<tr class="memdesc:a63bf67710219534b12e99dec573c4802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the <code>n</code> objects in the range starting at <code>first</code>.  <a href="#a63bf67710219534b12e99dec573c4802">More...</a><br /></td></tr>
<tr class="separator:a63bf67710219534b12e99dec573c4802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf862f7facbc4267ce240a9167ce3dfa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acf862f7facbc4267ce240a9167ce3dfa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#acf862f7facbc4267ce240a9167ce3dfa">destroy_array_at</a> (T *ptr)</td></tr>
<tr class="memdesc:acf862f7facbc4267ce240a9167ce3dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an array of entries at the given <code>ptr</code>.  <a href="#acf862f7facbc4267ce240a9167ce3dfa">More...</a><br /></td></tr>
<tr class="separator:acf862f7facbc4267ce240a9167ce3dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fb1c369e77d674a654bb943210c7b0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a20fb1c369e77d674a654bb943210c7b0"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a20fb1c369e77d674a654bb943210c7b0">fwd</a> (T &amp;&amp;x) noexcept</td></tr>
<tr class="memdesc:a20fb1c369e77d674a654bb943210c7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around std::forward that removes the need for specifying the type T.  <a href="#a20fb1c369e77d674a654bb943210c7b0">More...</a><br /></td></tr>
<tr class="separator:a20fb1c369e77d674a654bb943210c7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994018402d561913cfd756806468244a"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a994018402d561913cfd756806468244a"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a994018402d561913cfd756806468244a">at</a> (T(&amp;array)[N], std::size_t n)</td></tr>
<tr class="memdesc:a994018402d561913cfd756806468244a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely retrieves the value at the given index, otherwise asserts.  <a href="#a994018402d561913cfd756806468244a">More...</a><br /></td></tr>
<tr class="separator:a994018402d561913cfd756806468244a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace51dc6914690cfdbde3caf2c7f66105"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Key &gt; </td></tr>
<tr class="memitem:ace51dc6914690cfdbde3caf2c7f66105"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ace51dc6914690cfdbde3caf2c7f66105">at</a> (Container &amp;container, Key &amp;&amp;key)</td></tr>
<tr class="memdesc:ace51dc6914690cfdbde3caf2c7f66105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely retrieves the value at the given index, otherwise asserts.  <a href="#ace51dc6914690cfdbde3caf2c7f66105">More...</a><br /></td></tr>
<tr class="separator:ace51dc6914690cfdbde3caf2c7f66105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd395f73ba3488ce123b405e80b43eee"><td class="memTemplParams" colspan="2">template&lt;typename F , typename Tuple &gt; </td></tr>
<tr class="memitem:abd395f73ba3488ce123b405e80b43eee"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#abd395f73ba3488ce123b405e80b43eee">apply</a> (F &amp;&amp;f, Tuple &amp;&amp;t)</td></tr>
<tr class="memdesc:abd395f73ba3488ce123b405e80b43eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the Callable object f with a tuple of arguments.  <a href="#abd395f73ba3488ce123b405e80b43eee">More...</a><br /></td></tr>
<tr class="separator:abd395f73ba3488ce123b405e80b43eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44765e2cf31239152e2374bc6684ff6"><td class="memTemplParams" colspan="2">template&lt;typename Container , underlying_container_type_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac44765e2cf31239152e2374bc6684ff6"><td class="memTemplItemLeft" align="right" valign="top">underlying_container_type_t&lt; Container &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ac44765e2cf31239152e2374bc6684ff6">get_underlying_container</a> (Container &amp;container)</td></tr>
<tr class="memdesc:ac44765e2cf31239152e2374bc6684ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying container of a given container adapter.  <a href="#ac44765e2cf31239152e2374bc6684ff6">More...</a><br /></td></tr>
<tr class="separator:ac44765e2cf31239152e2374bc6684ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab993070150ba659591029ded08c97ab4"><td class="memItemLeft" align="right" valign="top"><a id="ab993070150ba659591029ded08c97ab4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a> &amp;lhs, const <a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:ab993070150ba659591029ded08c97ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db25858f4dacf51429ed979f4d63f8d"><td class="memItemLeft" align="right" valign="top"><a id="a6db25858f4dacf51429ed979f4d63f8d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a> &amp;lhs, const <a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:a6db25858f4dacf51429ed979f4d63f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6818223213d20420bf5c6f867e5130ca"><td class="memItemLeft" align="right" valign="top"><a id="a6818223213d20420bf5c6f867e5130ca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a> &amp;lhs, const <a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:a6818223213d20420bf5c6f867e5130ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062a995a56331341fe185a89df3f2f19"><td class="memItemLeft" align="right" valign="top"><a id="a062a995a56331341fe185a89df3f2f19"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a> &amp;lhs, const <a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:a062a995a56331341fe185a89df3f2f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962c5fecd9a1db1794835196db28a0b2"><td class="memItemLeft" align="right" valign="top"><a id="a962c5fecd9a1db1794835196db28a0b2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a> &amp;lhs, const <a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:a962c5fecd9a1db1794835196db28a0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693bfc84a9be219c1b0f18478b3cce1e"><td class="memItemLeft" align="right" valign="top"><a id="a693bfc84a9be219c1b0f18478b3cce1e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a> &amp;lhs, const <a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:a693bfc84a9be219c1b0f18478b3cce1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a74872a5b5134f3972927a78e69b5c8c7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a74872a5b5134f3972927a78e69b5c8c7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a74872a5b5134f3972927a78e69b5c8c7">deep_compare</a> (const T &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a74872a5b5134f3972927a78e69b5c8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep comparison of two pointer-like objects.  <a href="#a74872a5b5134f3972927a78e69b5c8c7">More...</a><br /></td></tr>
<tr class="separator:a74872a5b5134f3972927a78e69b5c8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b012db31ce10640055ff0c1bcc8baf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a61b012db31ce10640055ff0c1bcc8baf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a61b012db31ce10640055ff0c1bcc8baf">deep_compare</a> (std::nullptr_t, const T &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a61b012db31ce10640055ff0c1bcc8baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep comparison of two pointer-like objects.  <a href="#a61b012db31ce10640055ff0c1bcc8baf">More...</a><br /></td></tr>
<tr class="separator:a61b012db31ce10640055ff0c1bcc8baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f080cd59b223c721bb87836df95e0b9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f080cd59b223c721bb87836df95e0b9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a4f080cd59b223c721bb87836df95e0b9">deep_compare</a> (const T &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:a4f080cd59b223c721bb87836df95e0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep comparison of two pointer-like objects.  <a href="#a4f080cd59b223c721bb87836df95e0b9">More...</a><br /></td></tr>
<tr class="separator:a4f080cd59b223c721bb87836df95e0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef190c6b43facf566fc7bf0ccf2b5d2"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3ef190c6b43facf566fc7bf0ccf2b5d2">deep_compare</a> (std::nullptr_t, std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:a3ef190c6b43facf566fc7bf0ccf2b5d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep comparison of two pointer-like objects.  <a href="#a3ef190c6b43facf566fc7bf0ccf2b5d2">More...</a><br /></td></tr>
<tr class="separator:a3ef190c6b43facf566fc7bf0ccf2b5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2ecff478de92d62272d16166405cc0c9"><td class="memItemLeft" align="right" valign="top"><a id="a2ecff478de92d62272d16166405cc0c9"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a2ecff478de92d62272d16166405cc0c9">dynamic_extent</a> = std::ptrdiff_t{-1}</td></tr>
<tr class="memdesc:a2ecff478de92d62272d16166405cc0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to represent dynamic-extents. <br /></td></tr>
<tr class="separator:a2ecff478de92d62272d16166405cc0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada43fd75f18beefb9ea467bf2cad47d4"><td class="memTemplParams" colspan="2">template&lt;bool B&gt; </td></tr>
<tr class="memitem:ada43fd75f18beefb9ea467bf2cad47d4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ada43fd75f18beefb9ea467bf2cad47d4">bool_constant_v</a> = <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ab55b248051d5393fe10e6ffe1f7b2143">bool_constant</a>&lt;B&gt;::value</td></tr>
<tr class="memdesc:ada43fd75f18beefb9ea467bf2cad47d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience template variable to extract bool_constant::value.  <a href="#ada43fd75f18beefb9ea467bf2cad47d4">More...</a><br /></td></tr>
<tr class="separator:ada43fd75f18beefb9ea467bf2cad47d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb60d483f5de2ef973c2ff71ed3c2942"><td class="memTemplParams" colspan="2"><a id="adb60d483f5de2ef973c2ff71ed3c2942"></a>
template&lt;template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:adb60d483f5de2ef973c2ff71ed3c2942"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_detected_v</b> = is_detected&lt;Op, Args...&gt;::value</td></tr>
<tr class="separator:adb60d483f5de2ef973c2ff71ed3c2942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ac9e86413353207e62e5d3b9e7d14f"><td class="memTemplParams" colspan="2"><a id="a29ac9e86413353207e62e5d3b9e7d14f"></a>
template&lt;typename Expected , template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:a29ac9e86413353207e62e5d3b9e7d14f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_detected_exact_v</b> = is_detected_exact&lt;Expected, Op, Args...&gt;::value</td></tr>
<tr class="separator:a29ac9e86413353207e62e5d3b9e7d14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7730672047317259e0c71c08d274edb4"><td class="memTemplParams" colspan="2"><a id="a7730672047317259e0c71c08d274edb4"></a>
template&lt;typename To , template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:a7730672047317259e0c71c08d274edb4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_detected_convertible_v</b> = is_detected_convertible&lt;To, Op, Args...&gt;::value</td></tr>
<tr class="separator:a7730672047317259e0c71c08d274edb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54946837a8f3d43949c8bf99e780805c"><td class="memTemplParams" colspan="2"><a id="a54946837a8f3d43949c8bf99e780805c"></a>
template&lt;typename T , T V&gt; </td></tr>
<tr class="memitem:a54946837a8f3d43949c8bf99e780805c"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>integral_constant_v</b> = integral_constant&lt;T,V&gt;::value</td></tr>
<tr class="separator:a54946837a8f3d43949c8bf99e780805c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885977edf1cfbccd5de4978c99432da4"><td class="memTemplParams" colspan="2">template&lt;std::size_t Size&gt; </td></tr>
<tr class="memitem:a885977edf1cfbccd5de4978c99432da4"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a885977edf1cfbccd5de4978c99432da4">size_constant_v</a> = <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a618d89ada20b451c43bf19ab9580409e">size_constant</a>&lt;Size&gt;::value</td></tr>
<tr class="memdesc:a885977edf1cfbccd5de4978c99432da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience template variable to extract size_constant::value.  <a href="#a885977edf1cfbccd5de4978c99432da4">More...</a><br /></td></tr>
<tr class="separator:a885977edf1cfbccd5de4978c99432da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6763f85df51ea81226ea0816fb00bc"><td class="memTemplParams" colspan="2"><a id="a0d6763f85df51ea81226ea0816fb00bc"></a>
template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a0d6763f85df51ea81226ea0816fb00bc"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a0d6763f85df51ea81226ea0816fb00bc">arity_v</a> = <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d4/daf/structbit_1_1stl_1_1arity">arity</a>&lt;Fn&gt;::value</td></tr>
<tr class="memdesc:a0d6763f85df51ea81226ea0816fb00bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract arity::value. <br /></td></tr>
<tr class="separator:a0d6763f85df51ea81226ea0816fb00bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04679ea87568edfe8d59c4c65840824"><td class="memTemplParams" colspan="2"><a id="ab04679ea87568edfe8d59c4c65840824"></a>
template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:ab04679ea87568edfe8d59c4c65840824"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ab04679ea87568edfe8d59c4c65840824">index_of_type_v</a> = <a class="el" href="../../d0/dd0/structbit_1_1stl_1_1index__of__type.html">index_of_type</a>&lt;T,Types...&gt;::value</td></tr>
<tr class="memdesc:ab04679ea87568edfe8d59c4c65840824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract index_of_type::value. <br /></td></tr>
<tr class="separator:ab04679ea87568edfe8d59c4c65840824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc652e5e49f4ee85f3627f39b57571a0"><td class="memTemplParams" colspan="2"><a id="abc652e5e49f4ee85f3627f39b57571a0"></a>
template&lt;typename Func &gt; </td></tr>
<tr class="memitem:abc652e5e49f4ee85f3627f39b57571a0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#abc652e5e49f4ee85f3627f39b57571a0">is_const_member_function_pointer_v</a> = <a class="el" href="../../dc/d7e/structbit_1_1stl_1_1is__const__member__function__pointer.html">is_const_member_function_pointer</a>&lt;Func&gt;::value</td></tr>
<tr class="memdesc:abc652e5e49f4ee85f3627f39b57571a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_const_member_function_pointer::type. <br /></td></tr>
<tr class="separator:abc652e5e49f4ee85f3627f39b57571a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ecb52f67ed35fc56ab2b13c9642e6b"><td class="memTemplParams" colspan="2"><a id="a92ecb52f67ed35fc56ab2b13c9642e6b"></a>
template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a92ecb52f67ed35fc56ab2b13c9642e6b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a92ecb52f67ed35fc56ab2b13c9642e6b">is_cv_member_function_poiner_v</a> = <a class="el" href="../../dd/d1d/structbit_1_1stl_1_1is__cv__member__function__pointer.html">is_cv_member_function_pointer</a>&lt;Func&gt;::value</td></tr>
<tr class="memdesc:a92ecb52f67ed35fc56ab2b13c9642e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_cv_member_function_pointer::type. <br /></td></tr>
<tr class="separator:a92ecb52f67ed35fc56ab2b13c9642e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea6f7d97f3513e0de1d9d1d50cd842c"><td class="memTemplParams" colspan="2"><a id="a5ea6f7d97f3513e0de1d9d1d50cd842c"></a>
template&lt;typename From , typename To &gt; </td></tr>
<tr class="memitem:a5ea6f7d97f3513e0de1d9d1d50cd842c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5ea6f7d97f3513e0de1d9d1d50cd842c">is_explicitly_convertible_v</a> = <a class="el" href="../../d6/d38/structbit_1_1stl_1_1is__explicitly__convertible.html">is_explicitly_convertible</a>&lt;From,To&gt;::value</td></tr>
<tr class="memdesc:a5ea6f7d97f3513e0de1d9d1d50cd842c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract nth_type::type. <br /></td></tr>
<tr class="separator:a5ea6f7d97f3513e0de1d9d1d50cd842c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8b3d92c32e8c716376a63b57d5ef97"><td class="memTemplParams" colspan="2"><a id="a2b8b3d92c32e8c716376a63b57d5ef97"></a>
template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a2b8b3d92c32e8c716376a63b57d5ef97"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a2b8b3d92c32e8c716376a63b57d5ef97">is_volatile_member_function_pointer_v</a> = <a class="el" href="../../d9/d0a/structbit_1_1stl_1_1is__volatile__member__function__pointer.html">is_volatile_member_function_pointer</a>&lt;Func&gt;::value</td></tr>
<tr class="memdesc:a2b8b3d92c32e8c716376a63b57d5ef97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_volatile_member_function_pointer::type. <br /></td></tr>
<tr class="separator:a2b8b3d92c32e8c716376a63b57d5ef97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85faae2ba5eb5b5358802a5287e6d85"><td class="memTemplParams" colspan="2"><a id="ac85faae2ba5eb5b5358802a5287e6d85"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac85faae2ba5eb5b5358802a5287e6d85"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ac85faae2ba5eb5b5358802a5287e6d85">pointer_rank_v</a> = <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a793ba48cdec0344ad6a9dcc1792407dc">pointer_rank</a>&lt; std::decay_t&lt;T&gt; &gt;::value</td></tr>
<tr class="memdesc:ac85faae2ba5eb5b5358802a5287e6d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract pointer_rank::value. <br /></td></tr>
<tr class="separator:ac85faae2ba5eb5b5358802a5287e6d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90406b02a0de439645a1e41cfd35430c"><td class="memTemplParams" colspan="2"><a id="a90406b02a0de439645a1e41cfd35430c"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a90406b02a0de439645a1e41cfd35430c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a90406b02a0de439645a1e41cfd35430c">are_same_v</a> = <a class="el" href="../../dd/df3/structbit_1_1stl_1_1are__same.html">are_same</a>&lt;T,Ts...&gt;::value</td></tr>
<tr class="memdesc:a90406b02a0de439645a1e41cfd35430c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract are_same::value. <br /></td></tr>
<tr class="separator:a90406b02a0de439645a1e41cfd35430c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2df763a96d761e8d85a0c1ac3465a8"><td class="memTemplParams" colspan="2"><a id="acf2df763a96d761e8d85a0c1ac3465a8"></a>
template&lt;typename Base , typename... Derived&gt; </td></tr>
<tr class="memitem:acf2df763a96d761e8d85a0c1ac3465a8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#acf2df763a96d761e8d85a0c1ac3465a8">is_base_of_all_v</a> = <a class="el" href="../../d1/dfd/structbit_1_1stl_1_1is__base__of__all.html">is_base_of_all</a>&lt;Base,Derived...&gt;::value</td></tr>
<tr class="memdesc:acf2df763a96d761e8d85a0c1ac3465a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_base_of_all::value. <br /></td></tr>
<tr class="separator:acf2df763a96d761e8d85a0c1ac3465a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0caaffe9669b40a1021af97934b9df"><td class="memTemplParams" colspan="2"><a id="a5c0caaffe9669b40a1021af97934b9df"></a>
template&lt;typename Base , typename... Derived&gt; </td></tr>
<tr class="memitem:a5c0caaffe9669b40a1021af97934b9df"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5c0caaffe9669b40a1021af97934b9df">is_base_of_any_v</a> = <a class="el" href="../../dc/d99/structbit_1_1stl_1_1is__base__of__any.html">is_base_of_any</a>&lt;Base,Derived...&gt;::value</td></tr>
<tr class="memdesc:a5c0caaffe9669b40a1021af97934b9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_base_of_any::value. <br /></td></tr>
<tr class="separator:a5c0caaffe9669b40a1021af97934b9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e05940792616a76e15fcaafb984d17"><td class="memTemplParams" colspan="2"><a id="a45e05940792616a76e15fcaafb984d17"></a>
template&lt;typename Derived , typename... Bases&gt; </td></tr>
<tr class="memitem:a45e05940792616a76e15fcaafb984d17"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a45e05940792616a76e15fcaafb984d17">is_derived_from_all_v</a> = <a class="el" href="../../d8/d5f/structbit_1_1stl_1_1is__derived__from__all.html">is_derived_from_all</a>&lt;Derived,Bases...&gt;::value</td></tr>
<tr class="memdesc:a45e05940792616a76e15fcaafb984d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_derived_from_all::value. <br /></td></tr>
<tr class="separator:a45e05940792616a76e15fcaafb984d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0eb62ccdd58857e9bc0eeef1460092a"><td class="memTemplParams" colspan="2"><a id="ab0eb62ccdd58857e9bc0eeef1460092a"></a>
template&lt;typename Derived , typename... Bases&gt; </td></tr>
<tr class="memitem:ab0eb62ccdd58857e9bc0eeef1460092a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ab0eb62ccdd58857e9bc0eeef1460092a">is_derived_from_any_v</a> = <a class="el" href="../../da/dad/structbit_1_1stl_1_1is__derived__from__any.html">is_derived_from_any</a>&lt;Derived,Bases...&gt;::value</td></tr>
<tr class="memdesc:ab0eb62ccdd58857e9bc0eeef1460092a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_derived_from_any::value. <br /></td></tr>
<tr class="separator:ab0eb62ccdd58857e9bc0eeef1460092a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5ed3976d1d9626f265b4a4fdcd2251"><td class="memTemplParams" colspan="2"><a id="a5c5ed3976d1d9626f265b4a4fdcd2251"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a5c5ed3976d1d9626f265b4a4fdcd2251"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5c5ed3976d1d9626f265b4a4fdcd2251">is_one_of_v</a> = <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d3/dcc/structbit_1_1stl_1_1is__one__of">is_one_of</a>&lt;T,Ts...&gt;::value</td></tr>
<tr class="memdesc:a5c5ed3976d1d9626f265b4a4fdcd2251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_one_of::value. <br /></td></tr>
<tr class="separator:a5c5ed3976d1d9626f265b4a4fdcd2251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c193d07bf6aef24e0dcd6132dbcd517"><td class="memTemplParams" colspan="2"><a id="a2c193d07bf6aef24e0dcd6132dbcd517"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a2c193d07bf6aef24e0dcd6132dbcd517"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a2c193d07bf6aef24e0dcd6132dbcd517">is_same_constness_v</a> = <a class="el" href="../../d3/d80/structbit_1_1stl_1_1is__same__constness.html">is_same_constness</a>&lt;T,U&gt;::value</td></tr>
<tr class="memdesc:a2c193d07bf6aef24e0dcd6132dbcd517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_same_constness::value. <br /></td></tr>
<tr class="separator:a2c193d07bf6aef24e0dcd6132dbcd517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d6ab37b20d89ee7e4a61442001461e"><td class="memTemplParams" colspan="2"><a id="a58d6ab37b20d89ee7e4a61442001461e"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a58d6ab37b20d89ee7e4a61442001461e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a58d6ab37b20d89ee7e4a61442001461e">is_same_cv_v</a> = <a class="el" href="../../db/d22/structbit_1_1stl_1_1is__same__cv.html">is_same_cv</a>&lt;T,U&gt;::value</td></tr>
<tr class="memdesc:a58d6ab37b20d89ee7e4a61442001461e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_same_cv::value. <br /></td></tr>
<tr class="separator:a58d6ab37b20d89ee7e4a61442001461e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0781e56d3d1f7cec419ee3caf5dafeac"><td class="memTemplParams" colspan="2"><a id="a0781e56d3d1f7cec419ee3caf5dafeac"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a0781e56d3d1f7cec419ee3caf5dafeac"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a0781e56d3d1f7cec419ee3caf5dafeac">is_same_decay_v</a> = <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ada876145f89a8518848ed41709737585">is_same_decay</a>&lt;T,U&gt;::value</td></tr>
<tr class="memdesc:a0781e56d3d1f7cec419ee3caf5dafeac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_same_decay::value. <br /></td></tr>
<tr class="separator:a0781e56d3d1f7cec419ee3caf5dafeac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5d645b3400613ff7cd00ce34ab6e33"><td class="memTemplParams" colspan="2"><a id="aad5d645b3400613ff7cd00ce34ab6e33"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aad5d645b3400613ff7cd00ce34ab6e33"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aad5d645b3400613ff7cd00ce34ab6e33">is_same_sign_v</a> = <a class="el" href="../../d0/dee/structbit_1_1stl_1_1is__same__sign.html">is_same_sign</a>&lt;T,U&gt;::value</td></tr>
<tr class="memdesc:aad5d645b3400613ff7cd00ce34ab6e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_same_sign::value. <br /></td></tr>
<tr class="separator:aad5d645b3400613ff7cd00ce34ab6e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ba5c45b5abcffb116e0f52d201e893"><td class="memTemplParams" colspan="2"><a id="a50ba5c45b5abcffb116e0f52d201e893"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a50ba5c45b5abcffb116e0f52d201e893"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a50ba5c45b5abcffb116e0f52d201e893">is_same_volatility_v</a> = <a class="el" href="../../d9/db3/structbit_1_1stl_1_1is__same__volatility.html">is_same_volatility</a>&lt;T,U&gt;::value</td></tr>
<tr class="memdesc:a50ba5c45b5abcffb116e0f52d201e893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract is_same_volatility::value. <br /></td></tr>
<tr class="separator:a50ba5c45b5abcffb116e0f52d201e893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13220ba864e3fbc0b10964fa5f405f98"><td class="memTemplParams" colspan="2"><a id="a13220ba864e3fbc0b10964fa5f405f98"></a>
template&lt;typename T , typename... Types&gt; </td></tr>
<tr class="memitem:a13220ba864e3fbc0b10964fa5f405f98"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a13220ba864e3fbc0b10964fa5f405f98">resolves_overload_index_v</a> = <a class="el" href="../../dd/d33/structbit_1_1stl_1_1resolves__overload__index.html">resolves_overload_index</a>&lt;T,Types...&gt;::value</td></tr>
<tr class="memdesc:a13220ba864e3fbc0b10964fa5f405f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to extract resolves_overload_index::value. <br /></td></tr>
<tr class="separator:a13220ba864e3fbc0b10964fa5f405f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae20fa40af1b1ee83eddbcf4c90946b7"><td class="memItemLeft" align="right" valign="top"><a id="aae20fa40af1b1ee83eddbcf4c90946b7"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>max_align</b> = alignof(std::max_align_t)</td></tr>
<tr class="separator:aae20fa40af1b1ee83eddbcf4c90946b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3d8b99488f5c47539d0890e79b210e"><td class="memItemLeft" align="right" valign="top"><a id="a8a3d8b99488f5c47539d0890e79b210e"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>dynamic_index</b> = std::numeric_limits&lt;std::ptrdiff_t&gt;::min()</td></tr>
<tr class="separator:a8a3d8b99488f5c47539d0890e79b210e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cebfe59d835474a15593dd8c236a430"><td class="memItemLeft" align="right" valign="top"><a id="a9cebfe59d835474a15593dd8c236a430"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>dynamic_size</b> = std::size_t(-1)</td></tr>
<tr class="separator:a9cebfe59d835474a15593dd8c236a430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6456b8c7fd284a2b02b25d06db3d7cce"><td class="memItemLeft" align="right" valign="top"><a id="a6456b8c7fd284a2b02b25d06db3d7cce"></a>
constexpr <a class="el" href="../../d1/d19/structbit_1_1stl_1_1unexpect__t.html">unexpect_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>unexpect</b> {1}</td></tr>
<tr class="separator:a6456b8c7fd284a2b02b25d06db3d7cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55533d9967a3edda8f1d774b4b567d41"><td class="memItemLeft" align="right" valign="top"><a id="a55533d9967a3edda8f1d774b4b567d41"></a>
constexpr <a class="el" href="../../d2/d6c/structbit_1_1stl_1_1in__place__t.html">in_place_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>in_place</b> {}</td></tr>
<tr class="separator:a55533d9967a3edda8f1d774b4b567d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc1201f124324ba1e52705e5fcdca39"><td class="memTemplParams" colspan="2"><a id="a5cc1201f124324ba1e52705e5fcdca39"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5cc1201f124324ba1e52705e5fcdca39"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d6/d31/structbit_1_1stl_1_1in__place__type__t.html">in_place_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>in_place_type</b> {}</td></tr>
<tr class="separator:a5cc1201f124324ba1e52705e5fcdca39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbdccdc5b3afb7f3ef707953598792e6"><td class="memTemplParams" colspan="2"><a id="afbdccdc5b3afb7f3ef707953598792e6"></a>
template&lt;std::size_t I&gt; </td></tr>
<tr class="memitem:afbdccdc5b3afb7f3ef707953598792e6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../dc/d17/structbit_1_1stl_1_1in__place__index__t.html">in_place_index_t</a>&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>in_place_index</b> {}</td></tr>
<tr class="separator:afbdccdc5b3afb7f3ef707953598792e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156d311abc0ddbfe589e2245538f5d96"><td class="memTemplParams" colspan="2"><a id="a156d311abc0ddbfe589e2245538f5d96"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a156d311abc0ddbfe589e2245538f5d96"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_in_place_v</b> = <a class="el" href="../../d9/dd8/structbit_1_1stl_1_1is__in__place.html">is_in_place</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a156d311abc0ddbfe589e2245538f5d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6458c4a0d39f8ba5f1bb90348a1463"><td class="memTemplParams" colspan="2"><a id="abe6458c4a0d39f8ba5f1bb90348a1463"></a>
template&lt;typename Fn , typename... Args&gt; </td></tr>
<tr class="memitem:abe6458c4a0d39f8ba5f1bb90348a1463"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#abe6458c4a0d39f8ba5f1bb90348a1463">is_invocable_v</a> = <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a120d4f65c646a277af6fd9c51ad78381">is_invocable</a>&lt;Fn,Args...&gt;::value</td></tr>
<tr class="memdesc:abe6458c4a0d39f8ba5f1bb90348a1463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait helper to retrieve the <code>::value</code> of is_invokable. <br /></td></tr>
<tr class="separator:abe6458c4a0d39f8ba5f1bb90348a1463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8c22cdfb1a3783140d8c28061baeff"><td class="memTemplParams" colspan="2"><a id="acb8c22cdfb1a3783140d8c28061baeff"></a>
template&lt;typename Fn , typename... Args&gt; </td></tr>
<tr class="memitem:acb8c22cdfb1a3783140d8c28061baeff"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#acb8c22cdfb1a3783140d8c28061baeff">is_nothrow_invocable_v</a> = <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a7f47ee038bc1d9539fe2f38cbc00915e">is_nothrow_invocable</a>&lt;Fn,Args...&gt;::value</td></tr>
<tr class="memdesc:acb8c22cdfb1a3783140d8c28061baeff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait helper to retrieve the <code>::value</code> of is_nothrow_invokable. <br /></td></tr>
<tr class="separator:acb8c22cdfb1a3783140d8c28061baeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322ace5ea4e3242457cfc64f6bf00717"><td class="memItemLeft" align="right" valign="top"><a id="a322ace5ea4e3242457cfc64f6bf00717"></a>
constexpr <a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a322ace5ea4e3242457cfc64f6bf00717">nullopt</a> = <a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>(0)</td></tr>
<tr class="memdesc:a322ace5ea4e3242457cfc64f6bf00717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instance of a nullopt type. <br /></td></tr>
<tr class="separator:a322ace5ea4e3242457cfc64f6bf00717"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The standard namespace for this project. </p>
<p>Every class, free function, and sub-namespace will be defined inside of this namespace. </p>
</div><hr/><h2 class="groupheader">Class Documentation</h2>
<a name="d2/d55/structbit_1_1stl_1_1aligned__storage" id="d2/d55/structbit_1_1stl_1_1aligned__storage"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d2/d55/structbit_1_1stl_1_1aligned__storage">&#9670;&nbsp;</a></span>bit::stl::aligned_storage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::stl::aligned_storage</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;std::size_t Len, std::size_t Align = max_align&gt;<br />
struct bit::stl::aligned_storage&lt; Len, Align &gt;</h3>

<p>Provides the nested type type, which is a PODType suitable for use as uninitialized storage for any object whose size is at most Len and whose alignment requirement is a divisor of Align. </p>
<p>The default value of Align is the most stringent (the largest) alignment requirement for any object whose size is at most Len. If the default value is not used, Align must be the value of alignof(T) for some type T, or the behavior is undefined.</p>
<p>The behavior is undefined if Len == 0.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Len</td><td>the length of the storage </td></tr>
    <tr><td class="paramname">Align</td><td>the alignment of the storage </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d7/de5/aligned__storage_8hpp_source.html#l00048">48</a> of file <a class="el" href="../../d7/de5/aligned__storage_8hpp_source.html">aligned_storage.hpp</a>.</p>
</div>
</div>
</div>
<a name="d4/daf/structbit_1_1stl_1_1arity" id="d4/daf/structbit_1_1stl_1_1arity"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d4/daf/structbit_1_1stl_1_1arity">&#9670;&nbsp;</a></span>bit::stl::arity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::stl::arity</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Fn&gt;<br />
struct bit::stl::arity&lt; Fn &gt;</h3>

<p>Type-trait to determine the arity of a function. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d9/d8e/arity_8hpp_source.html#l00023">23</a> of file <a class="el" href="../../d9/d8e/arity_8hpp_source.html">arity.hpp</a>.</p>
</div>
</div>
</div>
<a name="d8/d1f/structbit_1_1stl_1_1conjunction" id="d8/d1f/structbit_1_1stl_1_1conjunction"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d8/d1f/structbit_1_1stl_1_1conjunction">&#9670;&nbsp;</a></span>bit::stl::conjunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::stl::conjunction</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename...&gt;<br />
struct bit::stl::conjunction&lt;... &gt;</h3>

<p>Type trait to determine the bool_constant from a logical AND operation of other bool_constants. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../df/d80/conjunction_8hpp_source.html#l00023">23</a> of file <a class="el" href="../../df/d80/conjunction_8hpp_source.html">conjunction.hpp</a>.</p>
</div>
</div>
</div>
<a name="d6/d7e/classbit_1_1stl_1_1delegate" id="d6/d7e/classbit_1_1stl_1_1delegate"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d6/d7e/classbit_1_1stl_1_1delegate">&#9670;&nbsp;</a></span>bit::stl::delegate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class bit::stl::delegate</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Fn&gt;<br />
class bit::stl::delegate&lt; Fn &gt;</h3>

<p>This class is for a lightweight way of managing function callbacks without requiring heap allocations. </p>
<p>The syntax is a little off as a result, requiring a call to Delegate::bind.</p>
<p>Example </p><div class="fragment"><div class="line">Delegate&lt;void()&gt; delegate;</div><div class="line">T       t;</div><div class="line"><span class="keyword">const</span> T ct;</div><div class="line"></div><div class="line">delegate.bind&lt;&amp;foo&gt;();           <span class="comment">// bind free function</span></div><div class="line">delegate.bind&lt;T,&amp;T::foo&gt;( &amp;t );  <span class="comment">// bind member functions</span></div><div class="line">delegate.bind&lt;T,&amp;T::foo&gt;( &amp;ct ); <span class="comment">// bind const member function</span></div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>signature and return type </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d0/d68/delegate_8hpp_source.html#l00041">41</a> of file <a class="el" href="../../d0/d68/delegate_8hpp_source.html">delegate.hpp</a>.</p>
</div>
</div>
</div>
<a name="da/d3e/structbit_1_1stl_1_1disable__if_3_01true_00_01_t_01_4" id="da/d3e/structbit_1_1stl_1_1disable__if_3_01true_00_01_t_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#da/d3e/structbit_1_1stl_1_1disable__if_3_01true_00_01_t_01_4">&#9670;&nbsp;</a></span>bit::stl::disable_if< true, T ></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::stl::disable_if&lt; true, T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct bit::stl::disable_if&lt; true, T &gt;</h3>


<p class="definition">Definition at line <a class="el" href="../../d5/da8/sfinae_8hpp_source.html#l00046">46</a> of file <a class="el" href="../../d5/da8/sfinae_8hpp_source.html">sfinae.hpp</a>.</p>
</div>
</div>
</div>
<a name="db/d9b/structbit_1_1stl_1_1empty" id="db/d9b/structbit_1_1stl_1_1empty"></a>
<h2 class="memtitle"><span class="permalink"><a href="#db/d9b/structbit_1_1stl_1_1empty">&#9670;&nbsp;</a></span>bit::stl::empty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::stl::empty</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct bit::stl::empty&lt; T &gt;</h3>

<p>Utility metafunction that always expands into an empty struct with no members or type members. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/da4/empty_8hpp_source.html#l00017">17</a> of file <a class="el" href="../../d8/da4/empty_8hpp_source.html">empty.hpp</a>.</p>
</div>
</div>
</div>
<a name="d1/d68/structbit_1_1stl_1_1enable__if_3_01false_00_01_t_01_4" id="d1/d68/structbit_1_1stl_1_1enable__if_3_01false_00_01_t_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d1/d68/structbit_1_1stl_1_1enable__if_3_01false_00_01_t_01_4">&#9670;&nbsp;</a></span>bit::stl::enable_if< false, T ></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::stl::enable_if&lt; false, T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct bit::stl::enable_if&lt; false, T &gt;</h3>


<p class="definition">Definition at line <a class="el" href="../../d5/da8/sfinae_8hpp_source.html#l00035">35</a> of file <a class="el" href="../../d5/da8/sfinae_8hpp_source.html">sfinae.hpp</a>.</p>
</div>
</div>
</div>
<a name="d8/ddd/structbit_1_1stl_1_1enable__overload__if_3_01false_00_01_t_01_4" id="d8/ddd/structbit_1_1stl_1_1enable__overload__if_3_01false_00_01_t_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d8/ddd/structbit_1_1stl_1_1enable__overload__if_3_01false_00_01_t_01_4">&#9670;&nbsp;</a></span>bit::stl::enable_overload_if< false, T ></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::stl::enable_overload_if&lt; false, T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct bit::stl::enable_overload_if&lt; false, T &gt;</h3>


<p class="definition">Definition at line <a class="el" href="../../d5/da8/sfinae_8hpp_source.html#l00064">64</a> of file <a class="el" href="../../d5/da8/sfinae_8hpp_source.html">sfinae.hpp</a>.</p>
</div>
</div>
</div>
<a name="d2/db4/structbit_1_1stl_1_1function__argument" id="d2/db4/structbit_1_1stl_1_1function__argument"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d2/db4/structbit_1_1stl_1_1function__argument">&#9670;&nbsp;</a></span>bit::stl::function_argument</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::stl::function_argument</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;std::size_t I, typename Fn&gt;<br />
struct bit::stl::function_argument&lt; I, Fn &gt;</h3>

<p>Type-trait to access the <code>Ith</code> argument type of a given function. </p>
<p>The result is aliased as <code>::type</code> </p>

<p class="definition">Definition at line <a class="el" href="../../de/d3a/function__argument_8hpp_source.html#l00024">24</a> of file <a class="el" href="../../de/d3a/function__argument_8hpp_source.html">function_argument.hpp</a>.</p>
</div>
</div>
</div>
<a name="df/d77/structbit_1_1stl_1_1function__signature" id="df/d77/structbit_1_1stl_1_1function__signature"></a>
<h2 class="memtitle"><span class="permalink"><a href="#df/d77/structbit_1_1stl_1_1function__signature">&#9670;&nbsp;</a></span>bit::stl::function_signature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::stl::function_signature</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Fn&gt;<br />
struct bit::stl::function_signature&lt; Fn &gt;</h3>

<p>Metafunction to extract the signature of a given function type. </p>
<p>The result is aliased as <code>::type</code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">fn</td><td>the function to check </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d5/d3b/function__signature_8hpp_source.html#l00025">25</a> of file <a class="el" href="../../d5/d3b/function__signature_8hpp_source.html">function_signature.hpp</a>.</p>
</div>
</div>
</div>
<a name="d3/dcc/structbit_1_1stl_1_1is__one__of" id="d3/dcc/structbit_1_1stl_1_1is__one__of"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d3/dcc/structbit_1_1stl_1_1is__one__of">&#9670;&nbsp;</a></span>bit::stl::is_one_of</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::stl::is_one_of</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, typename... Ts&gt;<br />
struct bit::stl::is_one_of&lt; T, Ts &gt;</h3>

<p>Type-trait to determine if <code>T</code> is one of <code>Ts</code>. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d0/def/is__one__of_8hpp_source.html#l00021">21</a> of file <a class="el" href="../../d0/def/is__one__of_8hpp_source.html">is_one_of.hpp</a>.</p>
</div>
</div>
</div>
<a name="d6/db2/structbit_1_1stl_1_1monostate" id="d6/db2/structbit_1_1stl_1_1monostate"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d6/db2/structbit_1_1stl_1_1monostate">&#9670;&nbsp;</a></span>bit::stl::monostate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::stl::monostate</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Unit type intended for use as a well-behaved empty alternative in <code>variant</code>. </p>
<p>In particular, a variant of non-default-constructible types may list monostate as its first alternative: this makes the variant itself default-constructible. </p>

<p class="definition">Definition at line <a class="el" href="../../d0/df0/monostate_8hpp_source.html#l00024">24</a> of file <a class="el" href="../../d0/df0/monostate_8hpp_source.html">monostate.hpp</a>.</p>
</div>
</div>
</div>
<a name="d9/d75/structbit_1_1stl_1_1normalize__char" id="d9/d75/structbit_1_1stl_1_1normalize__char"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d9/d75/structbit_1_1stl_1_1normalize__char">&#9670;&nbsp;</a></span>bit::stl::normalize_char</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::stl::normalize_char</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct bit::stl::normalize_char&lt; T &gt;</h3>

<p>Normalizes character types T to non-signed/unsigned character types. </p>
<p>The result is aliased as  ::type</p>
<dl class="section note"><dt>Note</dt><dd>The result is undefined for anything that is not a char-type </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dd/d43/normalize__char_8hpp_source.html#l00024">24</a> of file <a class="el" href="../../dd/d43/normalize__char_8hpp_source.html">normalize_char.hpp</a>.</p>
</div>
</div>
</div>
<a name="d2/d69/structbit_1_1stl_1_1nth__type" id="d2/d69/structbit_1_1stl_1_1nth__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d2/d69/structbit_1_1stl_1_1nth__type">&#9670;&nbsp;</a></span>bit::stl::nth_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::stl::nth_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;std::size_t I, typename... Types&gt;<br />
struct bit::stl::nth_type&lt; I, Types &gt;</h3>

<p>Type-trait for extracting the <code>Ith</code> type from a variadic pack. </p>
<p>The result is aliased as <code>::type</code> </p>

<p class="definition">Definition at line <a class="el" href="../../dc/d01/nth__type_8hpp_source.html#l00023">23</a> of file <a class="el" href="../../dc/d01/nth__type_8hpp_source.html">nth_type.hpp</a>.</p>
</div>
</div>
</div>
<a name="d5/d60/structbit_1_1stl_1_1sfinae__base" id="d5/d60/structbit_1_1stl_1_1sfinae__base"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d5/d60/structbit_1_1stl_1_1sfinae__base">&#9670;&nbsp;</a></span>bit::stl::sfinae_base</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::stl::sfinae_base</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Base class for sfinae types. </p>

<p class="definition">Definition at line <a class="el" href="../../d5/da8/sfinae_8hpp_source.html#l00018">18</a> of file <a class="el" href="../../d5/da8/sfinae_8hpp_source.html">sfinae.hpp</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a00b2917c0006468d01d1547affeb4946"></a>typedef char(&amp;)[4]</td>
<td class="fieldname">
no_type</td>
<td class="fielddoc">
Type corresponding to no (is not) instances using SFINAE. <dl class="section note"><dt>Note</dt><dd>bit::no_type is guaranteed to be a different size than bit::yes_type </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="a9e5bf19c20970d1e1bf38171391a7066"></a>typedef char(&amp;)[1]</td>
<td class="fieldname">
yes_type</td>
<td class="fielddoc">
Type corresponding to yes (is) instances using SFINAE. <dl class="section note"><dt>Note</dt><dd>bit::yes_type is guaranteed to be a different size than bit::no_type </dd></dl>
</td></tr>
</table>

</div>
</div>
<a name="dd/d73/classbit_1_1stl_1_1underlying__container__type" id="dd/d73/classbit_1_1stl_1_1underlying__container__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#dd/d73/classbit_1_1stl_1_1underlying__container__type">&#9670;&nbsp;</a></span>bit::stl::underlying_container_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class bit::stl::underlying_container_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class bit::stl::underlying_container_type&lt; T &gt;</h3>


<p class="definition">Definition at line <a class="el" href="../../d1/d4e/utility_8hpp_source.html#l00105">105</a> of file <a class="el" href="../../d1/d4e/utility_8hpp_source.html">utility.hpp</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="ad061421c9c25bca1057630ee1a55fa0a"></a>typedef typename type</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a129f3fb91f063c824288765df8236f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129f3fb91f063c824288765df8236f3e">&#9670;&nbsp;</a></span>aligned_storage_for</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a129f3fb91f063c824288765df8236f3e">bit::stl::aligned_storage_for</a> = typedef <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aac09cfc87a880a0470296b50ae869cd4">aligned_storage_t</a>&lt;detail::aligned_storage_max&lt;sizeof(Types)...&gt;::value, detail::aligned_storage_max&lt;alignof(Types)...&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type-alias for creating <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d2/d55/structbit_1_1stl_1_1aligned__storage" title="Provides the nested type type, which is a PODType suitable for use as uninitialized storage for any o...">aligned_storage</a> large enough and suitably aligned for all specified Types... </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Types</td><td>the types to ensure alignment and size of </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d7/de5/aligned__storage_8hpp_source.html#l00067">67</a> of file <a class="el" href="../../d7/de5/aligned__storage_8hpp_source.html">aligned_storage.hpp</a>.</p>

</div>
</div>
<a id="ab55b248051d5393fe10e6ffe1f7b2143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55b248051d5393fe10e6ffe1f7b2143">&#9670;&nbsp;</a></span>bool_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool B&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ab55b248051d5393fe10e6ffe1f7b2143">bit::stl::bool_constant</a> = typedef integral_constant&lt;bool,B&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This utility metafunction provides compile-time boolean values as an integral constant. </p>
<p>The value is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d6/dfd/bool__constant_8hpp_source.html#l00022">22</a> of file <a class="el" href="../../d6/dfd/bool__constant_8hpp_source.html">bool_constant.hpp</a>.</p>

</div>
</div>
<a id="a8f679456d2b3cd6f3f65577718d97c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f679456d2b3cd6f3f65577718d97c79">&#9670;&nbsp;</a></span>function_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a8f679456d2b3cd6f3f65577718d97c79">bit::stl::function_t</a> = typedef typename detail::function_t&lt;Fn&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type alias for function pointers to make it more readable. </p>
<dl class="section note"><dt>Note</dt><dd>That function_t is unable to deduce it's template parameters if used in a deduction context. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dd/de3/types_8hpp_source.html#l00162">162</a> of file <a class="el" href="../../dd/de3/types_8hpp_source.html">types.hpp</a>.</p>

</div>
</div>
<a id="a88f5507832d9db0668b2b0d96c93be75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f5507832d9db0668b2b0d96c93be75">&#9670;&nbsp;</a></span>identity_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a88f5507832d9db0668b2b0d96c93be75">bit::stl::identity_t</a> = typedef typename <a class="el" href="../../df/d46/structbit_1_1stl_1_1identity.html">identity</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Namespace alias used to extract identity&lt;T&gt;::type. </p>
<dl class="section note"><dt>Note</dt><dd>This alias is mostly useful for preventing template deduction </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d7/d0e/identity_8hpp_source.html#l00025">25</a> of file <a class="el" href="../../d7/d0e/identity_8hpp_source.html">identity.hpp</a>.</p>

</div>
</div>
<a id="a120d4f65c646a277af6fd9c51ad78381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120d4f65c646a277af6fd9c51ad78381">&#9670;&nbsp;</a></span>is_invocable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a120d4f65c646a277af6fd9c51ad78381">bit::stl::is_invocable</a> = typedef detail::is_invocable&lt;Fn,Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait to determine whether <code>Fn</code> is invokable with <code>Args</code>... </p>
<p>Formally, the expression: </p><div class="fragment"><div class="line">INVOKE( std::declval&lt;Fn&gt;(), std::declval&lt;Args&gt;()... )</div></div><!-- fragment --><p> is well formed</p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../dd/d31/invoke_8hpp_source.html#l00058">58</a> of file <a class="el" href="../../dd/d31/invoke_8hpp_source.html">invoke.hpp</a>.</p>

</div>
</div>
<a id="a7f47ee038bc1d9539fe2f38cbc00915e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f47ee038bc1d9539fe2f38cbc00915e">&#9670;&nbsp;</a></span>is_nothrow_invocable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a7f47ee038bc1d9539fe2f38cbc00915e">bit::stl::is_nothrow_invocable</a> = typedef detail::is_nothrow_invocable&lt;Fn,Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait to determine whether <code>Fn</code> is nothrow invokable with <code>Args</code>... </p>
<p>Formally, the expression: </p><div class="fragment"><div class="line">INVOKE( std::declval&lt;Fn&gt;(), std::declval&lt;Args&gt;()... )</div></div><!-- fragment --><p> is well formed and is known not to throw</p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../dd/d31/invoke_8hpp_source.html#l00084">84</a> of file <a class="el" href="../../dd/d31/invoke_8hpp_source.html">invoke.hpp</a>.</p>

</div>
</div>
<a id="ada876145f89a8518848ed41709737585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada876145f89a8518848ed41709737585">&#9670;&nbsp;</a></span>is_same_decay</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ada876145f89a8518848ed41709737585">bit::stl::is_same_decay</a> = typedef std::is_same&lt;std::decay_t&lt;T&gt;,std::decay_t&lt;U&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait to determine whether a type is the same with a different decay type. </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d6/dd3/is__same__decay_8hpp_source.html#l00022">22</a> of file <a class="el" href="../../d6/dd3/is__same__decay_8hpp_source.html">is_same_decay.hpp</a>.</p>

</div>
</div>
<a id="ac960b0c0061252bb398695e4bd0c706b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac960b0c0061252bb398695e4bd0c706b">&#9670;&nbsp;</a></span>is_string_span</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ac960b0c0061252bb398695e4bd0c706b">bit::stl::is_string_span</a> = typedef detail::is_string_span&lt;std::remove_cv_t&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type-trait to determine whether the type is a string_span </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d9/d14/string__span_8hpp_source.html#l00100">100</a> of file <a class="el" href="../../d9/d14/string__span_8hpp_source.html">string_span.hpp</a>.</p>

</div>
</div>
<a id="ad591c6c50fab0fb9348d8afd38322a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad591c6c50fab0fb9348d8afd38322a37">&#9670;&nbsp;</a></span>is_zstring_span</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ad591c6c50fab0fb9348d8afd38322a37">bit::stl::is_zstring_span</a> = typedef detail::is_zstring_span&lt;std::remove_cv_t&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type-trait to determine whether the type is a null-terminated string </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d9/d14/string__span_8hpp_source.html#l00107">107</a> of file <a class="el" href="../../d9/d14/string__span_8hpp_source.html">string_span.hpp</a>.</p>

</div>
</div>
<a id="a077a922f056d7c58abbab9a8634686be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077a922f056d7c58abbab9a8634686be">&#9670;&nbsp;</a></span>match_cv_qualifiers</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Qualified , typename Unqualified &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a077a922f056d7c58abbab9a8634686be">bit::stl::match_cv_qualifiers</a> = typedef detail::cv_selector&lt; Unqualified, std::is_const&lt;Qualified&gt;::value, std::is_volatile&lt;Qualified&gt;::value &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait to match the cv qualifications of <code>Qualified</code> and apply it to <code>Unqualified</code>. </p>
<p>The result is aliased as <code>::type</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d7/da0/match__cv__qualifiers_8hpp_source.html#l00051">51</a> of file <a class="el" href="../../d7/da0/match__cv__qualifiers_8hpp_source.html">match_cv_qualifiers.hpp</a>.</p>

</div>
</div>
<a id="a9a79f6cac4e03284e5b37de4066e8195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a79f6cac4e03284e5b37de4066e8195">&#9670;&nbsp;</a></span>match_ref_qualifiers</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Qualified , typename Unqualified &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a9a79f6cac4e03284e5b37de4066e8195">bit::stl::match_ref_qualifiers</a> = typedef detail::ref_selector&lt; Unqualified, std::is_lvalue_reference&lt;Qualified&gt;::value, std::is_rvalue_reference&lt;Qualified&gt;::value &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait to match the ref qualifications of <code>Qualified</code> and apply it to <code>Unqualified</code>. </p>
<p>The result is aliased as <code>::type</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d0/d5a/match__ref__qualifiers_8hpp_source.html#l00044">44</a> of file <a class="el" href="../../d0/d5a/match__ref__qualifiers_8hpp_source.html">match_ref_qualifiers.hpp</a>.</p>

</div>
</div>
<a id="a243bc9548267f05aaabf64ce36d3b981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a243bc9548267f05aaabf64ce36d3b981">&#9670;&nbsp;</a></span>match_sign_qualifiers</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Qualified , typename Unqualified &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a243bc9548267f05aaabf64ce36d3b981">bit::stl::match_sign_qualifiers</a> = typedef detail::sign_selector&lt; Unqualified, std::is_signed&lt;Qualified&gt;::value, std::is_unsigned&lt;Qualified&gt;::value &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait to match the sign qualifications of <code>Qualified</code> and apply it to <code>Unqualified</code>. </p>
<p>The result is aliased as <code>::type</code> </p>

<p class="definition">Definition at line <a class="el" href="../../de/d9b/match__sign__qualifiers_8hpp_source.html#l00043">43</a> of file <a class="el" href="../../de/d9b/match__sign__qualifiers_8hpp_source.html">match_sign_qualifiers.hpp</a>.</p>

</div>
</div>
<a id="add8bed7c33c9ca2f16724b85c3a0bb1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add8bed7c33c9ca2f16724b85c3a0bb1c">&#9670;&nbsp;</a></span>member_function_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#add8bed7c33c9ca2f16724b85c3a0bb1c">bit::stl::member_function_t</a> = typedef typename detail::member_function_t&lt;T,Fn&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type alias for member function pointers to make it more readable. </p>
<dl class="section note"><dt>Note</dt><dd>member_function_t is unable to deduce it's template parameters if used in a deduction context. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dd/de3/types_8hpp_source.html#l00155">155</a> of file <a class="el" href="../../dd/de3/types_8hpp_source.html">types.hpp</a>.</p>

</div>
</div>
<a id="aacf455f79e68ed45d131623ae84329b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf455f79e68ed45d131623ae84329b2">&#9670;&nbsp;</a></span>member_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aacf455f79e68ed45d131623ae84329b2">bit::stl::member_t</a> = typedef R T::*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type alias for member pointers to make it more readable. </p>
<dl class="section note"><dt>Note</dt><dd>member_t is unable to deduce it's template parameters if used in a deduction context. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dd/de3/types_8hpp_source.html#l00147">147</a> of file <a class="el" href="../../dd/de3/types_8hpp_source.html">types.hpp</a>.</p>

</div>
</div>
<a id="a793ba48cdec0344ad6a9dcc1792407dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793ba48cdec0344ad6a9dcc1792407dc">&#9670;&nbsp;</a></span>pointer_rank</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a793ba48cdec0344ad6a9dcc1792407dc">bit::stl::pointer_rank</a> = typedef detail::pointer_rank&lt;T,0&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the level of indirection of a given type T. </p>
<p>This effectively counts the number of pointer types in a given type T</p>
<p>The result is stored in <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../df/dde/pointer__rank_8hpp_source.html#l00035">35</a> of file <a class="el" href="../../df/dde/pointer__rank_8hpp_source.html">pointer_rank.hpp</a>.</p>

</div>
</div>
<a id="a618d89ada20b451c43bf19ab9580409e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618d89ada20b451c43bf19ab9580409e">&#9670;&nbsp;</a></span>size_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a618d89ada20b451c43bf19ab9580409e">bit::stl::size_constant</a> = typedef std::integral_constant&lt;std::size_t,Size&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This utility metafunction provides compile-time size values as an integral constant. </p>
<p>The value is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../de/dcd/size__constant_8hpp_source.html#l00025">25</a> of file <a class="el" href="../../de/dcd/size__constant_8hpp_source.html">size_constant.hpp</a>.</p>

</div>
</div>
<a id="ae6db0040e1fb483117eb2ddadbfba7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6db0040e1fb483117eb2ddadbfba7a7">&#9670;&nbsp;</a></span>void_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ae6db0040e1fb483117eb2ddadbfba7a7">bit::stl::void_t</a> = typedef typename detail::voidify&lt;Types...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility metafunction that maps a sequence of any types to the type void. </p>
<p>This is used for determining validity of expressions using SFINAE </p>

<p class="definition">Definition at line <a class="el" href="../../d9/dce/void__t_8hpp_source.html#l00026">26</a> of file <a class="el" href="../../d9/dce/void__t_8hpp_source.html">void_t.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a3491ada4c9984f7854f01ad75b62c8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3491ada4c9984f7854f01ad75b62c8b9">&#9670;&nbsp;</a></span>byte</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3491ada4c9984f7854f01ad75b62c8b9">bit::stl::byte</a> : unsigned char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsigned byte type. </p>
<dl class="section note"><dt>Note</dt><dd>Due to a restriction in pre-C++-17, a conversion to a pointer of byte types results in undefined behavior due to a violation of strict-aliasing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../da/da9/byte_8hpp_source.html#l00022">22</a> of file <a class="el" href="../../da/da9/byte_8hpp_source.html">byte.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="abffa940c73f4ad283c6d1bc0042ca46b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abffa940c73f4ad283c6d1bc0042ca46b">&#9670;&nbsp;</a></span>address_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::stl::address_from </td>
          <td>(</td>
          <td class="paramtype">InputIterator &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> -&gt;  typename std::iterator_traits&lt; InputIterator &gt;::value_type *</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains the actual address of the object referenced through an iterator <code>it</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the value referenced from the iterator </dd></dl>

</div>
</div>
<a id="a767ceaa1de7727dadc2a6523b37ffa5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767ceaa1de7727dadc2a6523b37ffa5b">&#9670;&nbsp;</a></span>apply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) constexpr bit::stl::apply </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the Callable object <code>function</code> with a <code>tuple</code> of arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to be invoked </td></tr>
    <tr><td class="paramname">tuple</td><td>tuple whose elements to be used as arguments to <code>function</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value returned from <code>function</code> </dd></dl>

</div>
</div>
<a id="abd395f73ba3488ce123b405e80b43eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd395f73ba3488ce123b405e80b43eee">&#9670;&nbsp;</a></span>apply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) constexpr bit::stl::apply </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the Callable object f with a tuple of arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Callable object to be invoked </td></tr>
    <tr><td class="paramname">t</td><td>tuple whose elements to be used as arguments to <code>f</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value returned from invoking <code>f</code> with <code>t's</code> elements </dd></dl>

</div>
</div>
<a id="a994018402d561913cfd756806468244a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994018402d561913cfd756806468244a">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T&amp; bit::stl::at </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safely retrieves the value at the given index, otherwise asserts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>reference to the array to index into </td></tr>
    <tr><td class="paramname">n</td><td>the index to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to instance </dd></dl>

</div>
</div>
<a id="ace51dc6914690cfdbde3caf2c7f66105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace51dc6914690cfdbde3caf2c7f66105">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Key &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) constexpr bit::stl::at </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safely retrieves the value at the given index, otherwise asserts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>reference to the array to index into </td></tr>
    <tr><td class="paramname">n</td><td>the index to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to instance </dd></dl>

</div>
</div>
<a id="a74872a5b5134f3972927a78e69b5c8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74872a5b5134f3972927a78e69b5c8c7">&#9670;&nbsp;</a></span>deep_compare() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::deep_compare </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a deep comparison of two pointer-like objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left pointer </td></tr>
    <tr><td class="paramname">rhs</td><td>the right pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> is the same as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a61b012db31ce10640055ff0c1bcc8baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b012db31ce10640055ff0c1bcc8baf">&#9670;&nbsp;</a></span>deep_compare() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::deep_compare </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a deep comparison of two pointer-like objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left pointer </td></tr>
    <tr><td class="paramname">rhs</td><td>the right pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> is the same as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a4f080cd59b223c721bb87836df95e0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f080cd59b223c721bb87836df95e0b9">&#9670;&nbsp;</a></span>deep_compare() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::deep_compare </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a deep comparison of two pointer-like objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left pointer </td></tr>
    <tr><td class="paramname">rhs</td><td>the right pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> is the same as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a3ef190c6b43facf566fc7bf0ccf2b5d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef190c6b43facf566fc7bf0ccf2b5d2">&#9670;&nbsp;</a></span>deep_compare() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::deep_compare </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a deep comparison of two pointer-like objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left pointer </td></tr>
    <tr><td class="paramname">rhs</td><td>the right pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> is the same as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a36e445241b494aa7aa950f4ca4ff2d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e445241b494aa7aa950f4ca4ff2d5c">&#9670;&nbsp;</a></span>default_assert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bit::stl::default_assert </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html">source_location</a>&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default assert handler. Prints a message, then triggers a breakpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>the message to print </td></tr>
    <tr><td class="paramname">source</td><td>the source of the assertion </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af04c12401a97f0afbb5d9863e3454b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04c12401a97f0afbb5d9863e3454b3a">&#9670;&nbsp;</a></span>dereference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) constexpr bit::stl::dereference </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dereferences all levels of pointer indirection from the supplied pointer. </p>
<dl class="section note"><dt>Note</dt><dd>This does not do any null-checking</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer to dereference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the dereferenced pointer </dd></dl>

</div>
</div>
<a id="a1691dc7bcc77311536263be8d1273d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1691dc7bcc77311536263be8d1273d7b">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bit::stl::destroy </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the objects in the range <code></code>[first, <code>last</code>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the start of the range to destroy </td></tr>
    <tr><td class="paramname">end</td><td>the end of the range to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf862f7facbc4267ce240a9167ce3dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf862f7facbc4267ce240a9167ce3dfa">&#9670;&nbsp;</a></span>destroy_array_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bit::stl::destroy_array_at </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys an array of entries at the given <code>ptr</code>. </p>
<dl class="section note"><dt>Note</dt><dd>The pointer to the destroyed array must have been created with A call to uninitialized_create_array_at</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to an </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d9c14044feb39441c88d133e6f94bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9c14044feb39441c88d133e6f94bf9">&#9670;&nbsp;</a></span>destroy_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bit::stl::destroy_at </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the destructor of the object pointed to by p, as if by p-&gt;~T(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>a pointer to the object to be destroyed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63bf67710219534b12e99dec573c4802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63bf67710219534b12e99dec573c4802">&#9670;&nbsp;</a></span>destroy_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator bit::stl::destroy_n </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the <code>n</code> objects in the range starting at <code>first</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the start of the range to destroy </td></tr>
    <tr><td class="paramname">n</td><td>the number of entries to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc07be03c7b93e780e6b6369cfb5c718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc07be03c7b93e780e6b6369cfb5c718">&#9670;&nbsp;</a></span>finally()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/dc4/classbit_1_1stl_1_1final__act.html">final_act</a>&lt;Func&gt; bit::stl::finally </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to generate a <a class="el" href="../../db/dc4/classbit_1_1stl_1_1final__act.html" title="This class leverages RAII to perform cleanup actions at the end of a scope. ">final_act</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>the function to perform on the final act </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e2bf516ec5150488457255f5b3f63cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2bf516ec5150488457255f5b3f63cf">&#9670;&nbsp;</a></span>from_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* bit::stl::from_address </td>
          <td>(</td>
          <td class="paramtype">std::uintptr_t&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric address <code>address</code> into a pointer pointing to the address location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>the address value to convert to a pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer pointing to the given address </dd></dl>

</div>
</div>
<a id="a20fb1c369e77d674a654bb943210c7b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20fb1c369e77d674a654bb943210c7b0">&#9670;&nbsp;</a></span>fwd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) constexpr bit::stl::fwd </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wrapper around std::forward that removes the need for specifying the type T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to forward </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87c0ed1fbd40262a8ea362a934dec70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c0ed1fbd40262a8ea362a934dec70f">&#9670;&nbsp;</a></span>gcd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::common_type_t&lt;T,U&gt; bit::stl::gcd </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the greatest common divisor of the integers <code>m</code> and <code>n</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first integer value </td></tr>
    <tr><td class="paramname">b</td><td>the second integer value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The greatest common divisor </dd></dl>

</div>
</div>
<a id="a1d4bce747381dc857bde640ed77ba843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d4bce747381dc857bde640ed77ba843">&#9670;&nbsp;</a></span>get_assert_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">assert_handler_t bit::stl::get_assert_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the currently active assertion handler. </p>
<dl class="section return"><dt>Returns</dt><dd>the handler </dd></dl>

</div>
</div>
<a id="afbb3979b1bfe78dd08f8331113ca197e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb3979b1bfe78dd08f8331113ca197e">&#9670;&nbsp;</a></span>get_deleter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Deleter , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Deleter* bit::stl::get_deleter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/d8c/classbit_1_1stl_1_1clone__ptr.html">clone_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the <code>p's</code> deleter. </p>
<p>If the clone pointer <code>p</code> owns a deleter of type cv-unqualified <code>Deleter</code> (e.g. if it was created with one of the constructors that take a deleter as a parameter), then returns a pointer to the deleter.</p>
<p>Otherwise, returns a null pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the deleter </dd></dl>

</div>
</div>
<a id="ac44765e2cf31239152e2374bc6684ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44765e2cf31239152e2374bc6684ff6">&#9670;&nbsp;</a></span>get_underlying_container()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , underlying_container_type_t&lt; Container &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">underlying_container_type_t&lt;Container&gt;&amp; bit::stl::get_underlying_container </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the underlying container of a given container adapter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>reference to the container adapter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the underlying container </dd></dl>

</div>
</div>
<a id="a2f49b109d7088448b46673cb58124764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f49b109d7088448b46673cb58124764">&#9670;&nbsp;</a></span>hash_combine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr void bit::stl::hash_combine </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines the hash with another hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The seed to combine the hash with </td></tr>
    <tr><td class="paramname">v</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9693facf6e039e9742d25bb169b13b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9693facf6e039e9742d25bb169b13b23">&#9670;&nbsp;</a></span>hash_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_range </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hashes a range of entries, returning the result. </p>
<p>This is equivalent to combining hashes of all entries within the range</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range to hash </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hashed value </dd></dl>

</div>
</div>
<a id="a30fcd550eed18391c0c378c3c1dcd802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30fcd550eed18391c0c378c3c1dcd802">&#9670;&nbsp;</a></span>hash_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr void bit::stl::hash_range </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hashes a range of entries. </p>
<p>This is equivalent to combining hashes of all entries within the range</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The seed to comine the hash with </td></tr>
    <tr><td class="paramname">first</td><td>The beginning of the range to hash </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range to hash </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02ea8727fd45f88a76ad6f9831623f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ea8727fd45f88a76ad6f9831623f0b">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[1/41]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/db2/structbit_1_1stl_1_1monostate">monostate</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hashes the monostate. </p>
<dl class="section return"><dt>Returns</dt><dd>9 </dd></dl>

</div>
</div>
<a id="a6f350703033effb94b5441aa17bccc02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f350703033effb94b5441aa17bccc02">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[2/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes a std::basic_string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash </dd></dl>

</div>
</div>
<a id="a584a27d0ea529578cfc11814176d3c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584a27d0ea529578cfc11814176d3c77">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[3/41]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of a null pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a9403b1d1333c84854974c3a26930c43e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9403b1d1333c84854974c3a26930c43e">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[4/41]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given bool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a21f07967eb5d5b849827db763987c8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f07967eb5d5b849827db763987c8fa">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[5/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Deleter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; T, Deleter &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes a unique_ptr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the ptr to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the unique_ptr </dd></dl>

</div>
</div>
<a id="a63eb167c6e9f2f72cb951d98e6b524aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63eb167c6e9f2f72cb951d98e6b524aa">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[6/41]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given char. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="acbec1aa53918460d5481c91354848547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbec1aa53918460d5481c91354848547">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[7/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes a shared_ptr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the ptr to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the unique_ptr </dd></dl>

</div>
</div>
<a id="aec0659afd18943b4b40ce92861a91508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0659afd18943b4b40ce92861a91508">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[8/41]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">signed char&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given signed char. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="aa66ae1724a126027297374c374b6ef6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66ae1724a126027297374c374b6ef6a">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[9/41]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given unsigned char. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="ad72f61cc97f25653194a936ee6b7dcf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad72f61cc97f25653194a936ee6b7dcf7">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[10/41]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">wchar_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given wchar_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a71c975f2d74a9235b487048cdf8379cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c975f2d74a9235b487048cdf8379cc">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[11/41]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">char16_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given char16_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a5d397ddf0317c66df2bfc01f46f8a5cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d397ddf0317c66df2bfc01f46f8a5cf">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[12/41]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">char32_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given char32_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a7154f4d7363372961d1e1994fa5bb7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7154f4d7363372961d1e1994fa5bb7c7">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[13/41]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given short. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a4a525d7be855171985a7193ecaecab76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a525d7be855171985a7193ecaecab76">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[14/41]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given unsigned short. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="ae0f0ceba5bc16b60258fbf0506bcae35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f0ceba5bc16b60258fbf0506bcae35">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[15/41]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given int. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a40a377050372166907861b21ab4b56c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a377050372166907861b21ab4b56c8">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[16/41]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given unsigned int. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a596483385fd40c05411995fb76e8cfa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596483385fd40c05411995fb76e8cfa5">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[17/41]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given long. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a45c2924b2f3e21ee85f0f514f59848e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c2924b2f3e21ee85f0f514f59848e4">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[18/41]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given unsigned long. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a5a97a54533bc83393bc21f5155c8f331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a97a54533bc83393bc21f5155c8f331">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[19/41]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given long long. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a16f32f66345d679e5031c7e7197dadc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f32f66345d679e5031c7e7197dadc4">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[20/41]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given unsigned long long. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a77fd58ad444420cb8b01a2832fdf496c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77fd58ad444420cb8b01a2832fdf496c">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[21/41]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given float. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="aa8add61aed3531d951d4e8cce1013363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8add61aed3531d951d4e8cce1013363">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[22/41]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a4e06a2ef7ee4eb339d240272fa4a3eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e06a2ef7ee4eb339d240272fa4a3eeb">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[23/41]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given long double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a4fcde1a36bf0d2e13786387e2b0150f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fcde1a36bf0d2e13786387e2b0150f1">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[24/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">T *const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="ab931efe137588922f0e94656ecc1f973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab931efe137588922f0e94656ecc1f973">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[25/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the hash from a given <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html" title="The basic_hashed_string_view is a compile-time hashed wrapper around a non-owning string (basic_strin...">basic_hashed_string_view</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html" title="The basic_hashed_string_view is a compile-time hashed wrapper around a non-owning string (basic_strin...">basic_hashed_string_view</a> to retrieve the hash from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the string </dd></dl>

</div>
</div>
<a id="a20db1218b612cc2ab37f8dcd38615a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20db1218b612cc2ab37f8dcd38615a72">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[26/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>val</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a hash of the given T array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a8f3b83a4b60aa7cc9b67201bdf733341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3b83a4b60aa7cc9b67201bdf733341">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[27/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes this <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the underlying pointer </dd></dl>

</div>
</div>
<a id="ad849248942ee4fdca3f4d0c9f5ecb2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad849248942ee4fdca3f4d0c9f5ecb2ee">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[28/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>val</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a hash of the given T array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a034adf6da7e194b42f547fd9893c7eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034adf6da7e194b42f547fd9893c7eb8">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[29/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Enum &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">Enum&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes enum values. </p>
<dl class="section note"><dt>Note</dt><dd>This only participates in overload resolution if <code>std::is_enum</code> is <code>true</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the enum value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash value of the enum </dd></dl>

</div>
</div>
<a id="a8c9de76842f31be5040cc11a5d14ea85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9de76842f31be5040cc11a5d14ea85">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[30/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the hash from a given <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html" title="The basic_hashed_string_view is a compile-time hashed wrapper around a non-owning string (basic_strin...">basic_hashed_string_view</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html" title="The basic_hashed_string_view is a compile-time hashed wrapper around a non-owning string (basic_strin...">basic_hashed_string_view</a> to retrieve the hash from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the string </dd></dl>

</div>
</div>
<a id="a2fdef9b2830203ce585db5d761edd266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdef9b2830203ce585db5d761edd266">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[31/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes any given container. </p>
<p>The hash is computed as the combination of all the hashes within the container</p>
<dl class="section note"><dt>Note</dt><dd>This does not participate in overload resolution unless the container defines begin() and end()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>the container to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash value </dd></dl>

</div>
</div>
<a id="a5f4b0d5342a805f542d824ef4348b9af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4b0d5342a805f542d824ef4348b9af">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[32/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>pair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hashes a std::pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pair</td><td>the pair to hash </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7241d90920683074f44ebf4023aa040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7241d90920683074f44ebf4023aa040">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[33/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes a <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html" title="An offset pointer based on boost::offset_ptr. ">offset_ptr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the ptr to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the unique_ptr </dd></dl>

</div>
</div>
<a id="a1d3887964130579e473a8c9ba19497f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3887964130579e473a8c9ba19497f6">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[34/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; Args... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hashes a tuple of entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>the tuple to hash </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a095457d6a448fa63db72891dda7ff055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095457d6a448fa63db72891dda7ff055">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[35/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hashes an initializer_list. </p>
<p>This is equivalent to calling hash_range( il.begin(), il.end() )</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>the initializer_list to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the initializer_list </dd></dl>

</div>
</div>
<a id="a8c483265cee8b59be7c053f892262432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c483265cee8b59be7c053f892262432">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[36/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d6a/classbit_1_1stl_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes the value of the underlying type of the <a class="el" href="../../d6/d6a/classbit_1_1stl_1_1propagate__const.html" title="A wrapper to propagate the const qualifier. ">propagate_const</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hashed value </dd></dl>

</div>
</div>
<a id="a579b291a6b48dec5d3278c1e08170fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579b291a6b48dec5d3278c1e08170fae">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[37/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d6a/classbit_1_1stl_1_1fat__ptr.html">fat_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes the <a class="el" href="../../d9/d6a/classbit_1_1stl_1_1fat__ptr.html" title="A fat pointer that contains the pointer and the size. ">fat_ptr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the <a class="el" href="../../d9/d6a/classbit_1_1stl_1_1fat__ptr.html" title="A fat pointer that contains the pointer and the size. ">fat_ptr</a> </dd></dl>

</div>
</div>
<a id="a889cce0c0e6dd8da86d6ed018e66d9de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889cce0c0e6dd8da86d6ed018e66d9de">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[38/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>pair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hashes a std::pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pair</td><td>the pair to hash </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83b254b21c3e850abecc2b128cb236b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b254b21c3e850abecc2b128cb236b3">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[39/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a hash of the underlying lazy, instantiating it if not already instantiated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to retrieve the has of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the lazy </dd></dl>

</div>
</div>
<a id="a0d4f9bef5f51b8b9fde39f5ab1b29212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4f9bef5f51b8b9fde39f5ab1b29212">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[40/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the hash from a given optional. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the optional to retrieve the hash from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the string </dd></dl>

</div>
</div>
<a id="adca339d8647a8939fccfe7e0aef8b9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca339d8647a8939fccfe7e0aef8b9d7">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[41/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the hash from a given <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html" title="A wrapper around non-owned strings. ">basic_string_view</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the basic_ string_view to retrieve the hash from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the string </dd></dl>

</div>
</div>
<a id="ad0dbaaca037aad1973f344bc1f6bbd81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0dbaaca037aad1973f344bc1f6bbd81">&#9670;&nbsp;</a></span>indeterminate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::indeterminate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tribool is indeterminate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tribool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>t</code> is <code>indeterminate</code> </dd></dl>

</div>
</div>
<a id="a48ce9fdc997ce1f3c58f1c246ef65c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ce9fdc997ce1f3c58f1c246ef65c21">&#9670;&nbsp;</a></span>invoke()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::stl::invoke </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(detail::invoke_impl(std::forward&lt; Func &gt;(function), std::forward&lt; Args &gt;(args)...))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke the Callable object <code>function</code> with the parameters <code>args</code>. </p>
<p>As by <code>INVOKE</code>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to be invoked </td></tr>
    <tr><td class="paramname">args</td><td>arguments to pass to <code>function</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a064c1a74dad23ef09ef9eaf423532596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064c1a74dad23ef09ef9eaf423532596">&#9670;&nbsp;</a></span>lcm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::common_type_t&lt;T,U&gt; bit::stl::lcm </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the least common multiple of the integers <code>m</code> and <code>n</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first integer value </td></tr>
    <tr><td class="paramname">b</td><td>the second integer value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The least-common multiple of <code>a</code> and <code>b</code> </dd></dl>

</div>
</div>
<a id="a2befb911f8c8b196b4ba81d50e20fb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2befb911f8c8b196b4ba81d50e20fb28">&#9670;&nbsp;</a></span>make_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = detail::array_autodeduce, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::stl::make_array </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt;  detail::array_return_type_t&lt; T, Args... &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make utility for creating a std::array. </p>
<p>If the return type is explicitly specified, no deduction take place; if the type is ommitted, the return type is the common type of all inputs.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the return type of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>the arguments for the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array containing the arguments </dd></dl>

</div>
</div>
<a id="ab9c5bd1f2d6824c7fafd21e9621add0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c5bd1f2d6824c7fafd21e9621add0f">&#9670;&nbsp;</a></span>make_compressed_pair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt;std::decay_t&lt;T1&gt;,std::decay_t&lt;T2&gt; &gt; bit::stl::make_compressed_pair </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make utility to create a type-deduced compressed pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to assign to <code>first</code> </td></tr>
    <tr><td class="paramname">y</td><td>the value to assign to <code>second</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14e8cff3ee1637db01fb2e8c04a4a9a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e8cff3ee1637db01fb2e8c04a4a9a0">&#9670;&nbsp;</a></span>make_enum_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Enum &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d5/d36/classbit_1_1stl_1_1enum__range.html">enum_range</a>&lt;Enum&gt; bit::stl::make_enum_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes an enum range from a given. </p>
<dl class="section return"><dt>Returns</dt><dd>an enum range </dd></dl>

</div>
</div>
<a id="af9a49f6f584ffbee6b67c31087a95e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a49f6f584ffbee6b67c31087a95e03">&#9670;&nbsp;</a></span>make_from_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T bit::stl::make_from_tuple </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an object of type  T, using the elements of the tuple t as the arguments to the constructor. </p>
<p>Construct an object of type T, using the elements of the tuple t as the arguments to the constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>tuple whose elements to be used as arguments to the constructor of T </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The constructed T object</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to construct </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>tuple whose elements to be used as arguments to the constructor of T </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The constructed T object </dd></dl>

</div>
</div>
<a id="aa33bddf083a04210702a30106d991b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33bddf083a04210702a30106d991b3f">&#9670;&nbsp;</a></span>make_key_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../de/d9c/classbit_1_1stl_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt;0,Iterator&gt; bit::stl::make_key_iterator </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for making a tuple iterator that only iterates the first tuple element, which is the key in associative containers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tuple element iterator </dd></dl>

</div>
</div>
<a id="aa998a5df14df29d0930831c718ef1a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa998a5df14df29d0930831c718ef1a25">&#9670;&nbsp;</a></span>make_key_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Sentinel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::stl::make_key_range </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sentinel&#160;</td>
          <td class="paramname"><em>sentinel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="../../d9/d68/classbit_1_1stl_1_1range.html">range</a>&lt; <a class="el" href="../../de/d9c/classbit_1_1stl_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; 0, Iterator &gt;, <a class="el" href="../../de/d9c/classbit_1_1stl_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; 0, Sentinel &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a range from a given <code>iterator</code> <code>sentinel</code> pair iterating the first value of a given tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>the beginning of a range </td></tr>
    <tr><td class="paramname">sentinel</td><td>the end of a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced tuple_element range </dd></dl>

</div>
</div>
<a id="a44b291d11c52d94444f2625dcefb69da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b291d11c52d94444f2625dcefb69da">&#9670;&nbsp;</a></span>make_key_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::stl::make_key_range </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> -&gt;  decltype(make_key_range(r.begin(), r.end()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a key range from another range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a key range </dd></dl>

</div>
</div>
<a id="a9ea22e81640ef84b40a63a3aa0280a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea22e81640ef84b40a63a3aa0280a2f">&#9670;&nbsp;</a></span>make_lazy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt;T&gt; bit::stl::make_lazy </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a lazy type from the given arguments. </p>
<p>This is just a wrapper around lazy&lt;T&gt;( in_place, args... );</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>the arguments to forward to T's constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the lazy instance </dd></dl>

</div>
</div>
<a id="a769c3379a597a59899d35d552c8a14a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a769c3379a597a59899d35d552c8a14a2">&#9670;&nbsp;</a></span>make_lazy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt;T&gt; bit::stl::make_lazy </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; U &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a lazy type from the given arguments. </p>
<p>This is just a wrapper around lazy&lt;T&gt;( in_place, ilist, args... );</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>an initializer list to forward to T's constructor </td></tr>
    <tr><td class="paramname">args</td><td>the arguments to forward to T's constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the lazy instance </dd></dl>

</div>
</div>
<a id="ad7844a4592038b7ba6cf898167d593d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7844a4592038b7ba6cf898167d593d4">&#9670;&nbsp;</a></span>make_lazy_generator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Ctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt;T&gt; bit::stl::make_lazy_generator </td>
          <td>(</td>
          <td class="paramtype">Ctor &amp;&amp;&#160;</td>
          <td class="paramname"><em>ctor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a lazy type that uses a generator function to generate the arguments that will be forwarded to T's constructor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the lazy to construct </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctor</td><td>A function that returns a tuple of arguments used to forward to T's constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly constructed lazy </dd></dl>

</div>
</div>
<a id="add5f09d0db15bc976086708151cad4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5f09d0db15bc976086708151cad4e7">&#9670;&nbsp;</a></span>make_move_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Sentinel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d68/classbit_1_1stl_1_1range.html">move_range</a>&lt;Iterator,Sentinel&gt; bit::stl::make_move_range </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sentinel&#160;</td>
          <td class="paramname"><em>sentinel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a movable range from a given <code>iterator</code> <code>sentinal</code> pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>the beginning of a range </td></tr>
    <tr><td class="paramname">sentinel</td><td>the end of a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced range </dd></dl>

</div>
</div>
<a id="a6fd4d204c6360d55e80c63411164decb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd4d204c6360d55e80c63411164decb">&#9670;&nbsp;</a></span>make_move_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::stl::make_move_range </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> -&gt;  decltype(make_move_range(r.begin(), r.end()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a reverse range from a given <code>iterator</code> <code>sentinal</code> pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irange</td><td>the range to deduce </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced range </dd></dl>

</div>
</div>
<a id="abdd9da49e3cb4e053b125e324336be8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd9da49e3cb4e053b125e324336be8a">&#9670;&nbsp;</a></span>make_observer() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt;T&gt; bit::stl::make_observer </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes an <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> from a raw pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> </dd></dl>

</div>
</div>
<a id="afe3a7cdb4778675a5d49b02a7f01a02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3a7cdb4778675a5d49b02a7f01a02e">&#9670;&nbsp;</a></span>make_observer() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , std::enable_if_t&lt;!std::is_same&lt; T, U &gt;::value &amp;&amp;std::is_convertible&lt; U *, T *&gt;::value &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt;T&gt; bit::stl::make_observer </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes an <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> from a raw pointer, and coerces it to the specified type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to convert to </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> </dd></dl>

</div>
</div>
<a id="aaf64affbaa7d1b456ae4be240ec6fc1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf64affbaa7d1b456ae4be240ec6fc1c">&#9670;&nbsp;</a></span>make_observer() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pointer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::stl::make_observer </td>
          <td>(</td>
          <td class="paramtype">const Pointer &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> -&gt;  decltype(make_observer(ptr.get()))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes an <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> from a smart pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> </dd></dl>

</div>
</div>
<a id="aca5430a6c4a3f1cbe97bbc798b5eac11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5430a6c4a3f1cbe97bbc798b5eac11">&#9670;&nbsp;</a></span>make_observer() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Pointer , std::enable_if&lt; detail::is_ptr_observable&lt; Pointer &gt;::value &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt;T&gt; bit::stl::make_observer </td>
          <td>(</td>
          <td class="paramtype">const Pointer &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes an <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> from a smart pointer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>explicit type of the pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> </dd></dl>

</div>
</div>
<a id="ad1685414ab5b9729175258024c1f034a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1685414ab5b9729175258024c1f034a">&#9670;&nbsp;</a></span>make_optional() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt;std::decay_t&lt;T&gt; &gt; bit::stl::make_optional </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an optional object from <code>value</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to construct the optional from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c586d69708cf2aa3d6196f5c38e5edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c586d69708cf2aa3d6196f5c38e5edd">&#9670;&nbsp;</a></span>make_optional() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt;T&gt; bit::stl::make_optional </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an optional object of type <code>T</code> from the given <code>args</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to construct </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args...</td><td>the arguments to pass to <code>T's</code> constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdcc7a61cae2e21593e248e3996eac0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcc7a61cae2e21593e248e3996eac0c">&#9670;&nbsp;</a></span>make_optional() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt;T&gt; bit::stl::make_optional </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; U &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an optional object of type <code>T</code> from the given <code>il</code> <code>args</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to construct </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>the initializer list to pass </td></tr>
    <tr><td class="paramname">args...</td><td>the arguments to pass to <code>T's</code> constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44311fa8af9c4066b4aff80158e37429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44311fa8af9c4066b4aff80158e37429">&#9670;&nbsp;</a></span>make_pointer_wrapper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/dde/classbit_1_1stl_1_1pointer__wrapper.html">pointer_wrapper</a>&lt;T&gt; bit::stl::make_pointer_wrapper </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a <a class="el" href="../../d6/dde/classbit_1_1stl_1_1pointer__wrapper.html" title="A wrapper type around a given type that allows it to be treated with pointer-semantics instead of ref...">pointer_wrapper</a> of the underlying type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args...</td><td>the arguments to forward </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f242f7df14fb4961730a553e96084b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f242f7df14fb4961730a553e96084b2">&#9670;&nbsp;</a></span>make_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d68/classbit_1_1stl_1_1range.html">range</a>&lt;I,S&gt; bit::stl::make_range </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>sentinel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a range from a given <code>iterator</code> <code>sentinel</code> pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>the beginning of a range </td></tr>
    <tr><td class="paramname">sentinel</td><td>the end of a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced range </dd></dl>

</div>
</div>
<a id="a10e28a7d1651dd558116d848caaab0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10e28a7d1651dd558116d848caaab0ef">&#9670;&nbsp;</a></span>make_reverse_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d68/classbit_1_1stl_1_1range.html">detail::reverse_range_t</a>&lt;Range&gt; bit::stl::make_reverse_range </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a reverse range from a given range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>the range to deduce </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced range </dd></dl>

</div>
</div>
<a id="a3858d10559ba8d9064205690c1e26ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3858d10559ba8d9064205690c1e26ea3">&#9670;&nbsp;</a></span>make_tuple_element_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../de/d9c/classbit_1_1stl_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt;N,Iterator&gt; bit::stl::make_tuple_element_iterator </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to type-deduce and make an iterator for iterating specific tuple elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tuple element iterator </dd></dl>

</div>
</div>
<a id="aeb836366eb9312a050e71090d0d0ab18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb836366eb9312a050e71090d0d0ab18">&#9670;&nbsp;</a></span>make_tuple_element_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename Iterator , typename Sentinel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d9/d68/classbit_1_1stl_1_1range.html">tuple_element_range</a>&lt;N,Iterator,Sentinel&gt; bit::stl::make_tuple_element_range </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sentinel&#160;</td>
          <td class="paramname"><em>sentinel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a range from a given <code>iterator</code> <code>sentinel</code> pair iterating values of a given tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>the beginning of a range </td></tr>
    <tr><td class="paramname">sentinel</td><td>the end of a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced tuple_element range </dd></dl>

</div>
</div>
<a id="a9755799c88fc44a9721b20f5f9ad2d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9755799c88fc44a9721b20f5f9ad2d26">&#9670;&nbsp;</a></span>make_tuple_element_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::stl::make_tuple_element_range </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> -&gt;  decltype(make_tuple_element_range&lt; N &gt;(r.begin(), r.end()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a tuple element range from a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced tuple_element range </dd></dl>

</div>
</div>
<a id="a31279bc7e0ea43b6d0815518eb4eb205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31279bc7e0ea43b6d0815518eb4eb205">&#9670;&nbsp;</a></span>make_unexpected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../dd/d45/classbit_1_1stl_1_1unexpected__type.html">unexpected_type</a>&lt;E&gt; bit::stl::make_unexpected </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes an unexpected type <code>E</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E</td><td>the unexpected type to make </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>the arguments to forward </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the unexpected type </dd></dl>

</div>
</div>
<a id="a643a6bd17072910d8f851d40eeababa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643a6bd17072910d8f851d40eeababa7">&#9670;&nbsp;</a></span>make_value_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../de/d9c/classbit_1_1stl_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt;1,Iterator&gt; bit::stl::make_value_iterator </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for making a tuple iterator that only iterates the second tuple element, which is the value in associative containers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tuple element iterator </dd></dl>

</div>
</div>
<a id="ad6cca0b51b9a9be22b42f7dcdef6aaaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6cca0b51b9a9be22b42f7dcdef6aaaf">&#9670;&nbsp;</a></span>make_value_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename Sentinel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::stl::make_value_range </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sentinel&#160;</td>
          <td class="paramname"><em>sentinel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="../../d9/d68/classbit_1_1stl_1_1range.html">range</a>&lt; <a class="el" href="../../de/d9c/classbit_1_1stl_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; 1, Iterator &gt;, <a class="el" href="../../de/d9c/classbit_1_1stl_1_1tuple__element__iterator.html">tuple_element_iterator</a>&lt; 1, Sentinel &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a range from a given <code>iterator</code> <code>sentinel</code> pair iterating the second value of a given tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>the beginning of a range </td></tr>
    <tr><td class="paramname">sentinel</td><td>the end of a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced tuple_element range </dd></dl>

</div>
</div>
<a id="a90b8bd09adc8ff6908217ee5b913628b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b8bd09adc8ff6908217ee5b913628b">&#9670;&nbsp;</a></span>make_value_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::stl::make_value_range </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> -&gt;  decltype(make_value_range(r.begin(), r.end()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a value range from another range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a value range </dd></dl>

</div>
</div>
<a id="a18841cb6f87b8d466adb47fee8d88c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18841cb6f87b8d466adb47fee8d88c02">&#9670;&nbsp;</a></span>make_zip_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range0 , typename... RangeN&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::stl::make_zip_range </td>
          <td>(</td>
          <td class="paramtype">Range0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>r0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="../../d9/d68/classbit_1_1stl_1_1range.html">range</a>&lt; <a class="el" href="../../d3/dc5/classbit_1_1stl_1_1zip__iterator.html">zip_iterator</a>&lt; decltype(r0.begin()), decltype(rn.begin())... &gt;, <a class="el" href="../../d3/dc5/classbit_1_1stl_1_1zip__iterator.html">zip_iterator</a>&lt; decltype(r0.end()), decltype(rn.end())... &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a zip range from a selection of zip iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r0</td><td>the first range entry </td></tr>
    <tr><td class="paramname">rn</td><td>the rest of the range entries </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced range </dd></dl>

</div>
</div>
<a id="ae180be04635d8455a78ecd80b67ffe55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae180be04635d8455a78ecd80b67ffe55">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html">source_location</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html">source_location</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines inequality between two source_locations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html" title="Source location is a small, immutable type used for representing where retrieving information about w...">source_location</a> on the left side of the equation </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html" title="Source location is a small, immutable type used for representing where retrieving information about w...">source_location</a> on the right side of the equation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> is not equal to <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a3f719bc2f88ec95bdce7ac3bddaca536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f719bc2f88ec95bdce7ac3bddaca536">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two tribooleans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left entry </td></tr>
    <tr><td class="paramname">rhs</td><td>the right entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> has the same state as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="af8cacd7e1ce32b5e367aba95145f0c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8cacd7e1ce32b5e367aba95145f0c87">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5853dc716058231d67db9de2a050a251">indeterminate_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two tribooleans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left entry </td></tr>
    <tr><td class="paramname">rhs</td><td>the right entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> has the same state as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="aea0377caf58e0deaa3a8b13d34c398e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0377caf58e0deaa3a8b13d34c398e3">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5853dc716058231d67db9de2a050a251">indeterminate_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two tribooleans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left entry </td></tr>
    <tr><td class="paramname">rhs</td><td>the right entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> has the same state as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a7369b94edb1aa30603f6a4295280f810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7369b94edb1aa30603f6a4295280f810">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs inequality operation on two optionals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>an optional object on the left side to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>an optional object on the right side to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If bool(lhs) != bool(rhs), returns true Otherwise, if bool(lhs) == false, returns false Otherwise, returns *lhs == *rhs </dd></dl>

</div>
</div>
<a id="a0ace58348d55a83f9d4b81df99724d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ace58348d55a83f9d4b81df99724d33">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the left and right lazy elements together for inequality, using the underlying type's operator!=. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ef95178467c3eb83c8c648eb062333b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef95178467c3eb83c8c648eb062333b">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::ptrdiff_t Extent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs inequality comparison between all entries in the span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left span to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>the right span to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if the spans contain the same elements in the same order </dd></dl>

</div>
</div>
<a id="a23e9db0b731c0f094b5fa4b5a248d46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e9db0b731c0f094b5fa4b5a248d46e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the left and right lazy elements together for inequality, using the underlying type's operator!=. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e3aa6b26006dfe792cf209e7705a192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3aa6b26006dfe792cf209e7705a192">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the left and right lazy elements together for inequality, using the underlying type's operator!=. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2bf027ebca228450fda5cef3c2c60d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf027ebca228450fda5cef3c2c60d3c">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares inequality between the two basic_string_views. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left string view </td></tr>
    <tr><td class="paramname">rhs</td><td>the right string view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two strings are different </dd></dl>

</div>
</div>
<a id="aaf3e384d5ee5018ce420f7282e1d6992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3e384d5ee5018ce420f7282e1d6992">&#9670;&nbsp;</a></span>operator<() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs less-than operation on two optionals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>an optional object on the left side to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>an optional object on the right side to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If bool(rhs) == false, returns false Otherwise, if bool(lhs) == false, returns true Otherwise, returns *lhs &lt; *rhs </dd></dl>

</div>
</div>
<a id="af144d9c063aae932355474287ad14759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af144d9c063aae932355474287ad14759">&#9670;&nbsp;</a></span>operator<() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::ptrdiff_t Extent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexographically compares all entries in the span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left span to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>the right span to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the left span is lexographically less than the right </dd></dl>

</div>
</div>
<a id="a2ec221617391931c78569a3d2702b288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec221617391931c78569a3d2702b288">&#9670;&nbsp;</a></span>operator<() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if <code>lhs</code> &lt; <code>rhs</code>, using the underlying type's <code>operator&lt;</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1aef677a777630f327620d039ec22bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1aef677a777630f327620d039ec22bd">&#9670;&nbsp;</a></span>operator<() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if <code>lhs</code> &lt; <code>rhs</code>, using the underlying type's <code>operator&lt;</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65343987a73506a66147635c970ce0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65343987a73506a66147635c970ce0af">&#9670;&nbsp;</a></span>operator<() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if <code>lhs</code> &lt; <code>rhs</code>, using the underlying type's <code>operator&lt;</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a415444efbcfeefad454cd010cc9b344f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415444efbcfeefad454cd010cc9b344f">&#9670;&nbsp;</a></span>operator<() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the left string is less than the right substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left string view </td></tr>
    <tr><td class="paramname">rhs</td><td>the right string view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the left string has a character less than the right string, or if the right string is shorter than the left string </dd></dl>

</div>
</div>
<a id="a1580085f3114393d66c277bc11cb5690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1580085f3114393d66c277bc11cb5690">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;CharT,Traits&gt;&amp; bit::stl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload for ostream output of <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html" title="A wrapper around non-owned strings. ">basic_string_view</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>The output stream to print to </td></tr>
    <tr><td class="paramname">str</td><td>the string to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the output stream </dd></dl>

</div>
</div>
<a id="adab66a890e7dea7249c4f81241f15753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab66a890e7dea7249c4f81241f15753">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs less-than or equal operation on two optionals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>an optional object on the left side to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>an optional object on the right side to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If bool(lhs) == false, returns true Otherwise, if bool(rhs) == false, returns false Otherwise, returns *lhs &lt;= *rhs </dd></dl>

</div>
</div>
<a id="acc3ac8246dbe309e18132145a226d5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3ac8246dbe309e18132145a226d5f9">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::ptrdiff_t Extent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexographically compares all entries in the span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left span to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>the right span to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the left span is lexographically less than or equal to the right entry </dd></dl>

</div>
</div>
<a id="a2694a1ebe40355527138a693adb98b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2694a1ebe40355527138a693adb98b3b">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if <code>lhs</code> &lt;= <code>rhs</code>, using the underlying type's <code>operator&lt;=</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbabcb48392e608812339f0f57526efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbabcb48392e608812339f0f57526efb">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if <code>lhs</code> &lt;= <code>rhs</code>, using the underlying type's <code>operator&lt;=</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92f0f2791bf66cf30bdf5311f48f6f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f0f2791bf66cf30bdf5311f48f6f3e">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if <code>lhs</code> &lt;= <code>rhs</code>, using the underlying type's <code>operator&lt;=</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa26180d86b4a63447cb01a783830c132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26180d86b4a63447cb01a783830c132">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a4f2a34d2c6d7bbb220c7d8ac2a79c458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2a34d2c6d7bbb220c7d8ac2a79c458">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html">source_location</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html">source_location</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines equality between two source_locations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html" title="Source location is a small, immutable type used for representing where retrieving information about w...">source_location</a> on the left side of the equation </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html" title="Source location is a small, immutable type used for representing where retrieving information about w...">source_location</a> on the right side of the equation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> is equal to <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a1f8dec5bd2fc486c8d2144b3d7f17943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8dec5bd2fc486c8d2144b3d7f17943">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two tribooleans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left entry </td></tr>
    <tr><td class="paramname">rhs</td><td>the right entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> has the same state as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a83a4151c0d15bef2c65b5d64a2ec2975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a4151c0d15bef2c65b5d64a2ec2975">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5853dc716058231d67db9de2a050a251">indeterminate_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two tribooleans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left entry </td></tr>
    <tr><td class="paramname">rhs</td><td>the right entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> has the same state as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a894b424c1fe9bf6f27b776ecefd8300f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894b424c1fe9bf6f27b776ecefd8300f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5853dc716058231d67db9de2a050a251">indeterminate_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two tribooleans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left entry </td></tr>
    <tr><td class="paramname">rhs</td><td>the right entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> has the same state as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="aaaaba5e942c77826b17b02c17b1b11de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaaba5e942c77826b17b02c17b1b11de">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs equality operation on two optionals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>an optional object on the left side to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>an optional object on the right side to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If bool(lhs) != bool(rhs), returns false Otherwise, if bool(lhs) == false, returns true Otherwise, returns *lhs == *rhs </dd></dl>

</div>
</div>
<a id="a69c2c4bcf46f871a44c4d39ae1f829c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c2c4bcf46f871a44c4d39ae1f829c4">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the left and right lazy elements together for equality, using the underlying type's operator==. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef7b385636356ef469ca965df7b6372c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef7b385636356ef469ca965df7b6372c">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the left and right lazy elements together for equality, using the underlying type's operator==. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa3a169fb3e7d89f16f12ea8d5ccd0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3a169fb3e7d89f16f12ea8d5ccd0a9">&#9670;&nbsp;</a></span>operator==() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the left and right lazy elements together for equality, using the underlying type's operator==. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a949bcb6cedbc08ec6aac45fc2ed17e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949bcb6cedbc08ec6aac45fc2ed17e51">&#9670;&nbsp;</a></span>operator==() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::ptrdiff_t Extent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs equality comparison between all entries in the span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left span to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>the right span to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the spans contain the same elements in the same order </dd></dl>

</div>
</div>
<a id="aba40e0a952f28127626caa2438700a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba40e0a952f28127626caa2438700a5c">&#9670;&nbsp;</a></span>operator==() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares equality between the two basic_string_views. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left string view </td></tr>
    <tr><td class="paramname">rhs</td><td>the right string view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two strings are the same </dd></dl>

</div>
</div>
<a id="a9fa00301df0b90006322ef8fd5fc4f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa00301df0b90006322ef8fd5fc4f7d">&#9670;&nbsp;</a></span>operator>() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs greater-than operation on two optionals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>an optional object on the left side to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>an optional object on the right side to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If bool(lhs) == false, returns false Otherwise, if bool(rhs) == false, returns true Otherwise, returns *lhs &gt; *rhs </dd></dl>

</div>
</div>
<a id="a46d826a3a556768ab643121194d3d5d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d826a3a556768ab643121194d3d5d3">&#9670;&nbsp;</a></span>operator>() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::ptrdiff_t Extent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexographically compares all entries in the span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left span to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>the right span to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the left span is lexographically greater than the right entry </dd></dl>

</div>
</div>
<a id="a746813e83ffff1853ff45291ea291a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746813e83ffff1853ff45291ea291a8b">&#9670;&nbsp;</a></span>operator>() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if <code>lhs</code> &gt; <code>rhs</code>, using the underlying type's <code>operator&gt;</code> </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f76db3bf68fa12d31cefd4888223bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f76db3bf68fa12d31cefd4888223bf9">&#9670;&nbsp;</a></span>operator>() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if <code>lhs</code> &gt; <code>rhs</code>, using the underlying type's <code>operator&gt;</code> </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a775f362ae0a51d2f0125e1168a2fc590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775f362ae0a51d2f0125e1168a2fc590">&#9670;&nbsp;</a></span>operator>() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if <code>lhs</code> &gt; <code>rhs</code>, using the underlying type's <code>operator&gt;</code> </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69b91bebb63c963188f090691677e815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b91bebb63c963188f090691677e815">&#9670;&nbsp;</a></span>operator>() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aba083b0665196f2dab5de18013deed76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba083b0665196f2dab5de18013deed76">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs greater-than or equal operation on two optionals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>an optional object on the left side to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>an optional object on the right side to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If bool(rhs) == false, returns true Otherwise, if bool(lhs) == false, returns false Otherwise, returns *lhs &lt;= *rhs </dd></dl>

</div>
</div>
<a id="a4850b6a62191725450ad5a4c37dfdbcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4850b6a62191725450ad5a4c37dfdbcd">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::ptrdiff_t Extent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexographically compares all entries in the span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left span to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>the right span to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the left span is lexographically greater than or equal to the right entry </dd></dl>

</div>
</div>
<a id="a7c8e6565cc41cde9536df9c09e51d778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8e6565cc41cde9536df9c09e51d778">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if <code>lhs</code> &gt;= <code>rhs</code>, using the underlying type's <code>operator&gt;=</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a436993f5969646f1923b2f6f6f8e8c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436993f5969646f1923b2f6f6f8e8c11">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if <code>lhs</code> &gt;= <code>rhs</code>, using the underlying type's <code>operator&gt;=</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a001b72215d0b5e3721b12564542d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a001b72215d0b5e3721b12564542d95">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if <code>lhs</code> &gt;= <code>rhs</code>, using the underlying type's <code>operator&gt;=</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab692e38a5d9027b524c7532b189d8ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab692e38a5d9027b524c7532b189d8ff1">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a422888e8bf759070c079f4ae2b699a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422888e8bf759070c079f4ae2b699a3d">&#9670;&nbsp;</a></span>set_assert_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">assert_handler_t bit::stl::set_assert_handler </td>
          <td>(</td>
          <td class="paramtype">assert_handler_t&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the assertion handler, returning the previous assertion handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the function to handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the old handler </dd></dl>

</div>
</div>
<a id="ac1aac54f3c941e37118dd7091628d2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1aac54f3c941e37118dd7091628d2b8">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bit::stl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html">observer_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the <a class="el" href="../../de/ddb/classbit_1_1stl_1_1observer__ptr.html" title="A lightweight wrapper around a pointer type. ">observer_ptr</a> <code>lhs</code> with <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left one to swap </td></tr>
    <tr><td class="paramname">rhs</td><td>the right one to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88c1f4f2eb32c378cd04c5fb57cf7329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c1f4f2eb32c378cd04c5fb57cf7329">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bit::stl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html">offset_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the instances of two <a class="el" href="../../d8/d81/classbit_1_1stl_1_1offset__ptr.html" title="An offset pointer based on boost::offset_ptr. ">offset_ptr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left pointer to swap </td></tr>
    <tr><td class="paramname">rhs</td><td>the right pointer to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1108cce7da03dc43b2e4db96604ccca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1108cce7da03dc43b2e4db96604ccca">&#9670;&nbsp;</a></span>swap() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void bit::stl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d6a/classbit_1_1stl_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d6a/classbit_1_1stl_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the two propagate_consts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left entry to swap </td></tr>
    <tr><td class="paramname">rhs</td><td>the right entry to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86bf67c78fb7632490d91617b43f2400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86bf67c78fb7632490d91617b43f2400">&#9670;&nbsp;</a></span>swap() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bit::stl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d6a/classbit_1_1stl_1_1fat__ptr.html">fat_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d6a/classbit_1_1stl_1_1fat__ptr.html">fat_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the instances of two fat_ptrs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left pointer to swap </td></tr>
    <tr><td class="paramname">rhs</td><td>the right pointer to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80c74ab0d9ab7114d1c9954fdec69491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c74ab0d9ab7114d1c9954fdec69491">&#9670;&nbsp;</a></span>swap() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void bit::stl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps <code>lhs</code> with <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left array view </td></tr>
    <tr><td class="paramname">rhs</td><td>the right array view </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae65508369ae89754862b70e7b4b93542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae65508369ae89754862b70e7b4b93542">&#9670;&nbsp;</a></span>swap() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bit::stl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d8c/classbit_1_1stl_1_1clone__ptr.html">clone_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/d8c/classbit_1_1stl_1_1clone__ptr.html">clone_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of two clone_ptrs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left <a class="el" href="../../d1/d8c/classbit_1_1stl_1_1clone__ptr.html" title="clone_ptr is a smart pointer that owns and manages another object through a pointer and disposes of t...">clone_ptr</a> </td></tr>
    <tr><td class="paramname">rhs</td><td>the right <a class="el" href="../../d1/d8c/classbit_1_1stl_1_1clone__ptr.html" title="clone_ptr is a smart pointer that owns and manages another object through a pointer and disposes of t...">clone_ptr</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7870c066ad0f83c5a615058855cf99ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7870c066ad0f83c5a615058855cf99ab">&#9670;&nbsp;</a></span>swap() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bit::stl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html">compressed_pair</a>&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of two compressed_pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left <a class="el" href="../../d0/d21/classbit_1_1stl_1_1compressed__pair.html" title="compressed_pair is a struct template that provides a way to store two heterogeneous objects as a sing...">compressed_pair</a> to swap </td></tr>
    <tr><td class="paramname">rhs</td><td>the right compressed pair to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e2212f7f9bb1f2ffa862da0cbcd2301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2212f7f9bb1f2ffa862da0cbcd2301">&#9670;&nbsp;</a></span>swap() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bit::stl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of the lazy from <code>lhs</code> and <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left lazy to swap </td></tr>
    <tr><td class="paramname">rhs</td><td>the right lazy to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39fc15967879a2d062e81cf59e4b80c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39fc15967879a2d062e81cf59e4b80c5">&#9670;&nbsp;</a></span>swap() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bit::stl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps <code>lhs</code> and <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left optional to swap </td></tr>
    <tr><td class="paramname">rhs</td><td>the right optional to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af61f3c4de60623e376e8625aaeec2e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61f3c4de60623e376e8625aaeec2e8d">&#9670;&nbsp;</a></span>throwing_assert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bit::stl::throwing_assert </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html">source_location</a>&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An exception-throwing assert handler. Throws an <a class="el" href="../../d5/de8/classbit_1_1stl_1_1assertion__failure.html" title="An exception thrown from assertion failures when BIT_COMPILER_EXCEPTIONS_ENABLED is defined...">assertion_failure</a> exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>the message for the assertion </td></tr>
    <tr><td class="paramname">source</td><td>the source of the assertion </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9807ce838e4fd230b03f9796f2203888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9807ce838e4fd230b03f9796f2203888">&#9670;&nbsp;</a></span>to_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uintptr_t bit::stl::to_address </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a pointer <code>ptr</code> into an integral type representing the address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer to convert to an integral value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the numeric address of the given pointer </dd></dl>

</div>
</div>
<a id="a0c54cd7406cc5388e67323491e900826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c54cd7406cc5388e67323491e900826">&#9670;&nbsp;</a></span>to_array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt;T,N&gt; bit::stl::to_array </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility to convert raw arrays to std::array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>a lvalue reference to an array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the std::array </dd></dl>

</div>
</div>
<a id="a966bc186dbddc974625ca051e42d2aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a966bc186dbddc974625ca051e42d2aed">&#9670;&nbsp;</a></span>to_array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt;T,N&gt; bit::stl::to_array </td>
          <td>(</td>
          <td class="paramtype">T(&amp;&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility to convert raw arrays to std::array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>a rvalue reference to an array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the std::array </dd></dl>

</div>
</div>
<a id="a5ceda0466f45a09b16591ccb2de29ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ceda0466f45a09b16591ccb2de29ab4">&#9670;&nbsp;</a></span>uninitialized_construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bit::stl::uninitialized_construct </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an instance of type <code>T</code> with the given <code>args</code> at the memory addresses in the given range [<code>first</code>, <code>last</code> ) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the start of the range of the elements to copy </td></tr>
    <tr><td class="paramname">last</td><td>the end of the range of the elements to copy </td></tr>
    <tr><td class="paramname">args...</td><td>The arguments to supply to the </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d0dcea6d5a9e100bea41a7fdc6ef7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0dcea6d5a9e100bea41a7fdc6ef7d2">&#9670;&nbsp;</a></span>uninitialized_construct_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* bit::stl::uninitialized_construct_at </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an instance of type <code>T</code> with the given <code>args</code> at the memory location specified in <code>ptr</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The memory location to construct into </td></tr>
    <tr><td class="paramname">args...</td><td>The arguments to supply to T's constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the initialized memory (cast of <code>ptr</code>) </dd></dl>

</div>
</div>
<a id="a504a3790a931e2137cecd7bc9f53deb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504a3790a931e2137cecd7bc9f53deb2">&#9670;&nbsp;</a></span>uninitialized_construct_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename Size , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator bit::stl::uninitialized_construct_n </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Size&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an instance of type <code>T</code> with the given <code>args</code> at the memory addresses in the given range [<code>first</code>, <code>first</code> + <code>n</code> ) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the start of the range of the elements to copy </td></tr>
    <tr><td class="paramname">n</td><td>the number of entries to construct </td></tr>
    <tr><td class="paramname">args...</td><td>The arguments to supply to the </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada62bae66a9ed451d9d7078146d9a8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada62bae66a9ed451d9d7078146d9a8b1">&#9670;&nbsp;</a></span>uninitialized_copy_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* bit::stl::uninitialized_copy_at </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructs an instance of type <code>T</code> in the given memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The memory location to construct into </td></tr>
    <tr><td class="paramname">other</td><td>The instance to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the initialized memory (cast of <code>ptr</code>) </dd></dl>

</div>
</div>
<a id="a29c81704abd3426d4a4f8d644bc9cca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c81704abd3426d4a4f8d644bc9cca9">&#9670;&nbsp;</a></span>uninitialized_default_construct_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* bit::stl::uninitialized_default_construct_at </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructs an instance of type <code>T</code> in the given memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The memory location to construct into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the initialized memory (cast of <code>ptr</code>) </dd></dl>

</div>
</div>
<a id="abc02d5f264a6272ee144f7d279f6cedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc02d5f264a6272ee144f7d279f6cedc">&#9670;&nbsp;</a></span>uninitialized_move_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* bit::stl::uninitialized_move_at </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructs an instance of type <code>T</code> in the given memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The memory location to construct into </td></tr>
    <tr><td class="paramname">other</td><td>The instance to move </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the initialized memory (cast of <code>ptr</code>) </dd></dl>

</div>
</div>
<a id="a24c4467d16ff80fbabb5ac8bb35f8975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c4467d16ff80fbabb5ac8bb35f8975">&#9670;&nbsp;</a></span>uninitialized_tuple_construct_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* bit::stl::uninitialized_tuple_construct_at </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an instance of type <code>T</code> with the given <code>tuple</code> at the memory location specified in <code>ptr</code>. </p>
<p>This forwards the arguments from the <code>tuple</code> to the constructor of T, as if by calling make_from_tuple</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The memory location to construct into </td></tr>
    <tr><td class="paramname">tuple</td><td>The tuple containing arguments to forward to T </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer ot the initialzied memory (cast of <code>ptr</code>) </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ada43fd75f18beefb9ea467bf2cad47d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada43fd75f18beefb9ea467bf2cad47d4">&#9670;&nbsp;</a></span>bool_constant_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool B&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::bool_constant_v = <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ab55b248051d5393fe10e6ffe1f7b2143">bool_constant</a>&lt;B&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience template variable to extract bool_constant::value. </p>
<p>This is always the same as the template variable (trivial) </p>

<p class="definition">Definition at line <a class="el" href="../../d6/dfd/bool__constant_8hpp_source.html#l00028">28</a> of file <a class="el" href="../../d6/dfd/bool__constant_8hpp_source.html">bool_constant.hpp</a>.</p>

</div>
</div>
<a id="a885977edf1cfbccd5de4978c99432da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885977edf1cfbccd5de4978c99432da4">&#9670;&nbsp;</a></span>size_constant_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::size_constant_v = <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a618d89ada20b451c43bf19ab9580409e">size_constant</a>&lt;Size&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience template variable to extract size_constant::value. </p>
<p>This is always the same as the template variable (trivial) </p>

<p class="definition">Definition at line <a class="el" href="../../de/dcd/size__constant_8hpp_source.html#l00031">31</a> of file <a class="el" href="../../de/dcd/size__constant_8hpp_source.html">size_constant.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
