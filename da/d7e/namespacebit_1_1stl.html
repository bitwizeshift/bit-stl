<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bit::stl: bit::stl Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">bit::stl
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dd/d9f/namespacebit.html">bit</a></li><li class="navelem"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html">stl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">bit::stl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The standard namespace for this project.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:d4/dc0/namespacebit_1_1stl_1_1casts"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dc0/namespacebit_1_1stl_1_1casts.html">casts</a></td></tr>
<tr class="memdesc:d4/dc0/namespacebit_1_1stl_1_1casts"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline namespace for managing cast utilities. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d3/d66/namespacebit_1_1stl_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d66/namespacebit_1_1stl_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:d3/d66/namespacebit_1_1stl_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private namespace for managing implementation-details within headers. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d7/dd7/namespacebit_1_1stl_1_1enum__ops"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dd7/namespacebit_1_1stl_1_1enum__ops.html">enum_ops</a></td></tr>
<tr class="memdesc:d7/dd7/namespacebit_1_1stl_1_1enum__ops"><td class="mdescLeft">&#160;</td><td class="mdescRight">This namespace introduces bitwise operations to any enums that specialize <code><a class="el" href="../../d7/d4c/structbit_1_1stl_1_1is__enum__bitmask.html" title="Type-trait to determine whether a type is an enum_bitmask. ">is_enum_bitmask</a></code>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:db/de3/namespacebit_1_1stl_1_1literals"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/de3/namespacebit_1_1stl_1_1literals.html">literals</a></td></tr>
<tr class="memdesc:db/de3/namespacebit_1_1stl_1_1literals"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline namespace for managing literal operators. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An immutable wrapper around non-owned contiguous data.  <a href="../../da/dcc/classbit_1_1stl_1_1array__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de8/classbit_1_1stl_1_1assertion__failure.html">assertion_failure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown from assertion failures when BIT_COMPILER_EXCEPTIONS_ENABLED is defined.  <a href="../../d5/de8/classbit_1_1stl_1_1assertion__failure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/da0/classbit_1_1stl_1_1bad__enum__cast.html">bad_enum_cast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception of this type is thrown when an enum_cast to a string fails with an invalid serialization, or when an enum value is outside of range of a string.  <a href="../../d5/da0/classbit_1_1stl_1_1bad__enum__cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d2f/classbit_1_1stl_1_1bad__expected__access.html">bad_expected_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception indicating a bad access was attempted for an expected type.  <a href="../../d2/d2f/classbit_1_1stl_1_1bad__expected__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d2f/structbit_1_1stl_1_1bad__narrow__cast.html">bad_narrow_cast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception for failed narrow_casts.  <a href="../../d0/d2f/structbit_1_1stl_1_1bad__narrow__cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dee/classbit_1_1stl_1_1bad__optional__access.html">bad_optional_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown when an optional is attempted to be accessed while not containing a value.  <a href="../../dc/dee/classbit_1_1stl_1_1bad__optional__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd0/structbit_1_1stl_1_1bad__pointer__cast.html">bad_pointer_cast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception for failed pointer cast.  <a href="../../d3/dd0/structbit_1_1stl_1_1bad__pointer__cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html" title="The basic_hashed_string is a wrapper around an owning basic_string with the hash. ...">basic_hashed_string</a> is a wrapper around an owning basic_string with the hash.  <a href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html" title="The basic_hashed_string_view is a compile-time hashed wrapper around a non-owning string (basic_strin...">basic_hashed_string_view</a> is a compile-time hashed wrapper around a non-owning string (<a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html" title="A wrapper around non-owned strings. ">basic_string_view</a>).  <a href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/de7/classbit_1_1stl_1_1basic__string__span.html">basic_string_span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A light-weight non-owning wrapper around strings.  <a href="../../db/de7/classbit_1_1stl_1_1basic__string__span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d50/classbit_1_1stl_1_1basic__string__tokenizer.html">basic_string_tokenizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tokenizer class for strings.  <a href="../../d3/d50/classbit_1_1stl_1_1basic__string__tokenizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around non-owned strings.  <a href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d92/classbit_1_1stl_1_1basic__zstring__span.html">basic_zstring_span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A light-weight non-owning wrapper around strings.  <a href="../../dd/d92/classbit_1_1stl_1_1basic__zstring__span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d16/classbit_1_1stl_1_1basic__zstring__view.html">basic_zstring_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around non-owned zero-terminated strings.  <a href="../../d6/d16/classbit_1_1stl_1_1basic__zstring__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dfc/classbit_1_1stl_1_1checked.html">checked</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A checked type is a wrapper around an error or a value type.  <a href="../../db/dfc/classbit_1_1stl_1_1checked.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d1c/classbit_1_1stl_1_1circular__array.html">circular_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A circular buffer that uses an array for storage.  <a href="../../d8/d1c/classbit_1_1stl_1_1circular__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is an implementation of a non-owning circular buffer.  <a href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d53/classbit_1_1stl_1_1circular__deque.html">circular_deque</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A circular buffer with a deque API.  <a href="../../d8/d53/classbit_1_1stl_1_1circular__deque.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfe/classbit_1_1stl_1_1circular__queue.html">circular_queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A circular buffer with a queue API.  <a href="../../dc/dfe/classbit_1_1stl_1_1circular__queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db2/structbit_1_1stl_1_1const__type__wrapper.html">const_type_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor tag used to differentiate const type pointers from fixed known type arrays at compile time. (e.g. "const T* p" from "const T (&amp;p)[N]")  <a href="../../d4/db2/structbit_1_1stl_1_1const__type__wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dd/d27/structbit_1_1stl_1_1ctor__do__not__convert__tag"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#dd/d27/structbit_1_1stl_1_1ctor__do__not__convert__tag">ctor_do_not_convert_tag</a></td></tr>
<tr class="memdesc:dd/d27/structbit_1_1stl_1_1ctor__do__not__convert__tag"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor tag used to disable automatic internal conversion.  <a href="../../da/d7e/namespacebit_1_1stl.html#dd/d27/structbit_1_1stl_1_1ctor__do__not__convert__tag">More...</a><br /></td></tr>
<tr class="separator:dd/d27/structbit_1_1stl_1_1ctor__do__not__convert__tag"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d4/dd2/structbit_1_1stl_1_1ctor__va__args__tag"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d4/dd2/structbit_1_1stl_1_1ctor__va__args__tag">ctor_va_args_tag</a></td></tr>
<tr class="memdesc:d4/dd2/structbit_1_1stl_1_1ctor__va__args__tag"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor tag used as a placeholder to not conflict with variadic constructors.  <a href="../../da/d7e/namespacebit_1_1stl.html#d4/dd2/structbit_1_1stl_1_1ctor__va__args__tag">More...</a><br /></td></tr>
<tr class="separator:d4/dd2/structbit_1_1stl_1_1ctor__va__args__tag"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d4/d21/structbit_1_1stl_1_1ctor__zero__out__tag"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d4/d21/structbit_1_1stl_1_1ctor__zero__out__tag">ctor_zero_out_tag</a></td></tr>
<tr class="memdesc:d4/d21/structbit_1_1stl_1_1ctor__zero__out__tag"><td class="mdescLeft">&#160;</td><td class="mdescRight">For specified string types.  <a href="../../da/d7e/namespacebit_1_1stl.html#d4/d21/structbit_1_1stl_1_1ctor__zero__out__tag">More...</a><br /></td></tr>
<tr class="separator:d4/d21/structbit_1_1stl_1_1ctor__zero__out__tag"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dcd/classbit_1_1stl_1_1data__watcher.html">data_watcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper class around fundamental types that causes a breakpoint any time the variable is set.  <a href="../../d8/dcd/classbit_1_1stl_1_1data__watcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d6/d7e/classbit_1_1stl_1_1delegate"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a></td></tr>
<tr class="memdesc:d6/d7e/classbit_1_1stl_1_1delegate"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is for a lightweight way of managing function callbacks without requiring heap allocations.  <a href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">More...</a><br /></td></tr>
<tr class="separator:d6/d7e/classbit_1_1stl_1_1delegate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de5/classbit_1_1stl_1_1delegate_3_01_r_07_types_8_8_8_08_4.html">delegate&lt; R(Types...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d36/classbit_1_1stl_1_1enum__range.html">enum_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range for enumerable values.  <a href="../../d5/d36/classbit_1_1stl_1_1enum__range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d1b/structbit_1_1stl_1_1enum__traits.html">enum_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits for an enum.  <a href="../../d9/d1b/structbit_1_1stl_1_1enum__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dbd/classbit_1_1stl_1_1error__code.html">error_code</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A moveable error mechanism.  <a href="../../db/dbd/classbit_1_1stl_1_1error__code.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An expected type is a combination of an optional and an exception type.  <a href="../../dc/da7/classbit_1_1stl_1_1expected.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d37/classbit_1_1stl_1_1expected_3_01void_01_4.html">expected&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dc4/classbit_1_1stl_1_1final__act.html">final_act</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class leverages RAII to perform cleanup actions at the end of a scope.  <a href="../../db/dc4/classbit_1_1stl_1_1final__act.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/deb/structbit_1_1stl_1_1hash.html">hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash struct that satisfies the requirements of <code>std::hash</code>, but is implemented in terms of hash_value to allow for easy ADL overloads and type-querying.  <a href="../../dd/deb/structbit_1_1stl_1_1hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d57/structbit_1_1stl_1_1in__place__tag.html">in_place_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../dd/d57/structbit_1_1stl_1_1in__place__tag.html" title="in_place_tag is an empty struct type used as the return types of the in_place functions for disambigu...">in_place_tag</a> is an empty struct type used as the return types of the in_place functions for disambiguation.  <a href="../../dd/d57/structbit_1_1stl_1_1in__place__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d40/structbit_1_1stl_1_1insensitive__char__traits.html">insensitive_char_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Char traits to allow case-insensitive comparisons for strings.  <a href="../../da/d40/structbit_1_1stl_1_1insensitive__char__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d20/structbit_1_1stl_1_1is__dynamic__span.html">is_dynamic_span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the given type a dynamic span?  <a href="../../d6/d20/structbit_1_1stl_1_1is__dynamic__span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d5b/structbit_1_1stl_1_1is__dynamic__span_3_01span_3_01_t_00_01dynamic__extent_01_4_01_4.html">is_dynamic_span&lt; span&lt; T, dynamic_extent &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d4c/structbit_1_1stl_1_1is__enum__bitmask.html">is_enum_bitmask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine whether a type is an enum_bitmask.  <a href="../../d7/d4c/structbit_1_1stl_1_1is__enum__bitmask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd8/structbit_1_1stl_1_1is__in__place.html">is_in_place</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-trait to determine if the type is an in_place type.  <a href="../../d9/dd8/structbit_1_1stl_1_1is__in__place.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d33/structbit_1_1stl_1_1is__in__place_3_01in__place__index__t_3_01_i_01_4_01_4.html">is_in_place&lt; in_place_index_t&lt; I &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dc3/structbit_1_1stl_1_1is__in__place_3_01in__place__t_01_4.html">is_in_place&lt; in_place_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d12/structbit_1_1stl_1_1is__in__place_3_01in__place__type__t_3_01_t_01_4_01_4.html">is_in_place&lt; in_place_type_t&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dc9/structbit_1_1stl_1_1is__span.html">is_span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the given type an span ?  <a href="../../d3/dc9/structbit_1_1stl_1_1is__span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d34/structbit_1_1stl_1_1is__span_3_01span_3_01_t_00_01_n_01_4_01_4.html">is_span&lt; span&lt; T, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazy class used for lazy-loading any type.  <a href="../../d0/dbb/classbit_1_1stl_1_1lazy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d23/classbit_1_1stl_1_1map__view.html">map_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight, non-owning wrapper around map operations.  <a href="../../d5/d23/classbit_1_1stl_1_1map__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type represents null optional value.  <a href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class template optional manages an optional contained value, i.e. a value that may or may not be present.  <a href="../../d0/d1d/classbit_1_1stl_1_1optional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dde/classbit_1_1stl_1_1pointer__wrapper.html">pointer_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper type around a given type that allows it to be treated with pointer-semantics instead of reference-semantics.  <a href="../../d6/dde/classbit_1_1stl_1_1pointer__wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d95/classbit_1_1stl_1_1set__view.html">set_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight, non-owning wrapper around set operations.  <a href="../../d0/d95/classbit_1_1stl_1_1set__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html">source_location</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Source location is a small, immutable type used for representing where retrieving information about where this type is constructed.  <a href="../../d6/d2f/classbit_1_1stl_1_1source__location.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A light-weight non-owning wrapper around contiguous memory.  <a href="../../d5/d30/classbit_1_1stl_1_1span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d61/structbit_1_1stl_1_1static__divisible__by__range.html">static_divisible_by_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/ddd/structbit_1_1stl_1_1static__divisible__by__range_3_01v_00_01b_00_01b_01_4.html">static_divisible_by_range&lt; v, b, b &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d49/structbit_1_1stl_1_1static__gcd.html">static_gcd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the greatest common denominator of <code>a</code> and <code>b</code> The result is aliased as <em>static_gcd::value</em>.  <a href="../../de/d49/structbit_1_1stl_1_1static__gcd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/da4/structbit_1_1stl_1_1static__gcd_3_010_00_01b_01_4.html">static_gcd&lt; 0, b &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d72/structbit_1_1stl_1_1static__is__prime.html">static_is_prime</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/db3/structbit_1_1stl_1_1static__is__prime_3_010_01_4.html">static_is_prime&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dce/structbit_1_1stl_1_1static__is__prime_3_011_01_4.html">static_is_prime&lt; 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc9/structbit_1_1stl_1_1static__is__prime_3_012_01_4.html">static_is_prime&lt; 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d54/structbit_1_1stl_1_1static__lcm.html">static_lcm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de7/structbit_1_1stl_1_1static__square__sum__of__range.html">static_square_sum_of_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dde/structbit_1_1stl_1_1static__sum__of__range.html">static_sum_of_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a 3-state boolean type that introduces 'indeterminate' as the third state.  <a href="../../d0/dc9/classbit_1_1stl_1_1tribool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dd/d73/classbit_1_1stl_1_1underlying__container__type"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#dd/d73/classbit_1_1stl_1_1underlying__container__type">underlying_container_type</a></td></tr>
<tr class="separator:dd/d73/classbit_1_1stl_1_1underlying__container__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper type to represent universally unique identifiers.  <a href="../../d5/d75/classbit_1_1stl_1_1uuid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a16c47b035ca6385a8da51928ceb06a80"><td class="memTemplParams" colspan="2"><a id="a16c47b035ca6385a8da51928ceb06a80"></a>
template&lt;typename Enum &gt; </td></tr>
<tr class="memitem:a16c47b035ca6385a8da51928ceb06a80"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a16c47b035ca6385a8da51928ceb06a80">enum_iterator</a> = pointer_iterator&lt; const Enum *, Enum &gt;</td></tr>
<tr class="memdesc:a16c47b035ca6385a8da51928ceb06a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for iterating an <a class="el" href="../../d5/d36/classbit_1_1stl_1_1enum__range.html" title="A range for enumerable values. ">enum_range</a>. <br /></td></tr>
<tr class="separator:a16c47b035ca6385a8da51928ceb06a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02537ee2880264a40fcfe4f16f73db9a"><td class="memItemLeft" align="right" valign="top"><a id="a02537ee2880264a40fcfe4f16f73db9a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hashed_string</b> = <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; char &gt;</td></tr>
<tr class="separator:a02537ee2880264a40fcfe4f16f73db9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c8fdf0a72af9c6366a44d80b07df71"><td class="memItemLeft" align="right" valign="top"><a id="a27c8fdf0a72af9c6366a44d80b07df71"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hashed_wstring</b> = <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; wchar_t &gt;</td></tr>
<tr class="separator:a27c8fdf0a72af9c6366a44d80b07df71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b943df91261c5c3996892fd07c4a13e"><td class="memItemLeft" align="right" valign="top"><a id="a1b943df91261c5c3996892fd07c4a13e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hashed_u16string</b> = <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; char16_t &gt;</td></tr>
<tr class="separator:a1b943df91261c5c3996892fd07c4a13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3229d87da205f5801832a22dc755b6b"><td class="memItemLeft" align="right" valign="top"><a id="ad3229d87da205f5801832a22dc755b6b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hashed_u32string</b> = <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; char32_t &gt;</td></tr>
<tr class="separator:ad3229d87da205f5801832a22dc755b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ea9e337581daaeb1764a7d34843c37"><td class="memItemLeft" align="right" valign="top"><a id="ad8ea9e337581daaeb1764a7d34843c37"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hashed_string_view</b> = <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; char &gt;</td></tr>
<tr class="separator:ad8ea9e337581daaeb1764a7d34843c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f13560e63d464a61be82ed3ac4d43c"><td class="memItemLeft" align="right" valign="top"><a id="ab3f13560e63d464a61be82ed3ac4d43c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hashed_wstring_view</b> = <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; wchar_t &gt;</td></tr>
<tr class="separator:ab3f13560e63d464a61be82ed3ac4d43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3286dae509aed68b4fe03ad6c6b9a24d"><td class="memItemLeft" align="right" valign="top"><a id="a3286dae509aed68b4fe03ad6c6b9a24d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hashed_u16string_view</b> = <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; char16_t &gt;</td></tr>
<tr class="separator:a3286dae509aed68b4fe03ad6c6b9a24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dceab8b6638fba97f238aac1fb661ca"><td class="memItemLeft" align="right" valign="top"><a id="a4dceab8b6638fba97f238aac1fb661ca"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hashed_u32string_view</b> = <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; char32_t &gt;</td></tr>
<tr class="separator:a4dceab8b6638fba97f238aac1fb661ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad243489c846cede444d03231400b6666"><td class="memTemplParams" colspan="2"><a id="ad243489c846cede444d03231400b6666"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad243489c846cede444d03231400b6666"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ad243489c846cede444d03231400b6666">owner</a> = T</td></tr>
<tr class="memdesc:ad243489c846cede444d03231400b6666"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer that represents ownership. <br /></td></tr>
<tr class="separator:ad243489c846cede444d03231400b6666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2379f4e27b53ecf7d9ee5bc39374a4ae"><td class="memTemplParams" colspan="2"><a id="a2379f4e27b53ecf7d9ee5bc39374a4ae"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a2379f4e27b53ecf7d9ee5bc39374a4ae"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a2379f4e27b53ecf7d9ee5bc39374a4ae">array_ref_t</a> = T(&amp;)[N]</td></tr>
<tr class="memdesc:a2379f4e27b53ecf7d9ee5bc39374a4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for lvalue-references to an array of N entries. <br /></td></tr>
<tr class="separator:a2379f4e27b53ecf7d9ee5bc39374a4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c70c898cbadfb2e44ee4f9e8230b98d"><td class="memTemplParams" colspan="2"><a id="a8c70c898cbadfb2e44ee4f9e8230b98d"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a8c70c898cbadfb2e44ee4f9e8230b98d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a8c70c898cbadfb2e44ee4f9e8230b98d">array_rref_t</a> = T(&amp;&amp;)[N]</td></tr>
<tr class="memdesc:a8c70c898cbadfb2e44ee4f9e8230b98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for rvalue-references to an array of N entries. <br /></td></tr>
<tr class="separator:a8c70c898cbadfb2e44ee4f9e8230b98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf455f79e68ed45d131623ae84329b2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R &gt; </td></tr>
<tr class="memitem:aacf455f79e68ed45d131623ae84329b2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aacf455f79e68ed45d131623ae84329b2">member_t</a> = R T::*</td></tr>
<tr class="memdesc:aacf455f79e68ed45d131623ae84329b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type alias for member pointers to make it more readable.  <a href="#aacf455f79e68ed45d131623ae84329b2">More...</a><br /></td></tr>
<tr class="separator:aacf455f79e68ed45d131623ae84329b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6a691794dcbf6afcdeba00278da3d5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R &gt; </td></tr>
<tr class="memitem:a3c6a691794dcbf6afcdeba00278da3d5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3c6a691794dcbf6afcdeba00278da3d5">member_function_t</a> = typename detail::member_function_t&lt; T, R &gt;::type</td></tr>
<tr class="memdesc:a3c6a691794dcbf6afcdeba00278da3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type alias for member function pointers to make it more readable.  <a href="#a3c6a691794dcbf6afcdeba00278da3d5">More...</a><br /></td></tr>
<tr class="separator:a3c6a691794dcbf6afcdeba00278da3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f679456d2b3cd6f3f65577718d97c79"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a8f679456d2b3cd6f3f65577718d97c79"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a8f679456d2b3cd6f3f65577718d97c79">function_t</a> = typename detail::function_t&lt; Fn &gt;::type</td></tr>
<tr class="memdesc:a8f679456d2b3cd6f3f65577718d97c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type alias for function pointers to make it more readable.  <a href="#a8f679456d2b3cd6f3f65577718d97c79">More...</a><br /></td></tr>
<tr class="separator:a8f679456d2b3cd6f3f65577718d97c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8390303a8a801dece9d6fede385cdec0"><td class="memItemLeft" align="right" valign="top"><a id="a8390303a8a801dece9d6fede385cdec0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a8390303a8a801dece9d6fede385cdec0">word</a> = int</td></tr>
<tr class="memdesc:a8390303a8a801dece9d6fede385cdec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed instruction-sized integer (Word) <br /></td></tr>
<tr class="separator:a8390303a8a801dece9d6fede385cdec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3c962cbbe823654a217c9c7619557f"><td class="memItemLeft" align="right" valign="top"><a id="adb3c962cbbe823654a217c9c7619557f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#adb3c962cbbe823654a217c9c7619557f">uword</a> = unsigned int</td></tr>
<tr class="memdesc:adb3c962cbbe823654a217c9c7619557f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned instruction-sized integer (Word) <br /></td></tr>
<tr class="separator:adb3c962cbbe823654a217c9c7619557f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609b8b83a65779bf425451da2c931bc3"><td class="memItemLeft" align="right" valign="top"><a id="a609b8b83a65779bf425451da2c931bc3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a609b8b83a65779bf425451da2c931bc3">uchar</a> = unsigned char</td></tr>
<tr class="memdesc:a609b8b83a65779bf425451da2c931bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned char type. <br /></td></tr>
<tr class="separator:a609b8b83a65779bf425451da2c931bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d16b03bce173a83cd4ac92ea2a0eeb"><td class="memItemLeft" align="right" valign="top"><a id="ae0d16b03bce173a83cd4ac92ea2a0eeb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ae0d16b03bce173a83cd4ac92ea2a0eeb">ushort</a> = unsigned short</td></tr>
<tr class="memdesc:ae0d16b03bce173a83cd4ac92ea2a0eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned short type. <br /></td></tr>
<tr class="separator:ae0d16b03bce173a83cd4ac92ea2a0eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1960753c0b87695d90d1085df554a54"><td class="memItemLeft" align="right" valign="top"><a id="aa1960753c0b87695d90d1085df554a54"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aa1960753c0b87695d90d1085df554a54">uint</a> = unsigned int</td></tr>
<tr class="memdesc:aa1960753c0b87695d90d1085df554a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned int type. <br /></td></tr>
<tr class="separator:aa1960753c0b87695d90d1085df554a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7213f0de5ec62553f34df797f4517aa9"><td class="memItemLeft" align="right" valign="top"><a id="a7213f0de5ec62553f34df797f4517aa9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a7213f0de5ec62553f34df797f4517aa9">ulong</a> = unsigned long</td></tr>
<tr class="memdesc:a7213f0de5ec62553f34df797f4517aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned long type. <br /></td></tr>
<tr class="separator:a7213f0de5ec62553f34df797f4517aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69cfc1b4ade1a9cc0f03d549d1685b7e"><td class="memItemLeft" align="right" valign="top"><a id="a69cfc1b4ade1a9cc0f03d549d1685b7e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ulonglong</b> = unsigned long long</td></tr>
<tr class="separator:a69cfc1b4ade1a9cc0f03d549d1685b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeda94e73421a165bf182fd7ca5b2e4c"><td class="memItemLeft" align="right" valign="top"><a id="abeda94e73421a165bf182fd7ca5b2e4c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#abeda94e73421a165bf182fd7ca5b2e4c">size_t</a> = std::size_t</td></tr>
<tr class="memdesc:abeda94e73421a165bf182fd7ca5b2e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type representing size of objects. <br /></td></tr>
<tr class="separator:abeda94e73421a165bf182fd7ca5b2e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c43d8849dd1538910e731be6f9b3a2c"><td class="memItemLeft" align="right" valign="top"><a id="a7c43d8849dd1538910e731be6f9b3a2c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a7c43d8849dd1538910e731be6f9b3a2c">align_t</a> = std::size_t</td></tr>
<tr class="memdesc:a7c43d8849dd1538910e731be6f9b3a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type representing alignment of an object. <br /></td></tr>
<tr class="separator:a7c43d8849dd1538910e731be6f9b3a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8843eac8c746fdb52b12036b241ed4e9"><td class="memItemLeft" align="right" valign="top"><a id="a8843eac8c746fdb52b12036b241ed4e9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a8843eac8c746fdb52b12036b241ed4e9">index_t</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:a8843eac8c746fdb52b12036b241ed4e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type representing index of objects. <br /></td></tr>
<tr class="separator:a8843eac8c746fdb52b12036b241ed4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54272c22a7297f1486e189a7ad68a6f9"><td class="memItemLeft" align="right" valign="top"><a id="a54272c22a7297f1486e189a7ad68a6f9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a54272c22a7297f1486e189a7ad68a6f9">hash_t</a> = std::size_t</td></tr>
<tr class="memdesc:a54272c22a7297f1486e189a7ad68a6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for hashes. <br /></td></tr>
<tr class="separator:a54272c22a7297f1486e189a7ad68a6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043edbf63b2f5985bc164cff164f082d"><td class="memItemLeft" align="right" valign="top"><a id="a043edbf63b2f5985bc164cff164f082d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_char_wrapper</b> = <a class="el" href="../../d4/db2/structbit_1_1stl_1_1const__type__wrapper.html">const_type_wrapper</a>&lt; char &gt;</td></tr>
<tr class="separator:a043edbf63b2f5985bc164cff164f082d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8315749126958143068047d92d4540b0"><td class="memItemLeft" align="right" valign="top"><a id="a8315749126958143068047d92d4540b0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a8315749126958143068047d92d4540b0">const_wchar_wrapper</a> = <a class="el" href="../../d4/db2/structbit_1_1stl_1_1const__type__wrapper.html">const_type_wrapper</a>&lt; wchar_t &gt;</td></tr>
<tr class="memdesc:a8315749126958143068047d92d4540b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">For ansi strings. <br /></td></tr>
<tr class="separator:a8315749126958143068047d92d4540b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af444408c984a94e05ff52daee756d6f7"><td class="memItemLeft" align="right" valign="top"><a id="af444408c984a94e05ff52daee756d6f7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#af444408c984a94e05ff52daee756d6f7">const_char16_wrapper</a> = <a class="el" href="../../d4/db2/structbit_1_1stl_1_1const__type__wrapper.html">const_type_wrapper</a>&lt; char16_t &gt;</td></tr>
<tr class="memdesc:af444408c984a94e05ff52daee756d6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">For wide strings. <br /></td></tr>
<tr class="separator:af444408c984a94e05ff52daee756d6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4dc24290b1d9fc5cf3ef052fcd650c"><td class="memItemLeft" align="right" valign="top"><a id="adf4dc24290b1d9fc5cf3ef052fcd650c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#adf4dc24290b1d9fc5cf3ef052fcd650c">const_char32_wrapper</a> = <a class="el" href="../../d4/db2/structbit_1_1stl_1_1const__type__wrapper.html">const_type_wrapper</a>&lt; char32_t &gt;</td></tr>
<tr class="memdesc:adf4dc24290b1d9fc5cf3ef052fcd650c"><td class="mdescLeft">&#160;</td><td class="mdescRight">For UTF16 strings. <br /></td></tr>
<tr class="separator:adf4dc24290b1d9fc5cf3ef052fcd650c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b237a003e9fd070c20ff0085b76ee2"><td class="memItemLeft" align="right" valign="top"><a id="ab2b237a003e9fd070c20ff0085b76ee2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ab2b237a003e9fd070c20ff0085b76ee2">const_tchar_wrapper</a> = <a class="el" href="../../d4/db2/structbit_1_1stl_1_1const__type__wrapper.html">const_type_wrapper</a>&lt; tchar &gt;</td></tr>
<tr class="memdesc:ab2b237a003e9fd070c20ff0085b76ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">For UTF32 strings. <br /></td></tr>
<tr class="separator:ab2b237a003e9fd070c20ff0085b76ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c03e112949198a99d50289dce7e6f2"><td class="memTemplParams" colspan="2"><a id="ab0c03e112949198a99d50289dce7e6f2"></a>
template&lt;typename CharT , typename Traits  = std::char_traits&lt;CharT&gt;, std::ptrdiff_t Extent = dynamic_extent&gt; </td></tr>
<tr class="memitem:ab0c03e112949198a99d50289dce7e6f2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>basic_zstring</b> = CharT *</td></tr>
<tr class="separator:ab0c03e112949198a99d50289dce7e6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943ce8a1e29d97ef545e410faaabd3a7"><td class="memTemplParams" colspan="2"><a id="a943ce8a1e29d97ef545e410faaabd3a7"></a>
template&lt;std::ptrdiff_t Extent = dynamic_extent&gt; </td></tr>
<tr class="memitem:a943ce8a1e29d97ef545e410faaabd3a7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>zstring</b> = basic_zstring&lt; char, std::char_traits&lt; char &gt;, Extent &gt;</td></tr>
<tr class="separator:a943ce8a1e29d97ef545e410faaabd3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ec786edb78723ca95eff416f7d18df"><td class="memTemplParams" colspan="2"><a id="a55ec786edb78723ca95eff416f7d18df"></a>
template&lt;std::ptrdiff_t Extent = dynamic_extent&gt; </td></tr>
<tr class="memitem:a55ec786edb78723ca95eff416f7d18df"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>wzstring</b> = basic_zstring&lt; wchar_t, std::char_traits&lt; wchar_t &gt;, Extent &gt;</td></tr>
<tr class="separator:a55ec786edb78723ca95eff416f7d18df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11e99f138a22e53a2c41a452bf9c23f"><td class="memTemplParams" colspan="2"><a id="ad11e99f138a22e53a2c41a452bf9c23f"></a>
template&lt;std::ptrdiff_t Extent = dynamic_extent&gt; </td></tr>
<tr class="memitem:ad11e99f138a22e53a2c41a452bf9c23f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>u16zstring</b> = basic_zstring&lt; char16_t, std::char_traits&lt; char16_t &gt;, Extent &gt;</td></tr>
<tr class="separator:ad11e99f138a22e53a2c41a452bf9c23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa895dd575730723851c77eb2981ad60e"><td class="memTemplParams" colspan="2"><a id="aa895dd575730723851c77eb2981ad60e"></a>
template&lt;std::ptrdiff_t Extent = dynamic_extent&gt; </td></tr>
<tr class="memitem:aa895dd575730723851c77eb2981ad60e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>u32zstring</b> = basic_zstring&lt; char32_t, std::char_traits&lt; char32_t &gt;, Extent &gt;</td></tr>
<tr class="separator:aa895dd575730723851c77eb2981ad60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac000d24a8914a0c94023979be4ffa179"><td class="memTemplParams" colspan="2"><a id="ac000d24a8914a0c94023979be4ffa179"></a>
template&lt;std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:ac000d24a8914a0c94023979be4ffa179"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>string_span</b> = <a class="el" href="../../db/de7/classbit_1_1stl_1_1basic__string__span.html">basic_string_span</a>&lt; char, std::char_traits&lt; char &gt;, Extent &gt;</td></tr>
<tr class="separator:ac000d24a8914a0c94023979be4ffa179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad892609c1d75f3c103c4aa4599e98a98"><td class="memTemplParams" colspan="2"><a id="ad892609c1d75f3c103c4aa4599e98a98"></a>
template&lt;std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:ad892609c1d75f3c103c4aa4599e98a98"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>wstring_span</b> = <a class="el" href="../../db/de7/classbit_1_1stl_1_1basic__string__span.html">basic_string_span</a>&lt; wchar_t, std::char_traits&lt; wchar_t &gt;, Extent &gt;</td></tr>
<tr class="separator:ad892609c1d75f3c103c4aa4599e98a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46422f18282328fee2a1b6fe23549c20"><td class="memTemplParams" colspan="2"><a id="a46422f18282328fee2a1b6fe23549c20"></a>
template&lt;std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a46422f18282328fee2a1b6fe23549c20"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>u16string_span</b> = <a class="el" href="../../db/de7/classbit_1_1stl_1_1basic__string__span.html">basic_string_span</a>&lt; char16_t, std::char_traits&lt; char16_t &gt;, Extent &gt;</td></tr>
<tr class="separator:a46422f18282328fee2a1b6fe23549c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ece75ff6a48b762fe43adc2445b867"><td class="memTemplParams" colspan="2"><a id="ac1ece75ff6a48b762fe43adc2445b867"></a>
template&lt;std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:ac1ece75ff6a48b762fe43adc2445b867"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>u32string_span</b> = <a class="el" href="../../db/de7/classbit_1_1stl_1_1basic__string__span.html">basic_string_span</a>&lt; char32_t, std::char_traits&lt; char32_t &gt;, Extent &gt;</td></tr>
<tr class="separator:ac1ece75ff6a48b762fe43adc2445b867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c9433e2c7eba860242f75c202d78eb"><td class="memTemplParams" colspan="2"><a id="ad2c9433e2c7eba860242f75c202d78eb"></a>
template&lt;std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:ad2c9433e2c7eba860242f75c202d78eb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>zstring_span</b> = <a class="el" href="../../dd/d92/classbit_1_1stl_1_1basic__zstring__span.html">basic_zstring_span</a>&lt; char, std::char_traits&lt; char &gt;, Extent &gt;</td></tr>
<tr class="separator:ad2c9433e2c7eba860242f75c202d78eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805428a98a25edaeaee01879f8a00c94"><td class="memTemplParams" colspan="2"><a id="a805428a98a25edaeaee01879f8a00c94"></a>
template&lt;std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a805428a98a25edaeaee01879f8a00c94"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>wzstring_span</b> = <a class="el" href="../../dd/d92/classbit_1_1stl_1_1basic__zstring__span.html">basic_zstring_span</a>&lt; wchar_t, std::char_traits&lt; wchar_t &gt;, Extent &gt;</td></tr>
<tr class="separator:a805428a98a25edaeaee01879f8a00c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b62a9e1e63b265fe5e2469dfd6b6e72"><td class="memTemplParams" colspan="2"><a id="a4b62a9e1e63b265fe5e2469dfd6b6e72"></a>
template&lt;std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a4b62a9e1e63b265fe5e2469dfd6b6e72"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>u16zstring_span</b> = <a class="el" href="../../dd/d92/classbit_1_1stl_1_1basic__zstring__span.html">basic_zstring_span</a>&lt; char16_t, std::char_traits&lt; char16_t &gt;, Extent &gt;</td></tr>
<tr class="separator:a4b62a9e1e63b265fe5e2469dfd6b6e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93762305bc884f428d8044055af525c4"><td class="memTemplParams" colspan="2"><a id="a93762305bc884f428d8044055af525c4"></a>
template&lt;std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a93762305bc884f428d8044055af525c4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>u32zstring_span</b> = <a class="el" href="../../dd/d92/classbit_1_1stl_1_1basic__zstring__span.html">basic_zstring_span</a>&lt; char32_t, std::char_traits&lt; char32_t &gt;, Extent &gt;</td></tr>
<tr class="separator:a93762305bc884f428d8044055af525c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac960b0c0061252bb398695e4bd0c706b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac960b0c0061252bb398695e4bd0c706b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ac960b0c0061252bb398695e4bd0c706b">is_string_span</a> = detail::is_string_span&lt; std::remove_cv_t&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ac960b0c0061252bb398695e4bd0c706b"><td class="mdescLeft">&#160;</td><td class="mdescRight">type-trait to determine whether the type is a string_span  <a href="#ac960b0c0061252bb398695e4bd0c706b">More...</a><br /></td></tr>
<tr class="separator:ac960b0c0061252bb398695e4bd0c706b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad591c6c50fab0fb9348d8afd38322a37"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad591c6c50fab0fb9348d8afd38322a37"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ad591c6c50fab0fb9348d8afd38322a37">is_zstring_span</a> = detail::is_zstring_span&lt; std::remove_cv_t&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ad591c6c50fab0fb9348d8afd38322a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">type-trait to determine whether the type is a null-terminated string  <a href="#ad591c6c50fab0fb9348d8afd38322a37">More...</a><br /></td></tr>
<tr class="separator:ad591c6c50fab0fb9348d8afd38322a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6963a843faa0d131247e2adc47ac2560"><td class="memItemLeft" align="right" valign="top"><a id="a6963a843faa0d131247e2adc47ac2560"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>string_tokenizer</b> = <a class="el" href="../../d3/d50/classbit_1_1stl_1_1basic__string__tokenizer.html">basic_string_tokenizer</a>&lt; char, std::char_traits&lt; char &gt;, true &gt;</td></tr>
<tr class="separator:a6963a843faa0d131247e2adc47ac2560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d68bc3c1d88143399550f061aee4cf"><td class="memItemLeft" align="right" valign="top"><a id="a24d68bc3c1d88143399550f061aee4cf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>wstring_tokenizer</b> = <a class="el" href="../../d3/d50/classbit_1_1stl_1_1basic__string__tokenizer.html">basic_string_tokenizer</a>&lt; wchar_t, std::char_traits&lt; wchar_t &gt;, true &gt;</td></tr>
<tr class="separator:a24d68bc3c1d88143399550f061aee4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5a9df0c24c2d354847a500febe0331"><td class="memItemLeft" align="right" valign="top"><a id="afe5a9df0c24c2d354847a500febe0331"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u16string_tokenizer</b> = <a class="el" href="../../d3/d50/classbit_1_1stl_1_1basic__string__tokenizer.html">basic_string_tokenizer</a>&lt; char16_t, std::char_traits&lt; char16_t &gt;, true &gt;</td></tr>
<tr class="separator:afe5a9df0c24c2d354847a500febe0331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe2bf118c3a4a953401852907d519dd"><td class="memItemLeft" align="right" valign="top"><a id="a7fe2bf118c3a4a953401852907d519dd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u32string_tokenizer</b> = <a class="el" href="../../d3/d50/classbit_1_1stl_1_1basic__string__tokenizer.html">basic_string_tokenizer</a>&lt; char32_t, std::char_traits&lt; char32_t &gt;, true &gt;</td></tr>
<tr class="separator:a7fe2bf118c3a4a953401852907d519dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8760e105102b02e07f763bb926b41a5a"><td class="memItemLeft" align="right" valign="top"><a id="a8760e105102b02e07f763bb926b41a5a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>string_view_tokenizer</b> = <a class="el" href="../../d3/d50/classbit_1_1stl_1_1basic__string__tokenizer.html">basic_string_tokenizer</a>&lt; char, std::char_traits&lt; char &gt;, false &gt;</td></tr>
<tr class="separator:a8760e105102b02e07f763bb926b41a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbdebdf249664f9ab46f4fb377509c9"><td class="memItemLeft" align="right" valign="top"><a id="a1dbdebdf249664f9ab46f4fb377509c9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>wstring_view_tokenizer</b> = <a class="el" href="../../d3/d50/classbit_1_1stl_1_1basic__string__tokenizer.html">basic_string_tokenizer</a>&lt; wchar_t, std::char_traits&lt; wchar_t &gt;, false &gt;</td></tr>
<tr class="separator:a1dbdebdf249664f9ab46f4fb377509c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370db6d3c570dc26f9a6a4c12d609344"><td class="memItemLeft" align="right" valign="top"><a id="a370db6d3c570dc26f9a6a4c12d609344"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u16string_view_tokenizer</b> = <a class="el" href="../../d3/d50/classbit_1_1stl_1_1basic__string__tokenizer.html">basic_string_tokenizer</a>&lt; char16_t, std::char_traits&lt; char16_t &gt;, false &gt;</td></tr>
<tr class="separator:a370db6d3c570dc26f9a6a4c12d609344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e3f2e0a425d22092336e333f0b3003"><td class="memItemLeft" align="right" valign="top"><a id="a05e3f2e0a425d22092336e333f0b3003"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u32string_view_tokenizer</b> = <a class="el" href="../../d3/d50/classbit_1_1stl_1_1basic__string__tokenizer.html">basic_string_tokenizer</a>&lt; char32_t, std::char_traits&lt; char32_t &gt;, false &gt;</td></tr>
<tr class="separator:a05e3f2e0a425d22092336e333f0b3003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7d69900d17489caf0ffbebea99485a"><td class="memItemLeft" align="right" valign="top"><a id="abb7d69900d17489caf0ffbebea99485a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>string_view</b> = <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; char &gt;</td></tr>
<tr class="separator:abb7d69900d17489caf0ffbebea99485a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2094d98472588d728985e9d677b0ed4c"><td class="memItemLeft" align="right" valign="top"><a id="a2094d98472588d728985e9d677b0ed4c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>wstring_view</b> = <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; wchar_t &gt;</td></tr>
<tr class="separator:a2094d98472588d728985e9d677b0ed4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf49a062911610dee85d6498d73c0e49"><td class="memItemLeft" align="right" valign="top"><a id="acf49a062911610dee85d6498d73c0e49"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u16string_view</b> = <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; char16_t &gt;</td></tr>
<tr class="separator:acf49a062911610dee85d6498d73c0e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c07055689d0d4e12452165cb90061f"><td class="memItemLeft" align="right" valign="top"><a id="a97c07055689d0d4e12452165cb90061f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u32string_view</b> = <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; char32_t &gt;</td></tr>
<tr class="separator:a97c07055689d0d4e12452165cb90061f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52ea4771a4f1b858b0c4355628dfd4f"><td class="memItemLeft" align="right" valign="top"><a id="ac52ea4771a4f1b858b0c4355628dfd4f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>zstring_view</b> = <a class="el" href="../../d6/d16/classbit_1_1stl_1_1basic__zstring__view.html">basic_zstring_view</a>&lt; char &gt;</td></tr>
<tr class="separator:ac52ea4771a4f1b858b0c4355628dfd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac55cc561f2177ed6edbbf5017a955a"><td class="memItemLeft" align="right" valign="top"><a id="a0ac55cc561f2177ed6edbbf5017a955a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>wzstring_view</b> = <a class="el" href="../../d6/d16/classbit_1_1stl_1_1basic__zstring__view.html">basic_zstring_view</a>&lt; wchar_t &gt;</td></tr>
<tr class="separator:a0ac55cc561f2177ed6edbbf5017a955a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ef4f44c4c168bc00112b0b5d6eef64"><td class="memItemLeft" align="right" valign="top"><a id="a19ef4f44c4c168bc00112b0b5d6eef64"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u16zstring_view</b> = <a class="el" href="../../d6/d16/classbit_1_1stl_1_1basic__zstring__view.html">basic_zstring_view</a>&lt; char16_t &gt;</td></tr>
<tr class="separator:a19ef4f44c4c168bc00112b0b5d6eef64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20eaaefa0a47f1b93c58572666af1cf0"><td class="memItemLeft" align="right" valign="top"><a id="a20eaaefa0a47f1b93c58572666af1cf0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u32zstring_view</b> = <a class="el" href="../../d6/d16/classbit_1_1stl_1_1basic__zstring__view.html">basic_zstring_view</a>&lt; char32_t &gt;</td></tr>
<tr class="separator:a20eaaefa0a47f1b93c58572666af1cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5853dc716058231d67db9de2a050a251"><td class="memItemLeft" align="right" valign="top"><a id="a5853dc716058231d67db9de2a050a251"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5853dc716058231d67db9de2a050a251">indeterminate_t</a> = bool(*)(const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;, detail::tribool_t)</td></tr>
<tr class="memdesc:a5853dc716058231d67db9de2a050a251"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to mark an indeterminate tribool. <br /></td></tr>
<tr class="separator:a5853dc716058231d67db9de2a050a251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948064b1934f1f7acc4272def8c90641"><td class="memItemLeft" align="right" valign="top"><a id="a948064b1934f1f7acc4272def8c90641"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a948064b1934f1f7acc4272def8c90641">in_place_t</a> = <a class="el" href="../../dd/d57/structbit_1_1stl_1_1in__place__tag.html">in_place_tag</a>(&amp;)()</td></tr>
<tr class="memdesc:a948064b1934f1f7acc4272def8c90641"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag type used for dispatching in_place calls. <br /></td></tr>
<tr class="separator:a948064b1934f1f7acc4272def8c90641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ab20b6ad39348adb5a6840ffc47d23"><td class="memTemplParams" colspan="2"><a id="a71ab20b6ad39348adb5a6840ffc47d23"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a71ab20b6ad39348adb5a6840ffc47d23"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a71ab20b6ad39348adb5a6840ffc47d23">in_place_type_t</a> = <a class="el" href="../../dd/d57/structbit_1_1stl_1_1in__place__tag.html">in_place_tag</a>(&amp;)()</td></tr>
<tr class="memdesc:a71ab20b6ad39348adb5a6840ffc47d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag type used for type-based dispatching in_place calls. <br /></td></tr>
<tr class="separator:a71ab20b6ad39348adb5a6840ffc47d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06713ea4eba76aba207b6b5da963d179"><td class="memTemplParams" colspan="2"><a id="a06713ea4eba76aba207b6b5da963d179"></a>
template&lt;std::size_t I&gt; </td></tr>
<tr class="memitem:a06713ea4eba76aba207b6b5da963d179"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a06713ea4eba76aba207b6b5da963d179">in_place_index_t</a> = <a class="el" href="../../dd/d57/structbit_1_1stl_1_1in__place__tag.html">in_place_tag</a>(&amp;)()</td></tr>
<tr class="memdesc:a06713ea4eba76aba207b6b5da963d179"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag type used for type-based dispatching in_place calls. <br /></td></tr>
<tr class="separator:a06713ea4eba76aba207b6b5da963d179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5964268b12686a86b6e28490504f6416"><td class="memTemplParams" colspan="2"><a id="a5964268b12686a86b6e28490504f6416"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5964268b12686a86b6e28490504f6416"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>underlying_container_type_t</b> = typename <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#dd/d73/classbit_1_1stl_1_1underlying__container__type">underlying_container_type</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a5964268b12686a86b6e28490504f6416"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2befb911f8c8b196b4ba81d50e20fb28"><td class="memTemplParams" colspan="2">template&lt;typename T  = detail::array_autodeduce, typename... Args&gt; </td></tr>
<tr class="memitem:a2befb911f8c8b196b4ba81d50e20fb28"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a2befb911f8c8b196b4ba81d50e20fb28">make_array</a> (Args &amp;&amp;... args) noexcept -&gt; detail::array_return_type_t&lt; T, Args... &gt;</td></tr>
<tr class="memdesc:a2befb911f8c8b196b4ba81d50e20fb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make utility for creating a std::array.  <a href="#a2befb911f8c8b196b4ba81d50e20fb28">More...</a><br /></td></tr>
<tr class="separator:a2befb911f8c8b196b4ba81d50e20fb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c54cd7406cc5388e67323491e900826"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a0c54cd7406cc5388e67323491e900826"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::array&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a0c54cd7406cc5388e67323491e900826">to_array</a> (const T(&amp;array)[N]) noexcept(std::is_nothrow_copy_constructible&lt; T &gt;::value)</td></tr>
<tr class="memdesc:a0c54cd7406cc5388e67323491e900826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to convert raw arrays to std::array.  <a href="#a0c54cd7406cc5388e67323491e900826">More...</a><br /></td></tr>
<tr class="separator:a0c54cd7406cc5388e67323491e900826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966bc186dbddc974625ca051e42d2aed"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a966bc186dbddc974625ca051e42d2aed"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::array&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a966bc186dbddc974625ca051e42d2aed">to_array</a> (T(&amp;&amp;array)[N]) noexcept(std::is_nothrow_move_constructible&lt; T &gt;::value)</td></tr>
<tr class="memdesc:a966bc186dbddc974625ca051e42d2aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to convert raw arrays to std::array.  <a href="#a966bc186dbddc974625ca051e42d2aed">More...</a><br /></td></tr>
<tr class="separator:a966bc186dbddc974625ca051e42d2aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c93c46863e5fb3e03f4302e8067343"><td class="memTemplParams" colspan="2"><a id="a22c93c46863e5fb3e03f4302e8067343"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a22c93c46863e5fb3e03f4302e8067343"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a22c93c46863e5fb3e03f4302e8067343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23e5de00eb12c35f7cf1036db07de54"><td class="memTemplParams" colspan="2"><a id="ad23e5de00eb12c35f7cf1036db07de54"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad23e5de00eb12c35f7cf1036db07de54"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:ad23e5de00eb12c35f7cf1036db07de54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268dcaa06fb1aad287b7d9c2b25e153e"><td class="memTemplParams" colspan="2"><a id="a268dcaa06fb1aad287b7d9c2b25e153e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a268dcaa06fb1aad287b7d9c2b25e153e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a268dcaa06fb1aad287b7d9c2b25e153e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c3042007a58db704ae5e159e88fa7d"><td class="memTemplParams" colspan="2"><a id="ab5c3042007a58db704ae5e159e88fa7d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab5c3042007a58db704ae5e159e88fa7d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:ab5c3042007a58db704ae5e159e88fa7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c0bca779bc1f0e57c36a21ba59b58a"><td class="memTemplParams" colspan="2"><a id="ac8c0bca779bc1f0e57c36a21ba59b58a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac8c0bca779bc1f0e57c36a21ba59b58a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:ac8c0bca779bc1f0e57c36a21ba59b58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12dc8b41981cdc6d7bfb37c43d9fdf26"><td class="memTemplParams" colspan="2"><a id="a12dc8b41981cdc6d7bfb37c43d9fdf26"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a12dc8b41981cdc6d7bfb37c43d9fdf26"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a12dc8b41981cdc6d7bfb37c43d9fdf26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb39cc7bf99225132194db4bc572100"><td class="memTemplParams" colspan="2"><a id="a7bb39cc7bf99225132194db4bc572100"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7bb39cc7bf99225132194db4bc572100"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../da/dcc/classbit_1_1stl_1_1array__view.html">array_view</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a7bb39cc7bf99225132194db4bc572100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6011c513ea463a3fafeb938c8105e788"><td class="memTemplParams" colspan="2">template&lt;typename Error , std::enable_if_t&lt; std::is_enum&lt; Error &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6011c513ea463a3fafeb938c8105e788"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../db/dbd/classbit_1_1stl_1_1error__code.html">error_code</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a6011c513ea463a3fafeb938c8105e788">make_error</a> (Error error, const std::error_category &amp;category) noexcept</td></tr>
<tr class="separator:a6011c513ea463a3fafeb938c8105e788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f197508e34e2051346698594a492cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dbd/classbit_1_1stl_1_1error__code.html">error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a35f197508e34e2051346698594a492cf">make_error</a> (int error, const std::error_category &amp;category) noexcept</td></tr>
<tr class="separator:a35f197508e34e2051346698594a492cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d02b1044408f28f1a45ed3cffb16cbd"><td class="memTemplParams" colspan="2"><a id="a9d02b1044408f28f1a45ed3cffb16cbd"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a9d02b1044408f28f1a45ed3cffb16cbd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../db/dfc/classbit_1_1stl_1_1checked.html">checked</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_checked</b> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:a9d02b1044408f28f1a45ed3cffb16cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4255d6677946523425ddefbf196711e2"><td class="memTemplParams" colspan="2"><a id="a4255d6677946523425ddefbf196711e2"></a>
template&lt;typename T , typename U , typename... Args&gt; </td></tr>
<tr class="memitem:a4255d6677946523425ddefbf196711e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../db/dfc/classbit_1_1stl_1_1checked.html">checked</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_checked</b> (std::initializer_list&lt; U &gt; ilist, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a4255d6677946523425ddefbf196711e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3db2a94cbc183d4423878f39289c44"><td class="memTemplParams" colspan="2"><a id="a6b3db2a94cbc183d4423878f39289c44"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6b3db2a94cbc183d4423878f39289c44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a6b3db2a94cbc183d4423878f39289c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe820e645aa1a0646e2b1b884b62c67"><td class="memTemplParams" colspan="2"><a id="a1fe820e645aa1a0646e2b1b884b62c67"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1fe820e645aa1a0646e2b1b884b62c67"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a1fe820e645aa1a0646e2b1b884b62c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6091a51d5f25be0f1cd42a56324dfc"><td class="memTemplParams" colspan="2"><a id="aea6091a51d5f25be0f1cd42a56324dfc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aea6091a51d5f25be0f1cd42a56324dfc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aea6091a51d5f25be0f1cd42a56324dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953f3766a67ff8585ec097adda9e5b9c"><td class="memTemplParams" colspan="2"><a id="a953f3766a67ff8585ec097adda9e5b9c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a953f3766a67ff8585ec097adda9e5b9c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a953f3766a67ff8585ec097adda9e5b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace573cae3ee1cf89f0106274a4bba8f5"><td class="memTemplParams" colspan="2"><a id="ace573cae3ee1cf89f0106274a4bba8f5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace573cae3ee1cf89f0106274a4bba8f5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ace573cae3ee1cf89f0106274a4bba8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55f8fb8bcd638d5bce26996bdded044"><td class="memTemplParams" colspan="2"><a id="ab55f8fb8bcd638d5bce26996bdded044"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab55f8fb8bcd638d5bce26996bdded044"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ab55f8fb8bcd638d5bce26996bdded044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3218a0470f36a953473ffc7997494b2e"><td class="memTemplParams" colspan="2"><a id="a3218a0470f36a953473ffc7997494b2e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3218a0470f36a953473ffc7997494b2e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../de/d28/classbit_1_1stl_1_1circular__buffer.html">circular_buffer</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a3218a0470f36a953473ffc7997494b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85fa7266c81294abadd9b2a636274387"><td class="memTemplParams" colspan="2"><a id="a85fa7266c81294abadd9b2a636274387"></a>
template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a85fa7266c81294abadd9b2a636274387"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a>&lt; Fn &gt; &amp;lhs, const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a>&lt; Fn &gt; &amp;rhs)</td></tr>
<tr class="separator:a85fa7266c81294abadd9b2a636274387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c91eeacbdcb55de0dda9517d41434a7"><td class="memTemplParams" colspan="2"><a id="a7c91eeacbdcb55de0dda9517d41434a7"></a>
template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a7c91eeacbdcb55de0dda9517d41434a7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a>&lt; Fn &gt; &amp;lhs, const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a>&lt; Fn &gt; &amp;rhs)</td></tr>
<tr class="separator:a7c91eeacbdcb55de0dda9517d41434a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa374c754addf788f926ccf3a6885c927"><td class="memTemplParams" colspan="2"><a id="aa374c754addf788f926ccf3a6885c927"></a>
template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:aa374c754addf788f926ccf3a6885c927"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a>&lt; Fn &gt; &amp;lhs, const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a>&lt; Fn &gt; &amp;rhs)</td></tr>
<tr class="separator:aa374c754addf788f926ccf3a6885c927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015674f342f7ec51e5e739c1a45d9af0"><td class="memTemplParams" colspan="2"><a id="a015674f342f7ec51e5e739c1a45d9af0"></a>
template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a015674f342f7ec51e5e739c1a45d9af0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a>&lt; Fn &gt; &amp;lhs, const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a>&lt; Fn &gt; &amp;rhs)</td></tr>
<tr class="separator:a015674f342f7ec51e5e739c1a45d9af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a737915f1b6d8aaf20c67dd3bcc583"><td class="memTemplParams" colspan="2"><a id="a54a737915f1b6d8aaf20c67dd3bcc583"></a>
template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a54a737915f1b6d8aaf20c67dd3bcc583"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a>&lt; Fn &gt; &amp;lhs, const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a>&lt; Fn &gt; &amp;rhs)</td></tr>
<tr class="separator:a54a737915f1b6d8aaf20c67dd3bcc583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17f78ee07e24f5a14d0de207c8f8b0c"><td class="memTemplParams" colspan="2"><a id="ac17f78ee07e24f5a14d0de207c8f8b0c"></a>
template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:ac17f78ee07e24f5a14d0de207c8f8b0c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a>&lt; Fn &gt; &amp;lhs, const <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d6/d7e/classbit_1_1stl_1_1delegate">delegate</a>&lt; Fn &gt; &amp;rhs)</td></tr>
<tr class="separator:ac17f78ee07e24f5a14d0de207c8f8b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e8cff3ee1637db01fb2e8c04a4a9a0"><td class="memTemplParams" colspan="2">template&lt;typename Enum &gt; </td></tr>
<tr class="memitem:a14e8cff3ee1637db01fb2e8c04a4a9a0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d5/d36/classbit_1_1stl_1_1enum__range.html">enum_range</a>&lt; Enum &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a14e8cff3ee1637db01fb2e8c04a4a9a0">make_enum_range</a> ()</td></tr>
<tr class="memdesc:a14e8cff3ee1637db01fb2e8c04a4a9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an enum range from a given.  <a href="#a14e8cff3ee1637db01fb2e8c04a4a9a0">More...</a><br /></td></tr>
<tr class="separator:a14e8cff3ee1637db01fb2e8c04a4a9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57b69bbf1e9222a69223b719d8337bf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa57b69bbf1e9222a69223b719d8337bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aa57b69bbf1e9222a69223b719d8337bf">operator==</a> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aa57b69bbf1e9222a69223b719d8337bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two expected&lt;T&gt; values together for equality.  <a href="#aa57b69bbf1e9222a69223b719d8337bf">More...</a><br /></td></tr>
<tr class="separator:aa57b69bbf1e9222a69223b719d8337bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ab3a3776017e9df8f4c376cd222a20"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad6ab3a3776017e9df8f4c376cd222a20"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ad6ab3a3776017e9df8f4c376cd222a20">operator!=</a> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ad6ab3a3776017e9df8f4c376cd222a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two expected&lt;T&gt; values together for inequality equality.  <a href="#ad6ab3a3776017e9df8f4c376cd222a20">More...</a><br /></td></tr>
<tr class="separator:ad6ab3a3776017e9df8f4c376cd222a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad700e1ab6c0e622c376e2e9416e1c9a9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad700e1ab6c0e622c376e2e9416e1c9a9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ad700e1ab6c0e622c376e2e9416e1c9a9">operator&lt;</a> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ad700e1ab6c0e622c376e2e9416e1c9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <code>lhs</code> &lt; <code>rhs</code>.  <a href="#ad700e1ab6c0e622c376e2e9416e1c9a9">More...</a><br /></td></tr>
<tr class="separator:ad700e1ab6c0e622c376e2e9416e1c9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b3fce30938e6c628ae75e00352550e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa8b3fce30938e6c628ae75e00352550e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aa8b3fce30938e6c628ae75e00352550e">operator&lt;=</a> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aa8b3fce30938e6c628ae75e00352550e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <code>lhs</code> &lt;= <code>rhs</code>.  <a href="#aa8b3fce30938e6c628ae75e00352550e">More...</a><br /></td></tr>
<tr class="separator:aa8b3fce30938e6c628ae75e00352550e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb28f08d7f257bf2db0dc9aa495a715"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5cb28f08d7f257bf2db0dc9aa495a715"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5cb28f08d7f257bf2db0dc9aa495a715">operator&gt;</a> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a5cb28f08d7f257bf2db0dc9aa495a715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <code>lhs</code> &gt; <code>rhs</code>.  <a href="#a5cb28f08d7f257bf2db0dc9aa495a715">More...</a><br /></td></tr>
<tr class="separator:a5cb28f08d7f257bf2db0dc9aa495a715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cec8f9db40b0863a90f4f486eb1456c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5cec8f9db40b0863a90f4f486eb1456c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5cec8f9db40b0863a90f4f486eb1456c">operator&gt;=</a> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a5cec8f9db40b0863a90f4f486eb1456c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <code>lhs</code> &gt; <code>rhs</code>.  <a href="#a5cec8f9db40b0863a90f4f486eb1456c">More...</a><br /></td></tr>
<tr class="separator:a5cec8f9db40b0863a90f4f486eb1456c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc621a1914a7d20efc1afa6b91be66eb"><td class="memTemplParams" colspan="2"><a id="acc621a1914a7d20efc1afa6b91be66eb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc621a1914a7d20efc1afa6b91be66eb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const T &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:acc621a1914a7d20efc1afa6b91be66eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eccdd1b07de59102eb28e4c4b588c45"><td class="memTemplParams" colspan="2"><a id="a1eccdd1b07de59102eb28e4c4b588c45"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1eccdd1b07de59102eb28e4c4b588c45"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;lhs, const T &amp;rhs) noexcept</td></tr>
<tr class="separator:a1eccdd1b07de59102eb28e4c4b588c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fadd299367dff8b91b608cde8347ba"><td class="memTemplParams" colspan="2"><a id="a28fadd299367dff8b91b608cde8347ba"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a28fadd299367dff8b91b608cde8347ba"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const T &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a28fadd299367dff8b91b608cde8347ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7885ca08b85fb597a7f75af7ed896652"><td class="memTemplParams" colspan="2"><a id="a7885ca08b85fb597a7f75af7ed896652"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7885ca08b85fb597a7f75af7ed896652"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;lhs, const T &amp;rhs) noexcept</td></tr>
<tr class="separator:a7885ca08b85fb597a7f75af7ed896652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9e532e31a12fbacdd5310afb38b393"><td class="memTemplParams" colspan="2"><a id="ade9e532e31a12fbacdd5310afb38b393"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ade9e532e31a12fbacdd5310afb38b393"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const T &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ade9e532e31a12fbacdd5310afb38b393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97420fc72e3a71974e3a0206973a7c5c"><td class="memTemplParams" colspan="2"><a id="a97420fc72e3a71974e3a0206973a7c5c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a97420fc72e3a71974e3a0206973a7c5c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;lhs, const T &amp;rhs) noexcept</td></tr>
<tr class="separator:a97420fc72e3a71974e3a0206973a7c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4d72a88e5ba5f223d98a7c9b836652"><td class="memTemplParams" colspan="2"><a id="a9d4d72a88e5ba5f223d98a7c9b836652"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d4d72a88e5ba5f223d98a7c9b836652"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const T &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a9d4d72a88e5ba5f223d98a7c9b836652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0631f8f9ea439bbb051701ae19ace37f"><td class="memTemplParams" colspan="2"><a id="a0631f8f9ea439bbb051701ae19ace37f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0631f8f9ea439bbb051701ae19ace37f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;lhs, const T &amp;rhs) noexcept</td></tr>
<tr class="separator:a0631f8f9ea439bbb051701ae19ace37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab078d862bb75f1eaefe7ed02dbe1a424"><td class="memTemplParams" colspan="2"><a id="ab078d862bb75f1eaefe7ed02dbe1a424"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab078d862bb75f1eaefe7ed02dbe1a424"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const T &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ab078d862bb75f1eaefe7ed02dbe1a424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad889ba98b2fe8e8b0c82c41dd73e4a36"><td class="memTemplParams" colspan="2"><a id="ad889ba98b2fe8e8b0c82c41dd73e4a36"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad889ba98b2fe8e8b0c82c41dd73e4a36"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;lhs, const T &amp;rhs) noexcept</td></tr>
<tr class="separator:ad889ba98b2fe8e8b0c82c41dd73e4a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08a2e365b5710744bfed5fe1e63eafa"><td class="memTemplParams" colspan="2"><a id="ad08a2e365b5710744bfed5fe1e63eafa"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad08a2e365b5710744bfed5fe1e63eafa"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const T &amp;lhs, const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ad08a2e365b5710744bfed5fe1e63eafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bb97e82572fc66cf69890c0d161d30"><td class="memTemplParams" colspan="2"><a id="a42bb97e82572fc66cf69890c0d161d30"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a42bb97e82572fc66cf69890c0d161d30"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;lhs, const T &amp;rhs) noexcept</td></tr>
<tr class="separator:a42bb97e82572fc66cf69890c0d161d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698e301e29a1fb9d276b511a6eb71463"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a698e301e29a1fb9d276b511a6eb71463"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; std::decay_t&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a698e301e29a1fb9d276b511a6eb71463">make_expected</a> (T &amp;&amp;value) noexcept(noexcept(<a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; std::decay_t&lt; T &gt;&gt;(std::forward&lt; T &gt;(value))))</td></tr>
<tr class="memdesc:a698e301e29a1fb9d276b511a6eb71463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an expected object from <code>value</code>.  <a href="#a698e301e29a1fb9d276b511a6eb71463">More...</a><br /></td></tr>
<tr class="separator:a698e301e29a1fb9d276b511a6eb71463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d93c28213541b7b8a28077d3bda144"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ad8d93c28213541b7b8a28077d3bda144"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ad8d93c28213541b7b8a28077d3bda144">make_expected</a> (Args &amp;&amp;...args) noexcept(noexcept(<a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt;(std::forward&lt; Args &gt;(args)...)))</td></tr>
<tr class="memdesc:ad8d93c28213541b7b8a28077d3bda144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an expected object of type <code>T</code> from the given <code>args</code>.  <a href="#ad8d93c28213541b7b8a28077d3bda144">More...</a><br /></td></tr>
<tr class="separator:ad8d93c28213541b7b8a28077d3bda144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2105804f0773cf2327a705e2424e1116"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename... Args&gt; </td></tr>
<tr class="memitem:a2105804f0773cf2327a705e2424e1116"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a2105804f0773cf2327a705e2424e1116">make_expected</a> (std::initializer_list&lt; U &gt; il, Args &amp;&amp;... args) noexcept(noexcept(<a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt;(il, std::forward&lt; Args &gt;(args)...)))</td></tr>
<tr class="memdesc:a2105804f0773cf2327a705e2424e1116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an expected object of type <code>T</code> from the given <code>il</code> <code>args</code>.  <a href="#a2105804f0773cf2327a705e2424e1116">More...</a><br /></td></tr>
<tr class="separator:a2105804f0773cf2327a705e2424e1116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c322fa5c383e7eeec10f36b8660b4f1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1c322fa5c383e7eeec10f36b8660b4f1"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a1c322fa5c383e7eeec10f36b8660b4f1">hash_value</a> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;val) noexcept</td></tr>
<tr class="memdesc:a1c322fa5c383e7eeec10f36b8660b4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the hash from a given expected.  <a href="#a1c322fa5c383e7eeec10f36b8660b4f1">More...</a><br /></td></tr>
<tr class="separator:a1c322fa5c383e7eeec10f36b8660b4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e8cbdbfe193a3f1e00930facf8de97"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ab9e8cbdbfe193a3f1e00930facf8de97">hash_value</a> (const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; void &gt; &amp;val) noexcept</td></tr>
<tr class="memdesc:ab9e8cbdbfe193a3f1e00930facf8de97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the hash from a given expected.  <a href="#ab9e8cbdbfe193a3f1e00930facf8de97">More...</a><br /></td></tr>
<tr class="separator:ab9e8cbdbfe193a3f1e00930facf8de97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415055bab1cfe18bfe0db940944bbf63"><td class="memTemplParams" colspan="2">template&lt;typename Func , typename... Args&gt; </td></tr>
<tr class="memitem:a415055bab1cfe18bfe0db940944bbf63"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a415055bab1cfe18bfe0db940944bbf63">invoke</a> (Func &amp;&amp;function, Args &amp;&amp;... args) noexcept(noexcept(detail::INVOKE(std::forward&lt; Func &gt;(function), std::forward&lt; Args &gt;(args)...))) -&gt; decltype(detail::INVOKE(std::forward&lt; Func &gt;(function), std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="memdesc:a415055bab1cfe18bfe0db940944bbf63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the Callable object <code>function</code> with the parameters <code>args</code>.  <a href="#a415055bab1cfe18bfe0db940944bbf63">More...</a><br /></td></tr>
<tr class="separator:a415055bab1cfe18bfe0db940944bbf63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aacd178461ac8159314793a3fa7dee6"><td class="memTemplParams" colspan="2"><a id="a7aacd178461ac8159314793a3fa7dee6"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a7aacd178461ac8159314793a3fa7dee6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a7aacd178461ac8159314793a3fa7dee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9de76842f31be5040cc11a5d14ea85"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a8c9de76842f31be5040cc11a5d14ea85"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a8c9de76842f31be5040cc11a5d14ea85">hash_value</a> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:a8c9de76842f31be5040cc11a5d14ea85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the hash from a given <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html" title="The basic_hashed_string_view is a compile-time hashed wrapper around a non-owning string (basic_strin...">basic_hashed_string_view</a>.  <a href="#a8c9de76842f31be5040cc11a5d14ea85">More...</a><br /></td></tr>
<tr class="separator:a8c9de76842f31be5040cc11a5d14ea85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d7a99fea08d25193e75dbe255fbc32"><td class="memTemplParams" colspan="2"><a id="a72d7a99fea08d25193e75dbe255fbc32"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a72d7a99fea08d25193e75dbe255fbc32"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a72d7a99fea08d25193e75dbe255fbc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59c457ef3d83af771f005057e9b02f9"><td class="memTemplParams" colspan="2"><a id="aa59c457ef3d83af771f005057e9b02f9"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:aa59c457ef3d83af771f005057e9b02f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aa59c457ef3d83af771f005057e9b02f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a171e4e3954c5807fd7b1c4a20b230"><td class="memTemplParams" colspan="2"><a id="ad4a171e4e3954c5807fd7b1c4a20b230"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ad4a171e4e3954c5807fd7b1c4a20b230"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ad4a171e4e3954c5807fd7b1c4a20b230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d2e5dcd1cda5e3e54fc275f92eb058"><td class="memTemplParams" colspan="2"><a id="a40d2e5dcd1cda5e3e54fc275f92eb058"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a40d2e5dcd1cda5e3e54fc275f92eb058"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a40d2e5dcd1cda5e3e54fc275f92eb058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7440a43d60d590f2e53390983851c84e"><td class="memTemplParams" colspan="2"><a id="a7440a43d60d590f2e53390983851c84e"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a7440a43d60d590f2e53390983851c84e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a7440a43d60d590f2e53390983851c84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b16396013aa8c9efde018e9fcd6e707"><td class="memTemplParams" colspan="2"><a id="a8b16396013aa8c9efde018e9fcd6e707"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a8b16396013aa8c9efde018e9fcd6e707"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a8b16396013aa8c9efde018e9fcd6e707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f8ebd27b3739cf9b4c06a2f7a42665"><td class="memTemplParams" colspan="2"><a id="aa9f8ebd27b3739cf9b4c06a2f7a42665"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:aa9f8ebd27b3739cf9b4c06a2f7a42665"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aa9f8ebd27b3739cf9b4c06a2f7a42665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada96c9c62a6993a4cc18644383068624"><td class="memTemplParams" colspan="2"><a id="ada96c9c62a6993a4cc18644383068624"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ada96c9c62a6993a4cc18644383068624"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ada96c9c62a6993a4cc18644383068624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a346165e21cadf8a191e31d4bae73a"><td class="memTemplParams" colspan="2"><a id="a85a346165e21cadf8a191e31d4bae73a"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a85a346165e21cadf8a191e31d4bae73a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a85a346165e21cadf8a191e31d4bae73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7c4ea4c6c5d3a6e11a3d04914d3218"><td class="memTemplParams" colspan="2"><a id="a7c7c4ea4c6c5d3a6e11a3d04914d3218"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a7c7c4ea4c6c5d3a6e11a3d04914d3218"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a7c7c4ea4c6c5d3a6e11a3d04914d3218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253b2fbb26ab5eeb7550c9289169fd02"><td class="memTemplParams" colspan="2"><a id="a253b2fbb26ab5eeb7550c9289169fd02"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a253b2fbb26ab5eeb7550c9289169fd02"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a253b2fbb26ab5eeb7550c9289169fd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaba88fca2574db46e2bb834a874985a"><td class="memTemplParams" colspan="2"><a id="afaba88fca2574db46e2bb834a874985a"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:afaba88fca2574db46e2bb834a874985a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:afaba88fca2574db46e2bb834a874985a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e824c36ab407b906ee383f2ca172e64"><td class="memTemplParams" colspan="2"><a id="a8e824c36ab407b906ee383f2ca172e64"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a8e824c36ab407b906ee383f2ca172e64"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a8e824c36ab407b906ee383f2ca172e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17c80dfeeb5ac7d563fa38f8db0147f"><td class="memTemplParams" colspan="2"><a id="ac17c80dfeeb5ac7d563fa38f8db0147f"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ac17c80dfeeb5ac7d563fa38f8db0147f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ac17c80dfeeb5ac7d563fa38f8db0147f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7cbf835145a81f781e5160ce73d949"><td class="memTemplParams" colspan="2"><a id="aac7cbf835145a81f781e5160ce73d949"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:aac7cbf835145a81f781e5160ce73d949"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aac7cbf835145a81f781e5160ce73d949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d34d469e08b2f602aa58f7b79b070a3"><td class="memTemplParams" colspan="2"><a id="a9d34d469e08b2f602aa58f7b79b070a3"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a9d34d469e08b2f602aa58f7b79b070a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a9d34d469e08b2f602aa58f7b79b070a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d82c6c57f5fa71ea9e9e73891e095f"><td class="memTemplParams" colspan="2"><a id="a14d82c6c57f5fa71ea9e9e73891e095f"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a14d82c6c57f5fa71ea9e9e73891e095f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a14d82c6c57f5fa71ea9e9e73891e095f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c02fbcbed816a95ab5d0d1ba38083e1"><td class="memTemplParams" colspan="2"><a id="a0c02fbcbed816a95ab5d0d1ba38083e1"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a0c02fbcbed816a95ab5d0d1ba38083e1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a0c02fbcbed816a95ab5d0d1ba38083e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48a09e8cd7ce4187908c1b8600bb97c"><td class="memTemplParams" colspan="2"><a id="ae48a09e8cd7ce4187908c1b8600bb97c"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:ae48a09e8cd7ce4187908c1b8600bb97c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ae48a09e8cd7ce4187908c1b8600bb97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab931efe137588922f0e94656ecc1f973"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:ab931efe137588922f0e94656ecc1f973"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ab931efe137588922f0e94656ecc1f973">hash_value</a> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:ab931efe137588922f0e94656ecc1f973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the hash from a given <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html" title="The basic_hashed_string_view is a compile-time hashed wrapper around a non-owning string (basic_strin...">basic_hashed_string_view</a>.  <a href="#ab931efe137588922f0e94656ecc1f973">More...</a><br /></td></tr>
<tr class="separator:ab931efe137588922f0e94656ecc1f973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cfa4752414369777c803a36bc595e8"><td class="memTemplParams" colspan="2"><a id="a16cfa4752414369777c803a36bc595e8"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a16cfa4752414369777c803a36bc595e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a16cfa4752414369777c803a36bc595e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa6ad1568938370a7ff88d2d87a1807"><td class="memTemplParams" colspan="2"><a id="a3fa6ad1568938370a7ff88d2d87a1807"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a3fa6ad1568938370a7ff88d2d87a1807"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a3fa6ad1568938370a7ff88d2d87a1807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521037ed6d846fa9a104b1450ddb0ad1"><td class="memTemplParams" colspan="2"><a id="a521037ed6d846fa9a104b1450ddb0ad1"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a521037ed6d846fa9a104b1450ddb0ad1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a521037ed6d846fa9a104b1450ddb0ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abceacab6bbe4910e8a744ffb1e5df94c"><td class="memTemplParams" colspan="2"><a id="abceacab6bbe4910e8a744ffb1e5df94c"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:abceacab6bbe4910e8a744ffb1e5df94c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:abceacab6bbe4910e8a744ffb1e5df94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16270f0a16b15dddcc04131af27a3dc4"><td class="memTemplParams" colspan="2"><a id="a16270f0a16b15dddcc04131af27a3dc4"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a16270f0a16b15dddcc04131af27a3dc4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a16270f0a16b15dddcc04131af27a3dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac421e4c5ca5f9d9b529fd302c4e0f5d"><td class="memTemplParams" colspan="2"><a id="aac421e4c5ca5f9d9b529fd302c4e0f5d"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:aac421e4c5ca5f9d9b529fd302c4e0f5d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aac421e4c5ca5f9d9b529fd302c4e0f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c9069b3af0247530dfac78370c080c"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename Iter &gt; </td></tr>
<tr class="memitem:a35c9069b3af0247530dfac78370c080c"><td class="memTemplItemLeft" align="right" valign="top">constexpr tuple_element_iterator&lt; N, Iter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a35c9069b3af0247530dfac78370c080c">make_tuple_element_iterator</a> (Iter iter)</td></tr>
<tr class="memdesc:a35c9069b3af0247530dfac78370c080c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to type-deduce and make an iterator for iterating specific tuple elements.  <a href="#a35c9069b3af0247530dfac78370c080c">More...</a><br /></td></tr>
<tr class="separator:a35c9069b3af0247530dfac78370c080c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc89f6045f99bceeb2727afc074f01f"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a6dc89f6045f99bceeb2727afc074f01f"><td class="memTemplItemLeft" align="right" valign="top">constexpr tuple_element_iterator&lt; 0, Iter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a6dc89f6045f99bceeb2727afc074f01f">make_key_iterator</a> (Iter iter)</td></tr>
<tr class="memdesc:a6dc89f6045f99bceeb2727afc074f01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for making a tuple iterator that only iterates the first tuple element, which is the key in associative containers.  <a href="#a6dc89f6045f99bceeb2727afc074f01f">More...</a><br /></td></tr>
<tr class="separator:a6dc89f6045f99bceeb2727afc074f01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc32653c70963f92afdb922bf41df9b9"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:afc32653c70963f92afdb922bf41df9b9"><td class="memTemplItemLeft" align="right" valign="top">constexpr tuple_element_iterator&lt; 1, Iter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#afc32653c70963f92afdb922bf41df9b9">make_value_iterator</a> (Iter iter)</td></tr>
<tr class="memdesc:afc32653c70963f92afdb922bf41df9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for making a tuple iterator that only iterates the second tuple element, which is the value in associative containers.  <a href="#afc32653c70963f92afdb922bf41df9b9">More...</a><br /></td></tr>
<tr class="separator:afc32653c70963f92afdb922bf41df9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b254b21c3e850abecc2b128cb236b3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a83b254b21c3e850abecc2b128cb236b3"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a83b254b21c3e850abecc2b128cb236b3">hash_value</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;val)</td></tr>
<tr class="memdesc:a83b254b21c3e850abecc2b128cb236b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a hash of the underlying lazy, instantiating it if not already instantiated.  <a href="#a83b254b21c3e850abecc2b128cb236b3">More...</a><br /></td></tr>
<tr class="separator:a83b254b21c3e850abecc2b128cb236b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea22e81640ef84b40a63a3aa0280a2f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a9ea22e81640ef84b40a63a3aa0280a2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a9ea22e81640ef84b40a63a3aa0280a2f">make_lazy</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a9ea22e81640ef84b40a63a3aa0280a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a lazy type from the given arguments.  <a href="#a9ea22e81640ef84b40a63a3aa0280a2f">More...</a><br /></td></tr>
<tr class="separator:a9ea22e81640ef84b40a63a3aa0280a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769c3379a597a59899d35d552c8a14a2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename... Args&gt; </td></tr>
<tr class="memitem:a769c3379a597a59899d35d552c8a14a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a769c3379a597a59899d35d552c8a14a2">make_lazy</a> (std::initializer_list&lt; U &gt; ilist, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a769c3379a597a59899d35d552c8a14a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a lazy type from the given arguments.  <a href="#a769c3379a597a59899d35d552c8a14a2">More...</a><br /></td></tr>
<tr class="separator:a769c3379a597a59899d35d552c8a14a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7844a4592038b7ba6cf898167d593d4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Ctor &gt; </td></tr>
<tr class="memitem:ad7844a4592038b7ba6cf898167d593d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ad7844a4592038b7ba6cf898167d593d4">make_lazy_generator</a> (Ctor &amp;&amp;ctor)</td></tr>
<tr class="memdesc:ad7844a4592038b7ba6cf898167d593d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a lazy type that uses a generator function to generate the arguments that will be forwarded to T's constructor.  <a href="#ad7844a4592038b7ba6cf898167d593d4">More...</a><br /></td></tr>
<tr class="separator:ad7844a4592038b7ba6cf898167d593d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2212f7f9bb1f2ffa862da0cbcd2301"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e2212f7f9bb1f2ffa862da0cbcd2301"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a0e2212f7f9bb1f2ffa862da0cbcd2301">swap</a> (<a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a0e2212f7f9bb1f2ffa862da0cbcd2301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the lazy from <code>lhs</code> and <code>rhs</code>.  <a href="#a0e2212f7f9bb1f2ffa862da0cbcd2301">More...</a><br /></td></tr>
<tr class="separator:a0e2212f7f9bb1f2ffa862da0cbcd2301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c2c4bcf46f871a44c4d39ae1f829c4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69c2c4bcf46f871a44c4d39ae1f829c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a69c2c4bcf46f871a44c4d39ae1f829c4">operator==</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a69c2c4bcf46f871a44c4d39ae1f829c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the left and right lazy elements together for equality, using the underlying type's operator==.  <a href="#a69c2c4bcf46f871a44c4d39ae1f829c4">More...</a><br /></td></tr>
<tr class="separator:a69c2c4bcf46f871a44c4d39ae1f829c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7b385636356ef469ca965df7b6372c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef7b385636356ef469ca965df7b6372c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aef7b385636356ef469ca965df7b6372c">operator==</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:aef7b385636356ef469ca965df7b6372c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the left and right lazy elements together for equality, using the underlying type's operator==.  <a href="#aef7b385636356ef469ca965df7b6372c">More...</a><br /></td></tr>
<tr class="separator:aef7b385636356ef469ca965df7b6372c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3a169fb3e7d89f16f12ea8d5ccd0a9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaa3a169fb3e7d89f16f12ea8d5ccd0a9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aaa3a169fb3e7d89f16f12ea8d5ccd0a9">operator==</a> (const T &amp;lhs, const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aaa3a169fb3e7d89f16f12ea8d5ccd0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the left and right lazy elements together for equality, using the underlying type's operator==.  <a href="#aaa3a169fb3e7d89f16f12ea8d5ccd0a9">More...</a><br /></td></tr>
<tr class="separator:aaa3a169fb3e7d89f16f12ea8d5ccd0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ace58348d55a83f9d4b81df99724d33"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ace58348d55a83f9d4b81df99724d33"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a0ace58348d55a83f9d4b81df99724d33">operator!=</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a0ace58348d55a83f9d4b81df99724d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the left and right lazy elements together for inequality, using the underlying type's operator!=.  <a href="#a0ace58348d55a83f9d4b81df99724d33">More...</a><br /></td></tr>
<tr class="separator:a0ace58348d55a83f9d4b81df99724d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e9db0b731c0f094b5fa4b5a248d46e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a23e9db0b731c0f094b5fa4b5a248d46e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a23e9db0b731c0f094b5fa4b5a248d46e">operator!=</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:a23e9db0b731c0f094b5fa4b5a248d46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the left and right lazy elements together for inequality, using the underlying type's operator!=.  <a href="#a23e9db0b731c0f094b5fa4b5a248d46e">More...</a><br /></td></tr>
<tr class="separator:a23e9db0b731c0f094b5fa4b5a248d46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3aa6b26006dfe792cf209e7705a192"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e3aa6b26006dfe792cf209e7705a192"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a9e3aa6b26006dfe792cf209e7705a192">operator!=</a> (const T &amp;lhs, const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9e3aa6b26006dfe792cf209e7705a192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the left and right lazy elements together for inequality, using the underlying type's operator!=.  <a href="#a9e3aa6b26006dfe792cf209e7705a192">More...</a><br /></td></tr>
<tr class="separator:a9e3aa6b26006dfe792cf209e7705a192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec221617391931c78569a3d2702b288"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2ec221617391931c78569a3d2702b288"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a2ec221617391931c78569a3d2702b288">operator&lt;</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2ec221617391931c78569a3d2702b288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>lhs</code> &lt; <code>rhs</code>, using the underlying type's <code>operator&lt;</code>.  <a href="#a2ec221617391931c78569a3d2702b288">More...</a><br /></td></tr>
<tr class="separator:a2ec221617391931c78569a3d2702b288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1aef677a777630f327620d039ec22bd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac1aef677a777630f327620d039ec22bd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ac1aef677a777630f327620d039ec22bd">operator&lt;</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:ac1aef677a777630f327620d039ec22bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>lhs</code> &lt; <code>rhs</code>, using the underlying type's <code>operator&lt;</code>.  <a href="#ac1aef677a777630f327620d039ec22bd">More...</a><br /></td></tr>
<tr class="separator:ac1aef677a777630f327620d039ec22bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65343987a73506a66147635c970ce0af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a65343987a73506a66147635c970ce0af"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a65343987a73506a66147635c970ce0af">operator&lt;</a> (const T &amp;lhs, const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a65343987a73506a66147635c970ce0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>lhs</code> &lt; <code>rhs</code>, using the underlying type's <code>operator&lt;</code>.  <a href="#a65343987a73506a66147635c970ce0af">More...</a><br /></td></tr>
<tr class="separator:a65343987a73506a66147635c970ce0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2694a1ebe40355527138a693adb98b3b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2694a1ebe40355527138a693adb98b3b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a2694a1ebe40355527138a693adb98b3b">operator&lt;=</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2694a1ebe40355527138a693adb98b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>lhs</code> &lt;= <code>rhs</code>, using the underlying type's <code>operator&lt;=</code>.  <a href="#a2694a1ebe40355527138a693adb98b3b">More...</a><br /></td></tr>
<tr class="separator:a2694a1ebe40355527138a693adb98b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbabcb48392e608812339f0f57526efb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afbabcb48392e608812339f0f57526efb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#afbabcb48392e608812339f0f57526efb">operator&lt;=</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:afbabcb48392e608812339f0f57526efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>lhs</code> &lt;= <code>rhs</code>, using the underlying type's <code>operator&lt;=</code>.  <a href="#afbabcb48392e608812339f0f57526efb">More...</a><br /></td></tr>
<tr class="separator:afbabcb48392e608812339f0f57526efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f0f2791bf66cf30bdf5311f48f6f3e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a92f0f2791bf66cf30bdf5311f48f6f3e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a92f0f2791bf66cf30bdf5311f48f6f3e">operator&lt;=</a> (const T &amp;lhs, const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a92f0f2791bf66cf30bdf5311f48f6f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>lhs</code> &lt;= <code>rhs</code>, using the underlying type's <code>operator&lt;=</code>.  <a href="#a92f0f2791bf66cf30bdf5311f48f6f3e">More...</a><br /></td></tr>
<tr class="separator:a92f0f2791bf66cf30bdf5311f48f6f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746813e83ffff1853ff45291ea291a8b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a746813e83ffff1853ff45291ea291a8b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a746813e83ffff1853ff45291ea291a8b">operator&gt;</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a746813e83ffff1853ff45291ea291a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>lhs</code> &gt; <code>rhs</code>, using the underlying type's <code>operator&gt;</code>  <a href="#a746813e83ffff1853ff45291ea291a8b">More...</a><br /></td></tr>
<tr class="separator:a746813e83ffff1853ff45291ea291a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f76db3bf68fa12d31cefd4888223bf9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9f76db3bf68fa12d31cefd4888223bf9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a9f76db3bf68fa12d31cefd4888223bf9">operator&gt;</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:a9f76db3bf68fa12d31cefd4888223bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>lhs</code> &gt; <code>rhs</code>, using the underlying type's <code>operator&gt;</code>  <a href="#a9f76db3bf68fa12d31cefd4888223bf9">More...</a><br /></td></tr>
<tr class="separator:a9f76db3bf68fa12d31cefd4888223bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775f362ae0a51d2f0125e1168a2fc590"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a775f362ae0a51d2f0125e1168a2fc590"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a775f362ae0a51d2f0125e1168a2fc590">operator&gt;</a> (const T &amp;lhs, const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a775f362ae0a51d2f0125e1168a2fc590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>lhs</code> &gt; <code>rhs</code>, using the underlying type's <code>operator&gt;</code>  <a href="#a775f362ae0a51d2f0125e1168a2fc590">More...</a><br /></td></tr>
<tr class="separator:a775f362ae0a51d2f0125e1168a2fc590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8e6565cc41cde9536df9c09e51d778"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c8e6565cc41cde9536df9c09e51d778"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a7c8e6565cc41cde9536df9c09e51d778">operator&gt;=</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7c8e6565cc41cde9536df9c09e51d778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>lhs</code> &gt;= <code>rhs</code>, using the underlying type's <code>operator&gt;=</code>.  <a href="#a7c8e6565cc41cde9536df9c09e51d778">More...</a><br /></td></tr>
<tr class="separator:a7c8e6565cc41cde9536df9c09e51d778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436993f5969646f1923b2f6f6f8e8c11"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a436993f5969646f1923b2f6f6f8e8c11"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a436993f5969646f1923b2f6f6f8e8c11">operator&gt;=</a> (const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:a436993f5969646f1923b2f6f6f8e8c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>lhs</code> &gt;= <code>rhs</code>, using the underlying type's <code>operator&gt;=</code>.  <a href="#a436993f5969646f1923b2f6f6f8e8c11">More...</a><br /></td></tr>
<tr class="separator:a436993f5969646f1923b2f6f6f8e8c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a001b72215d0b5e3721b12564542d95"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5a001b72215d0b5e3721b12564542d95"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5a001b72215d0b5e3721b12564542d95">operator&gt;=</a> (const T &amp;lhs, const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5a001b72215d0b5e3721b12564542d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if <code>lhs</code> &gt;= <code>rhs</code>, using the underlying type's <code>operator&gt;=</code>.  <a href="#a5a001b72215d0b5e3721b12564542d95">More...</a><br /></td></tr>
<tr class="separator:a5a001b72215d0b5e3721b12564542d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffa940c73f4ad283c6d1bc0042ca46b"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:abffa940c73f4ad283c6d1bc0042ca46b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#abffa940c73f4ad283c6d1bc0042ca46b">address_from</a> (InputIterator &amp;it) noexcept -&gt; typename std::iterator_traits&lt; InputIterator &gt;::value_type *</td></tr>
<tr class="memdesc:abffa940c73f4ad283c6d1bc0042ca46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the actual address of the object referenced through an iterator <code>it</code>.  <a href="#abffa940c73f4ad283c6d1bc0042ca46b">More...</a><br /></td></tr>
<tr class="separator:abffa940c73f4ad283c6d1bc0042ca46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04c12401a97f0afbb5d9863e3454b3a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af04c12401a97f0afbb5d9863e3454b3a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#af04c12401a97f0afbb5d9863e3454b3a">dereference</a> (T &amp;ptr)</td></tr>
<tr class="memdesc:af04c12401a97f0afbb5d9863e3454b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereferences all levels of pointer indirection from the supplied pointer.  <a href="#af04c12401a97f0afbb5d9863e3454b3a">More...</a><br /></td></tr>
<tr class="separator:af04c12401a97f0afbb5d9863e3454b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9807ce838e4fd230b03f9796f2203888"><td class="memItemLeft" align="right" valign="top">std::uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a9807ce838e4fd230b03f9796f2203888">to_address</a> (void *ptr) noexcept</td></tr>
<tr class="memdesc:a9807ce838e4fd230b03f9796f2203888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a pointer <code>ptr</code> into an integral type representing the address.  <a href="#a9807ce838e4fd230b03f9796f2203888">More...</a><br /></td></tr>
<tr class="separator:a9807ce838e4fd230b03f9796f2203888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2bf516ec5150488457255f5b3f63cf"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a9e2bf516ec5150488457255f5b3f63cf">from_address</a> (std::uintptr_t address) noexcept</td></tr>
<tr class="memdesc:a9e2bf516ec5150488457255f5b3f63cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a numeric address <code>address</code> into a pointer pointing to the address location.  <a href="#a9e2bf516ec5150488457255f5b3f63cf">More...</a><br /></td></tr>
<tr class="separator:a9e2bf516ec5150488457255f5b3f63cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c81704abd3426d4a4f8d644bc9cca9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a29c81704abd3426d4a4f8d644bc9cca9"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a29c81704abd3426d4a4f8d644bc9cca9">uninitialized_default_construct_at</a> (void *ptr)</td></tr>
<tr class="memdesc:a29c81704abd3426d4a4f8d644bc9cca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructs an instance of type <code>T</code> in the given memory.  <a href="#a29c81704abd3426d4a4f8d644bc9cca9">More...</a><br /></td></tr>
<tr class="separator:a29c81704abd3426d4a4f8d644bc9cca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada62bae66a9ed451d9d7078146d9a8b1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada62bae66a9ed451d9d7078146d9a8b1"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ada62bae66a9ed451d9d7078146d9a8b1">uninitialized_copy_at</a> (void *ptr, const T &amp;other)</td></tr>
<tr class="memdesc:ada62bae66a9ed451d9d7078146d9a8b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructs an instance of type <code>T</code> in the given memory.  <a href="#ada62bae66a9ed451d9d7078146d9a8b1">More...</a><br /></td></tr>
<tr class="separator:ada62bae66a9ed451d9d7078146d9a8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc02d5f264a6272ee144f7d279f6cedc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abc02d5f264a6272ee144f7d279f6cedc"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#abc02d5f264a6272ee144f7d279f6cedc">uninitialized_move_at</a> (void *ptr, T &amp;&amp;other)</td></tr>
<tr class="memdesc:abc02d5f264a6272ee144f7d279f6cedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructs an instance of type <code>T</code> in the given memory.  <a href="#abc02d5f264a6272ee144f7d279f6cedc">More...</a><br /></td></tr>
<tr class="separator:abc02d5f264a6272ee144f7d279f6cedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0dcea6d5a9e100bea41a7fdc6ef7d2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a8d0dcea6d5a9e100bea41a7fdc6ef7d2"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a8d0dcea6d5a9e100bea41a7fdc6ef7d2">uninitialized_construct_at</a> (void *ptr, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a8d0dcea6d5a9e100bea41a7fdc6ef7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an instance of type <code>T</code> with the given <code>args</code> at the memory location specified in <code>ptr</code>.  <a href="#a8d0dcea6d5a9e100bea41a7fdc6ef7d2">More...</a><br /></td></tr>
<tr class="separator:a8d0dcea6d5a9e100bea41a7fdc6ef7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c4467d16ff80fbabb5ac8bb35f8975"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tuple &gt; </td></tr>
<tr class="memitem:a24c4467d16ff80fbabb5ac8bb35f8975"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a24c4467d16ff80fbabb5ac8bb35f8975">uninitialized_tuple_construct_at</a> (void *ptr, Tuple &amp;&amp;tuple)</td></tr>
<tr class="memdesc:a24c4467d16ff80fbabb5ac8bb35f8975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an instance of type <code>T</code> with the given <code>tuple</code> at the memory location specified in <code>ptr</code>.  <a href="#a24c4467d16ff80fbabb5ac8bb35f8975">More...</a><br /></td></tr>
<tr class="separator:a24c4467d16ff80fbabb5ac8bb35f8975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ceda0466f45a09b16591ccb2de29ab4"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename... Args&gt; </td></tr>
<tr class="memitem:a5ceda0466f45a09b16591ccb2de29ab4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5ceda0466f45a09b16591ccb2de29ab4">uninitialized_construct</a> (ForwardIterator first, ForwardIterator last, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a5ceda0466f45a09b16591ccb2de29ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an instance of type <code>T</code> with the given <code>args</code> at the memory addresses in the given range [<code>first</code>, <code>last</code> )  <a href="#a5ceda0466f45a09b16591ccb2de29ab4">More...</a><br /></td></tr>
<tr class="separator:a5ceda0466f45a09b16591ccb2de29ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504a3790a931e2137cecd7bc9f53deb2"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Size , typename... Args&gt; </td></tr>
<tr class="memitem:a504a3790a931e2137cecd7bc9f53deb2"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a504a3790a931e2137cecd7bc9f53deb2">uninitialized_construct_n</a> (ForwardIterator first, Size n, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a504a3790a931e2137cecd7bc9f53deb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an instance of type <code>T</code> with the given <code>args</code> at the memory addresses in the given range [<code>first</code>, <code>first</code> + <code>n</code> )  <a href="#a504a3790a931e2137cecd7bc9f53deb2">More...</a><br /></td></tr>
<tr class="separator:a504a3790a931e2137cecd7bc9f53deb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9c14044feb39441c88d133e6f94bf9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d9c14044feb39441c88d133e6f94bf9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a6d9c14044feb39441c88d133e6f94bf9">destroy_at</a> (T *p)</td></tr>
<tr class="memdesc:a6d9c14044feb39441c88d133e6f94bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the destructor of the object pointed to by p, as if by p-&gt;~T().  <a href="#a6d9c14044feb39441c88d133e6f94bf9">More...</a><br /></td></tr>
<tr class="separator:a6d9c14044feb39441c88d133e6f94bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1691dc7bcc77311536263be8d1273d7b"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a1691dc7bcc77311536263be8d1273d7b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a1691dc7bcc77311536263be8d1273d7b">destroy</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="memdesc:a1691dc7bcc77311536263be8d1273d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the objects in the range <code></code>[first, <code>last</code>)  <a href="#a1691dc7bcc77311536263be8d1273d7b">More...</a><br /></td></tr>
<tr class="separator:a1691dc7bcc77311536263be8d1273d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bf67710219534b12e99dec573c4802"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a63bf67710219534b12e99dec573c4802"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a63bf67710219534b12e99dec573c4802">destroy_n</a> (ForwardIterator first, std::size_t n)</td></tr>
<tr class="memdesc:a63bf67710219534b12e99dec573c4802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the <code>n</code> objects in the range starting at <code>first</code>.  <a href="#a63bf67710219534b12e99dec573c4802">More...</a><br /></td></tr>
<tr class="separator:a63bf67710219534b12e99dec573c4802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf862f7facbc4267ce240a9167ce3dfa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acf862f7facbc4267ce240a9167ce3dfa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#acf862f7facbc4267ce240a9167ce3dfa">destroy_array_at</a> (T *ptr)</td></tr>
<tr class="memdesc:acf862f7facbc4267ce240a9167ce3dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an array of entries at the given <code>ptr</code>.  <a href="#acf862f7facbc4267ce240a9167ce3dfa">More...</a><br /></td></tr>
<tr class="separator:acf862f7facbc4267ce240a9167ce3dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f07967eb5d5b849827db763987c8fa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Deleter &gt; </td></tr>
<tr class="memitem:a21f07967eb5d5b849827db763987c8fa"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a21f07967eb5d5b849827db763987c8fa">hash_value</a> (const std::unique_ptr&lt; T, Deleter &gt; &amp;val) noexcept</td></tr>
<tr class="memdesc:a21f07967eb5d5b849827db763987c8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes a unique_ptr.  <a href="#a21f07967eb5d5b849827db763987c8fa">More...</a><br /></td></tr>
<tr class="separator:a21f07967eb5d5b849827db763987c8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbec1aa53918460d5481c91354848547"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acbec1aa53918460d5481c91354848547"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#acbec1aa53918460d5481c91354848547">hash_value</a> (const std::shared_ptr&lt; T &gt; &amp;val) noexcept</td></tr>
<tr class="memdesc:acbec1aa53918460d5481c91354848547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes a shared_ptr.  <a href="#acbec1aa53918460d5481c91354848547">More...</a><br /></td></tr>
<tr class="separator:acbec1aa53918460d5481c91354848547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c0ed1fbd40262a8ea362a934dec70f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a87c0ed1fbd40262a8ea362a934dec70f"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::common_type_t&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a87c0ed1fbd40262a8ea362a934dec70f">gcd</a> (const T &amp;a, const U &amp;b) noexcept</td></tr>
<tr class="memdesc:a87c0ed1fbd40262a8ea362a934dec70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common divisor of the integers <code>m</code> and <code>n</code>.  <a href="#a87c0ed1fbd40262a8ea362a934dec70f">More...</a><br /></td></tr>
<tr class="separator:a87c0ed1fbd40262a8ea362a934dec70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064c1a74dad23ef09ef9eaf423532596"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a064c1a74dad23ef09ef9eaf423532596"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::common_type_t&lt; T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a064c1a74dad23ef09ef9eaf423532596">lcm</a> (const T &amp;a, const U &amp;b) noexcept</td></tr>
<tr class="memdesc:a064c1a74dad23ef09ef9eaf423532596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the least common multiple of the integers <code>m</code> and <code>n</code>.  <a href="#a064c1a74dad23ef09ef9eaf423532596">More...</a><br /></td></tr>
<tr class="separator:a064c1a74dad23ef09ef9eaf423532596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaaba5e942c77826b17b02c17b1b11de"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaaaba5e942c77826b17b02c17b1b11de"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aaaaba5e942c77826b17b02c17b1b11de">operator==</a> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aaaaba5e942c77826b17b02c17b1b11de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs equality operation on two optionals.  <a href="#aaaaba5e942c77826b17b02c17b1b11de">More...</a><br /></td></tr>
<tr class="separator:aaaaba5e942c77826b17b02c17b1b11de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7369b94edb1aa30603f6a4295280f810"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7369b94edb1aa30603f6a4295280f810"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a7369b94edb1aa30603f6a4295280f810">operator!=</a> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7369b94edb1aa30603f6a4295280f810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs inequality operation on two optionals.  <a href="#a7369b94edb1aa30603f6a4295280f810">More...</a><br /></td></tr>
<tr class="separator:a7369b94edb1aa30603f6a4295280f810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3e384d5ee5018ce420f7282e1d6992"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaf3e384d5ee5018ce420f7282e1d6992"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aaf3e384d5ee5018ce420f7282e1d6992">operator&lt;</a> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aaf3e384d5ee5018ce420f7282e1d6992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs less-than operation on two optionals.  <a href="#aaf3e384d5ee5018ce420f7282e1d6992">More...</a><br /></td></tr>
<tr class="separator:aaf3e384d5ee5018ce420f7282e1d6992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa00301df0b90006322ef8fd5fc4f7d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9fa00301df0b90006322ef8fd5fc4f7d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a9fa00301df0b90006322ef8fd5fc4f7d">operator&gt;</a> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9fa00301df0b90006322ef8fd5fc4f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs greater-than operation on two optionals.  <a href="#a9fa00301df0b90006322ef8fd5fc4f7d">More...</a><br /></td></tr>
<tr class="separator:a9fa00301df0b90006322ef8fd5fc4f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab66a890e7dea7249c4f81241f15753"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adab66a890e7dea7249c4f81241f15753"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#adab66a890e7dea7249c4f81241f15753">operator&lt;=</a> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:adab66a890e7dea7249c4f81241f15753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs less-than or equal operation on two optionals.  <a href="#adab66a890e7dea7249c4f81241f15753">More...</a><br /></td></tr>
<tr class="separator:adab66a890e7dea7249c4f81241f15753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba083b0665196f2dab5de18013deed76"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba083b0665196f2dab5de18013deed76"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aba083b0665196f2dab5de18013deed76">operator&gt;=</a> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;lhs, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aba083b0665196f2dab5de18013deed76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs greater-than or equal operation on two optionals.  <a href="#aba083b0665196f2dab5de18013deed76">More...</a><br /></td></tr>
<tr class="separator:aba083b0665196f2dab5de18013deed76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d468ebd21c10de843bf66b67bb62651"><td class="memTemplParams" colspan="2"><a id="a8d468ebd21c10de843bf66b67bb62651"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d468ebd21c10de843bf66b67bb62651"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, <a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="separator:a8d468ebd21c10de843bf66b67bb62651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51a1322aca1335eb7c30958a9f922e3"><td class="memTemplParams" colspan="2"><a id="ad51a1322aca1335eb7c30958a9f922e3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad51a1322aca1335eb7c30958a9f922e3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt) noexcept</td></tr>
<tr class="separator:ad51a1322aca1335eb7c30958a9f922e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0743d43e39ea47c58e450d43d3c99f"><td class="memTemplParams" colspan="2"><a id="a9c0743d43e39ea47c58e450d43d3c99f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9c0743d43e39ea47c58e450d43d3c99f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, <a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="separator:a9c0743d43e39ea47c58e450d43d3c99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7429fed1de43b0a99218e8df8f7bc84d"><td class="memTemplParams" colspan="2"><a id="a7429fed1de43b0a99218e8df8f7bc84d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7429fed1de43b0a99218e8df8f7bc84d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt) noexcept</td></tr>
<tr class="separator:a7429fed1de43b0a99218e8df8f7bc84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21838e498bbc3b46b470f6a0d1d577b6"><td class="memTemplParams" colspan="2"><a id="a21838e498bbc3b46b470f6a0d1d577b6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a21838e498bbc3b46b470f6a0d1d577b6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, <a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="separator:a21838e498bbc3b46b470f6a0d1d577b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1745c626ec88eb59f3a74ceb9b07854a"><td class="memTemplParams" colspan="2"><a id="a1745c626ec88eb59f3a74ceb9b07854a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1745c626ec88eb59f3a74ceb9b07854a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (<a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt) noexcept</td></tr>
<tr class="separator:a1745c626ec88eb59f3a74ceb9b07854a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d97b22733867e49e2c2d4f08acbc2c"><td class="memTemplParams" colspan="2"><a id="a44d97b22733867e49e2c2d4f08acbc2c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a44d97b22733867e49e2c2d4f08acbc2c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, <a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="separator:a44d97b22733867e49e2c2d4f08acbc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c817ef96b40431e90522aec5497b30"><td class="memTemplParams" colspan="2"><a id="ad6c817ef96b40431e90522aec5497b30"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad6c817ef96b40431e90522aec5497b30"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (<a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt) noexcept</td></tr>
<tr class="separator:ad6c817ef96b40431e90522aec5497b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89ecfb5d05172a7b52e27bcdc6afae0"><td class="memTemplParams" colspan="2"><a id="af89ecfb5d05172a7b52e27bcdc6afae0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af89ecfb5d05172a7b52e27bcdc6afae0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, <a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="separator:af89ecfb5d05172a7b52e27bcdc6afae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89e286747f45b323c53c977331c5c18"><td class="memTemplParams" colspan="2"><a id="af89e286747f45b323c53c977331c5c18"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af89e286747f45b323c53c977331c5c18"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (<a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt) noexcept</td></tr>
<tr class="separator:af89e286747f45b323c53c977331c5c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171b376a8a6730142c6a1cd5112d81ca"><td class="memTemplParams" colspan="2"><a id="a171b376a8a6730142c6a1cd5112d81ca"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a171b376a8a6730142c6a1cd5112d81ca"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, <a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="separator:a171b376a8a6730142c6a1cd5112d81ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad213ee2af8b22973824008ad9e854f51"><td class="memTemplParams" colspan="2"><a id="ad213ee2af8b22973824008ad9e854f51"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad213ee2af8b22973824008ad9e854f51"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (<a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt) noexcept</td></tr>
<tr class="separator:ad213ee2af8b22973824008ad9e854f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10161d16c7af018164476d9c6376fbdf"><td class="memTemplParams" colspan="2"><a id="a10161d16c7af018164476d9c6376fbdf"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a10161d16c7af018164476d9c6376fbdf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, const T &amp;value)</td></tr>
<tr class="separator:a10161d16c7af018164476d9c6376fbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa708b85854276fe0c7ee60857abc57a0"><td class="memTemplParams" colspan="2"><a id="aa708b85854276fe0c7ee60857abc57a0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa708b85854276fe0c7ee60857abc57a0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const T &amp;value, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt)</td></tr>
<tr class="separator:aa708b85854276fe0c7ee60857abc57a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec705ac977aafbb2d61936df90db0011"><td class="memTemplParams" colspan="2"><a id="aec705ac977aafbb2d61936df90db0011"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec705ac977aafbb2d61936df90db0011"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, const T &amp;value)</td></tr>
<tr class="separator:aec705ac977aafbb2d61936df90db0011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084d90c38a8295362eeaad9845527c77"><td class="memTemplParams" colspan="2"><a id="a084d90c38a8295362eeaad9845527c77"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a084d90c38a8295362eeaad9845527c77"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const T &amp;value, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt)</td></tr>
<tr class="separator:a084d90c38a8295362eeaad9845527c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a5690de559eedd892b5835a3b64730"><td class="memTemplParams" colspan="2"><a id="a34a5690de559eedd892b5835a3b64730"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a34a5690de559eedd892b5835a3b64730"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, const T &amp;value)</td></tr>
<tr class="separator:a34a5690de559eedd892b5835a3b64730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96f5dfd64a567b611e278dad6e130c6"><td class="memTemplParams" colspan="2"><a id="ae96f5dfd64a567b611e278dad6e130c6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae96f5dfd64a567b611e278dad6e130c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const T &amp;value, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt)</td></tr>
<tr class="separator:ae96f5dfd64a567b611e278dad6e130c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65708fafc93c59842f0c5c612ea8ece"><td class="memTemplParams" colspan="2"><a id="aa65708fafc93c59842f0c5c612ea8ece"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa65708fafc93c59842f0c5c612ea8ece"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, const T &amp;value)</td></tr>
<tr class="separator:aa65708fafc93c59842f0c5c612ea8ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa956802d5615065acf18021fc03a63e8"><td class="memTemplParams" colspan="2"><a id="aa956802d5615065acf18021fc03a63e8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa956802d5615065acf18021fc03a63e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const T &amp;value, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt)</td></tr>
<tr class="separator:aa956802d5615065acf18021fc03a63e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f5db6b83313d46213f05358da1936b"><td class="memTemplParams" colspan="2"><a id="ad5f5db6b83313d46213f05358da1936b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad5f5db6b83313d46213f05358da1936b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, const T &amp;value)</td></tr>
<tr class="separator:ad5f5db6b83313d46213f05358da1936b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0e944f121c45962d6ad972f3948480"><td class="memTemplParams" colspan="2"><a id="aca0e944f121c45962d6ad972f3948480"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca0e944f121c45962d6ad972f3948480"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const T &amp;value, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt)</td></tr>
<tr class="separator:aca0e944f121c45962d6ad972f3948480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2967a4e7a60a01d4a0eb053a27b3b1"><td class="memTemplParams" colspan="2"><a id="abf2967a4e7a60a01d4a0eb053a27b3b1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abf2967a4e7a60a01d4a0eb053a27b3b1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt, const T &amp;value)</td></tr>
<tr class="separator:abf2967a4e7a60a01d4a0eb053a27b3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44347c35d9b6f432ba1b5c90075b7edc"><td class="memTemplParams" colspan="2"><a id="a44347c35d9b6f432ba1b5c90075b7edc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a44347c35d9b6f432ba1b5c90075b7edc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const T &amp;value, const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;opt)</td></tr>
<tr class="separator:a44347c35d9b6f432ba1b5c90075b7edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1685414ab5b9729175258024c1f034a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad1685414ab5b9729175258024c1f034a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; std::decay_t&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ad1685414ab5b9729175258024c1f034a">make_optional</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:ad1685414ab5b9729175258024c1f034a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an optional object from <code>value</code>.  <a href="#ad1685414ab5b9729175258024c1f034a">More...</a><br /></td></tr>
<tr class="separator:ad1685414ab5b9729175258024c1f034a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c586d69708cf2aa3d6196f5c38e5edd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a4c586d69708cf2aa3d6196f5c38e5edd"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a4c586d69708cf2aa3d6196f5c38e5edd">make_optional</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a4c586d69708cf2aa3d6196f5c38e5edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an optional object of type <code>T</code> from the given <code>args</code>.  <a href="#a4c586d69708cf2aa3d6196f5c38e5edd">More...</a><br /></td></tr>
<tr class="separator:a4c586d69708cf2aa3d6196f5c38e5edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcc7a61cae2e21593e248e3996eac0c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename... Args&gt; </td></tr>
<tr class="memitem:abdcc7a61cae2e21593e248e3996eac0c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#abdcc7a61cae2e21593e248e3996eac0c">make_optional</a> (std::initializer_list&lt; U &gt; il, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:abdcc7a61cae2e21593e248e3996eac0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an optional object of type <code>T</code> from the given <code>il</code> <code>args</code>.  <a href="#abdcc7a61cae2e21593e248e3996eac0c">More...</a><br /></td></tr>
<tr class="separator:abdcc7a61cae2e21593e248e3996eac0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fc15967879a2d062e81cf59e4b80c5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a39fc15967879a2d062e81cf59e4b80c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a39fc15967879a2d062e81cf59e4b80c5">swap</a> (<a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;lhs, <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a39fc15967879a2d062e81cf59e4b80c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <code>lhs</code> and <code>rhs</code>.  <a href="#a39fc15967879a2d062e81cf59e4b80c5">More...</a><br /></td></tr>
<tr class="separator:a39fc15967879a2d062e81cf59e4b80c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4f9bef5f51b8b9fde39f5ab1b29212"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0d4f9bef5f51b8b9fde39f5ab1b29212"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a0d4f9bef5f51b8b9fde39f5ab1b29212">hash_value</a> (const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;s) noexcept</td></tr>
<tr class="memdesc:a0d4f9bef5f51b8b9fde39f5ab1b29212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the hash from a given optional.  <a href="#a0d4f9bef5f51b8b9fde39f5ab1b29212">More...</a><br /></td></tr>
<tr class="separator:a0d4f9bef5f51b8b9fde39f5ab1b29212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44311fa8af9c4066b4aff80158e37429"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a44311fa8af9c4066b4aff80158e37429"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/dde/classbit_1_1stl_1_1pointer__wrapper.html">pointer_wrapper</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a44311fa8af9c4066b4aff80158e37429">make_pointer_wrapper</a> (Args &amp;&amp;...args) noexcept(std::is_nothrow_constructible&lt; T, Args... &gt;::value)</td></tr>
<tr class="memdesc:a44311fa8af9c4066b4aff80158e37429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a <a class="el" href="../../d6/dde/classbit_1_1stl_1_1pointer__wrapper.html" title="A wrapper type around a given type that allows it to be treated with pointer-semantics instead of ref...">pointer_wrapper</a> of the underlying type.  <a href="#a44311fa8af9c4066b4aff80158e37429">More...</a><br /></td></tr>
<tr class="separator:a44311fa8af9c4066b4aff80158e37429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f242f7df14fb4961730a553e96084b2"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S &gt; </td></tr>
<tr class="memitem:a0f242f7df14fb4961730a553e96084b2"><td class="memTemplItemLeft" align="right" valign="top">constexpr range&lt; I, S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a0f242f7df14fb4961730a553e96084b2">make_range</a> (I iterator, S sentinel)</td></tr>
<tr class="memdesc:a0f242f7df14fb4961730a553e96084b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a range from a given <code>iterator</code> <code>sentinel</code> pair.  <a href="#a0f242f7df14fb4961730a553e96084b2">More...</a><br /></td></tr>
<tr class="separator:a0f242f7df14fb4961730a553e96084b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23ff312d0bacfde323a4daa9e92da83"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:ab23ff312d0bacfde323a4daa9e92da83"><td class="memTemplItemLeft" align="right" valign="top">constexpr Range &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ab23ff312d0bacfde323a4daa9e92da83">make_range</a> (Range &amp;&amp;range)</td></tr>
<tr class="memdesc:ab23ff312d0bacfde323a4daa9e92da83"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function acts as an identity function, and exists solely for completion.  <a href="#ab23ff312d0bacfde323a4daa9e92da83">More...</a><br /></td></tr>
<tr class="separator:ab23ff312d0bacfde323a4daa9e92da83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7352c33e18cc147a4533ab1c7e1b9d4d"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename I , typename S &gt; </td></tr>
<tr class="memitem:a7352c33e18cc147a4533ab1c7e1b9d4d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a7352c33e18cc147a4533ab1c7e1b9d4d">make_tuple_element_range</a> (I iterator, S sentinel) -&gt; range&lt; tuple_element_iterator&lt; N, I &gt;, tuple_element_iterator&lt; N, S &gt;&gt;</td></tr>
<tr class="memdesc:a7352c33e18cc147a4533ab1c7e1b9d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a range from a given <code>iterator</code> <code>sentinel</code> pair iterating values of a given tuple.  <a href="#a7352c33e18cc147a4533ab1c7e1b9d4d">More...</a><br /></td></tr>
<tr class="separator:a7352c33e18cc147a4533ab1c7e1b9d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643bd0d2baac568efa86e1dbd43dea20"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename Range &gt; </td></tr>
<tr class="memitem:a643bd0d2baac568efa86e1dbd43dea20"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a643bd0d2baac568efa86e1dbd43dea20">make_tuple_element_range</a> (Range &amp;&amp;r) -&gt; decltype(make_tuple_element_range(r.begin(), r.end()))</td></tr>
<tr class="memdesc:a643bd0d2baac568efa86e1dbd43dea20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a tuple element range from a range.  <a href="#a643bd0d2baac568efa86e1dbd43dea20">More...</a><br /></td></tr>
<tr class="separator:a643bd0d2baac568efa86e1dbd43dea20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6396e40adc7ac96d04f3a51b6fa869bb"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S &gt; </td></tr>
<tr class="memitem:a6396e40adc7ac96d04f3a51b6fa869bb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a6396e40adc7ac96d04f3a51b6fa869bb">make_key_range</a> (I iterator, S sentinel) -&gt; range&lt; tuple_element_iterator&lt; 0, I &gt;, tuple_element_iterator&lt; 0, S &gt;&gt;</td></tr>
<tr class="memdesc:a6396e40adc7ac96d04f3a51b6fa869bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a range from a given <code>iterator</code> <code>sentinel</code> pair iterating the first value of a given tuple.  <a href="#a6396e40adc7ac96d04f3a51b6fa869bb">More...</a><br /></td></tr>
<tr class="separator:a6396e40adc7ac96d04f3a51b6fa869bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b291d11c52d94444f2625dcefb69da"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:a44b291d11c52d94444f2625dcefb69da"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a44b291d11c52d94444f2625dcefb69da">make_key_range</a> (Range &amp;&amp;r) -&gt; decltype(make_key_range(r.begin(), r.end()))</td></tr>
<tr class="memdesc:a44b291d11c52d94444f2625dcefb69da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a key range from another range.  <a href="#a44b291d11c52d94444f2625dcefb69da">More...</a><br /></td></tr>
<tr class="separator:a44b291d11c52d94444f2625dcefb69da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc06ca40f67c1f36c538b129d94e1648"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S &gt; </td></tr>
<tr class="memitem:abc06ca40f67c1f36c538b129d94e1648"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#abc06ca40f67c1f36c538b129d94e1648">make_value_range</a> (I iterator, S sentinel) -&gt; range&lt; tuple_element_iterator&lt; 1, I &gt;, tuple_element_iterator&lt; 1, S &gt;&gt;</td></tr>
<tr class="memdesc:abc06ca40f67c1f36c538b129d94e1648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a range from a given <code>iterator</code> <code>sentinel</code> pair iterating the second value of a given tuple.  <a href="#abc06ca40f67c1f36c538b129d94e1648">More...</a><br /></td></tr>
<tr class="separator:abc06ca40f67c1f36c538b129d94e1648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b8bd09adc8ff6908217ee5b913628b"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:a90b8bd09adc8ff6908217ee5b913628b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a90b8bd09adc8ff6908217ee5b913628b">make_value_range</a> (Range &amp;&amp;r) -&gt; decltype(make_value_range(r.begin(), r.end()))</td></tr>
<tr class="memdesc:a90b8bd09adc8ff6908217ee5b913628b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a value range from another range.  <a href="#a90b8bd09adc8ff6908217ee5b913628b">More...</a><br /></td></tr>
<tr class="separator:a90b8bd09adc8ff6908217ee5b913628b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d87ecf8388e99a7309e1ba5d63ccd2"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S &gt; </td></tr>
<tr class="memitem:a06d87ecf8388e99a7309e1ba5d63ccd2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a06d87ecf8388e99a7309e1ba5d63ccd2">make_move_range</a> (I iterator, S sentinel) -&gt; range&lt; std::move_iterator&lt; I &gt;, std::move_iterator&lt; S &gt;&gt;</td></tr>
<tr class="memdesc:a06d87ecf8388e99a7309e1ba5d63ccd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a movable range from a given <code>iterator</code> <code>sentinal</code> pair.  <a href="#a06d87ecf8388e99a7309e1ba5d63ccd2">More...</a><br /></td></tr>
<tr class="separator:a06d87ecf8388e99a7309e1ba5d63ccd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd4d204c6360d55e80c63411164decb"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:a6fd4d204c6360d55e80c63411164decb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a6fd4d204c6360d55e80c63411164decb">make_move_range</a> (Range &amp;&amp;r) -&gt; decltype(make_move_range(r.begin(), r.end()))</td></tr>
<tr class="memdesc:a6fd4d204c6360d55e80c63411164decb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a reverse range from a given <code>iterator</code> <code>sentinal</code> pair.  <a href="#a6fd4d204c6360d55e80c63411164decb">More...</a><br /></td></tr>
<tr class="separator:a6fd4d204c6360d55e80c63411164decb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1273582ac976cd6a10f739435bbbeb"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:a9d1273582ac976cd6a10f739435bbbeb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a9d1273582ac976cd6a10f739435bbbeb">make_reverse_range</a> (Range &amp;&amp;r) -&gt; decltype(<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a0f242f7df14fb4961730a553e96084b2">make_range</a>(r.rbegin(), r.rend()))</td></tr>
<tr class="memdesc:a9d1273582ac976cd6a10f739435bbbeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a reverse range from a given <code>iterator</code> <code>sentinal</code> pair.  <a href="#a9d1273582ac976cd6a10f739435bbbeb">More...</a><br /></td></tr>
<tr class="separator:a9d1273582ac976cd6a10f739435bbbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693d147e24e4c92faeec5a88502ad576"><td class="memTemplParams" colspan="2">template&lt;typename Range0 , typename... RangeN&gt; </td></tr>
<tr class="memitem:a693d147e24e4c92faeec5a88502ad576"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a693d147e24e4c92faeec5a88502ad576">make_zip_range</a> (Range0 &amp;&amp;r0, RangeN &amp;&amp;...rn) -&gt; range&lt; zip_iterator&lt; decltype(std::declval&lt; Range0 &gt;().begin()), decltype(std::declval&lt; RangeN &gt;().begin())... &gt;, zip_iterator&lt; decltype(std::declval&lt; Range0 &gt;().end()), decltype(std::declval&lt; RangeN &gt;().end())... &gt;&gt;</td></tr>
<tr class="memdesc:a693d147e24e4c92faeec5a88502ad576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a zip range from a selection of zip iterators.  <a href="#a693d147e24e4c92faeec5a88502ad576">More...</a><br /></td></tr>
<tr class="separator:a693d147e24e4c92faeec5a88502ad576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2a34d2c6d7bbb220c7d8ac2a79c458"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a4f2a34d2c6d7bbb220c7d8ac2a79c458">operator==</a> (const <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html">source_location</a> &amp;lhs, const <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html">source_location</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a4f2a34d2c6d7bbb220c7d8ac2a79c458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines equality between two source_locations.  <a href="#a4f2a34d2c6d7bbb220c7d8ac2a79c458">More...</a><br /></td></tr>
<tr class="separator:a4f2a34d2c6d7bbb220c7d8ac2a79c458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae180be04635d8455a78ecd80b67ffe55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ae180be04635d8455a78ecd80b67ffe55">operator!=</a> (const <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html">source_location</a> &amp;lhs, const <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html">source_location</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ae180be04635d8455a78ecd80b67ffe55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines inequality between two source_locations.  <a href="#ae180be04635d8455a78ecd80b67ffe55">More...</a><br /></td></tr>
<tr class="separator:ae180be04635d8455a78ecd80b67ffe55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949bcb6cedbc08ec6aac45fc2ed17e51"><td class="memTemplParams" colspan="2">template&lt;typename T , std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a949bcb6cedbc08ec6aac45fc2ed17e51"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a949bcb6cedbc08ec6aac45fc2ed17e51">operator==</a> (const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;lhs, const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a949bcb6cedbc08ec6aac45fc2ed17e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs equality comparison between all entries in the span.  <a href="#a949bcb6cedbc08ec6aac45fc2ed17e51">More...</a><br /></td></tr>
<tr class="separator:a949bcb6cedbc08ec6aac45fc2ed17e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef95178467c3eb83c8c648eb062333b"><td class="memTemplParams" colspan="2">template&lt;typename T , std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a0ef95178467c3eb83c8c648eb062333b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a0ef95178467c3eb83c8c648eb062333b">operator!=</a> (const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;lhs, const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a0ef95178467c3eb83c8c648eb062333b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs inequality comparison between all entries in the span.  <a href="#a0ef95178467c3eb83c8c648eb062333b">More...</a><br /></td></tr>
<tr class="separator:a0ef95178467c3eb83c8c648eb062333b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af144d9c063aae932355474287ad14759"><td class="memTemplParams" colspan="2">template&lt;typename T , std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:af144d9c063aae932355474287ad14759"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#af144d9c063aae932355474287ad14759">operator&lt;</a> (const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;lhs, const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:af144d9c063aae932355474287ad14759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexographically compares all entries in the span.  <a href="#af144d9c063aae932355474287ad14759">More...</a><br /></td></tr>
<tr class="separator:af144d9c063aae932355474287ad14759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3ac8246dbe309e18132145a226d5f9"><td class="memTemplParams" colspan="2">template&lt;typename T , std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:acc3ac8246dbe309e18132145a226d5f9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#acc3ac8246dbe309e18132145a226d5f9">operator&lt;=</a> (const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;lhs, const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:acc3ac8246dbe309e18132145a226d5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexographically compares all entries in the span.  <a href="#acc3ac8246dbe309e18132145a226d5f9">More...</a><br /></td></tr>
<tr class="separator:acc3ac8246dbe309e18132145a226d5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d826a3a556768ab643121194d3d5d3"><td class="memTemplParams" colspan="2">template&lt;typename T , std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a46d826a3a556768ab643121194d3d5d3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a46d826a3a556768ab643121194d3d5d3">operator&gt;</a> (const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;lhs, const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a46d826a3a556768ab643121194d3d5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexographically compares all entries in the span.  <a href="#a46d826a3a556768ab643121194d3d5d3">More...</a><br /></td></tr>
<tr class="separator:a46d826a3a556768ab643121194d3d5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4850b6a62191725450ad5a4c37dfdbcd"><td class="memTemplParams" colspan="2">template&lt;typename T , std::ptrdiff_t Extent&gt; </td></tr>
<tr class="memitem:a4850b6a62191725450ad5a4c37dfdbcd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a4850b6a62191725450ad5a4c37dfdbcd">operator&gt;=</a> (const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;lhs, const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a4850b6a62191725450ad5a4c37dfdbcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexographically compares all entries in the span.  <a href="#a4850b6a62191725450ad5a4c37dfdbcd">More...</a><br /></td></tr>
<tr class="separator:a4850b6a62191725450ad5a4c37dfdbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f350703033effb94b5441aa17bccc02"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a6f350703033effb94b5441aa17bccc02"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a6f350703033effb94b5441aa17bccc02">hash_value</a> (const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:a6f350703033effb94b5441aa17bccc02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes a std::basic_string.  <a href="#a6f350703033effb94b5441aa17bccc02">More...</a><br /></td></tr>
<tr class="separator:a6f350703033effb94b5441aa17bccc02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca339d8647a8939fccfe7e0aef8b9d7"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:adca339d8647a8939fccfe7e0aef8b9d7"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#adca339d8647a8939fccfe7e0aef8b9d7">hash_value</a> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;str) noexcept</td></tr>
<tr class="memdesc:adca339d8647a8939fccfe7e0aef8b9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the hash from a given <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html" title="A wrapper around non-owned strings. ">basic_string_view</a>.  <a href="#adca339d8647a8939fccfe7e0aef8b9d7">More...</a><br /></td></tr>
<tr class="separator:adca339d8647a8939fccfe7e0aef8b9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1580085f3114393d66c277bc11cb5690"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a1580085f3114393d66c277bc11cb5690"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; CharT, Traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a1580085f3114393d66c277bc11cb5690">operator&lt;&lt;</a> (std::basic_ostream&lt; CharT, Traits &gt; &amp;o, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;str)</td></tr>
<tr class="memdesc:a1580085f3114393d66c277bc11cb5690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for ostream output of <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html" title="A wrapper around non-owned strings. ">basic_string_view</a>.  <a href="#a1580085f3114393d66c277bc11cb5690">More...</a><br /></td></tr>
<tr class="separator:a1580085f3114393d66c277bc11cb5690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b18b47d716b42f23afa68f5b197f97"><td class="memTemplParams" colspan="2"><a id="ae8b18b47d716b42f23afa68f5b197f97"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:ae8b18b47d716b42f23afa68f5b197f97"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ae8b18b47d716b42f23afa68f5b197f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba40e0a952f28127626caa2438700a5c"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:aba40e0a952f28127626caa2438700a5c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aba40e0a952f28127626caa2438700a5c">operator==</a> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aba40e0a952f28127626caa2438700a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares equality between the two basic_string_views.  <a href="#aba40e0a952f28127626caa2438700a5c">More...</a><br /></td></tr>
<tr class="separator:aba40e0a952f28127626caa2438700a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cfdb2919ae50381d788a8eb25bb630"><td class="memTemplParams" colspan="2"><a id="a04cfdb2919ae50381d788a8eb25bb630"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a04cfdb2919ae50381d788a8eb25bb630"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, CharT(&amp;rhs)[N]) noexcept</td></tr>
<tr class="separator:a04cfdb2919ae50381d788a8eb25bb630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76194ef979bd8ac49293cb8c0c210a0"><td class="memTemplParams" colspan="2"><a id="ac76194ef979bd8ac49293cb8c0c210a0"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:ac76194ef979bd8ac49293cb8c0c210a0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (CharT(&amp;lhs)[N], const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ac76194ef979bd8ac49293cb8c0c210a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc0ff5eabe69aadb187f469a107726f"><td class="memTemplParams" colspan="2"><a id="a6cc0ff5eabe69aadb187f469a107726f"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a6cc0ff5eabe69aadb187f469a107726f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; lhs, const CharT *rhs) noexcept</td></tr>
<tr class="separator:a6cc0ff5eabe69aadb187f469a107726f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad368a5dbaf54db47d245458ccc64fbf4"><td class="memTemplParams" colspan="2"><a id="ad368a5dbaf54db47d245458ccc64fbf4"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:ad368a5dbaf54db47d245458ccc64fbf4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const CharT *lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ad368a5dbaf54db47d245458ccc64fbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae57d4d7aaba4d6f20bb720ed6b981d"><td class="memTemplParams" colspan="2"><a id="a2ae57d4d7aaba4d6f20bb720ed6b981d"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a2ae57d4d7aaba4d6f20bb720ed6b981d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a2ae57d4d7aaba4d6f20bb720ed6b981d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a21f9661cd4b6cb064189b3f03444db"><td class="memTemplParams" colspan="2"><a id="a2a21f9661cd4b6cb064189b3f03444db"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a2a21f9661cd4b6cb064189b3f03444db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a2a21f9661cd4b6cb064189b3f03444db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf027ebca228450fda5cef3c2c60d3c"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a2bf027ebca228450fda5cef3c2c60d3c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a2bf027ebca228450fda5cef3c2c60d3c">operator!=</a> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a2bf027ebca228450fda5cef3c2c60d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares inequality between the two basic_string_views.  <a href="#a2bf027ebca228450fda5cef3c2c60d3c">More...</a><br /></td></tr>
<tr class="separator:a2bf027ebca228450fda5cef3c2c60d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7dce5eff3ab071fd6f339da0b31018"><td class="memTemplParams" colspan="2"><a id="a6c7dce5eff3ab071fd6f339da0b31018"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a6c7dce5eff3ab071fd6f339da0b31018"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, CharT(&amp;rhs)[N]) noexcept</td></tr>
<tr class="separator:a6c7dce5eff3ab071fd6f339da0b31018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a4a193c01a969387b95851a91a0324"><td class="memTemplParams" colspan="2"><a id="ac9a4a193c01a969387b95851a91a0324"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:ac9a4a193c01a969387b95851a91a0324"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (CharT(&amp;lhs)[N], const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ac9a4a193c01a969387b95851a91a0324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a06bbfb2b9b6eb6ec4365aa52ef899a"><td class="memTemplParams" colspan="2"><a id="a0a06bbfb2b9b6eb6ec4365aa52ef899a"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a0a06bbfb2b9b6eb6ec4365aa52ef899a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const CharT *rhs) noexcept</td></tr>
<tr class="separator:a0a06bbfb2b9b6eb6ec4365aa52ef899a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36ac1a107cb00d968e4fc0ded13e954"><td class="memTemplParams" colspan="2"><a id="af36ac1a107cb00d968e4fc0ded13e954"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:af36ac1a107cb00d968e4fc0ded13e954"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const CharT *lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:af36ac1a107cb00d968e4fc0ded13e954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a640f943a56759d2ceb7245914bd10"><td class="memTemplParams" colspan="2"><a id="a86a640f943a56759d2ceb7245914bd10"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a86a640f943a56759d2ceb7245914bd10"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a86a640f943a56759d2ceb7245914bd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae463892264f6cc2ee3630f5c55a363a2"><td class="memTemplParams" colspan="2"><a id="ae463892264f6cc2ee3630f5c55a363a2"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ae463892264f6cc2ee3630f5c55a363a2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ae463892264f6cc2ee3630f5c55a363a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415444efbcfeefad454cd010cc9b344f"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a415444efbcfeefad454cd010cc9b344f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a415444efbcfeefad454cd010cc9b344f">operator&lt;</a> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a415444efbcfeefad454cd010cc9b344f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the left string is less than the right substring.  <a href="#a415444efbcfeefad454cd010cc9b344f">More...</a><br /></td></tr>
<tr class="separator:a415444efbcfeefad454cd010cc9b344f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6cb30c565041da9ed9c59e954a3ddf"><td class="memTemplParams" colspan="2"><a id="a4d6cb30c565041da9ed9c59e954a3ddf"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a4d6cb30c565041da9ed9c59e954a3ddf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, CharT(&amp;rhs)[N]) noexcept</td></tr>
<tr class="separator:a4d6cb30c565041da9ed9c59e954a3ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd45f38b3f0fb5228de886e6ab35568"><td class="memTemplParams" colspan="2"><a id="a3dd45f38b3f0fb5228de886e6ab35568"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a3dd45f38b3f0fb5228de886e6ab35568"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (CharT(&amp;lhs)[N], const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a3dd45f38b3f0fb5228de886e6ab35568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74ca39e25eaebde57a0244ec1e22f89"><td class="memTemplParams" colspan="2"><a id="af74ca39e25eaebde57a0244ec1e22f89"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:af74ca39e25eaebde57a0244ec1e22f89"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const CharT *rhs) noexcept</td></tr>
<tr class="separator:af74ca39e25eaebde57a0244ec1e22f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1651b7ea5e9e84469ff1a87feba6352d"><td class="memTemplParams" colspan="2"><a id="a1651b7ea5e9e84469ff1a87feba6352d"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a1651b7ea5e9e84469ff1a87feba6352d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const CharT *lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a1651b7ea5e9e84469ff1a87feba6352d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d706a523945548758e85dc1df63764"><td class="memTemplParams" colspan="2"><a id="a19d706a523945548758e85dc1df63764"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a19d706a523945548758e85dc1df63764"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a19d706a523945548758e85dc1df63764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f25173ae7991dd1e66ea68eec4f7955"><td class="memTemplParams" colspan="2"><a id="a9f25173ae7991dd1e66ea68eec4f7955"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a9f25173ae7991dd1e66ea68eec4f7955"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a9f25173ae7991dd1e66ea68eec4f7955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b91bebb63c963188f090691677e815"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a69b91bebb63c963188f090691677e815"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a69b91bebb63c963188f090691677e815">operator&gt;</a> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a69b91bebb63c963188f090691677e815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab738bc42afbf78cb4dbaeb61acc9a3e2"><td class="memTemplParams" colspan="2"><a id="ab738bc42afbf78cb4dbaeb61acc9a3e2"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:ab738bc42afbf78cb4dbaeb61acc9a3e2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, CharT(&amp;rhs)[N]) noexcept</td></tr>
<tr class="separator:ab738bc42afbf78cb4dbaeb61acc9a3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0402cf09f11089c1378ec40199b4de23"><td class="memTemplParams" colspan="2"><a id="a0402cf09f11089c1378ec40199b4de23"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a0402cf09f11089c1378ec40199b4de23"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (CharT(&amp;lhs)[N], const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a0402cf09f11089c1378ec40199b4de23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2575e73f2cb4e5a9b345e083deea646"><td class="memTemplParams" colspan="2"><a id="ab2575e73f2cb4e5a9b345e083deea646"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:ab2575e73f2cb4e5a9b345e083deea646"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const CharT *rhs) noexcept</td></tr>
<tr class="separator:ab2575e73f2cb4e5a9b345e083deea646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e35a2d2ef2cd6322c380eb41e8a0778"><td class="memTemplParams" colspan="2"><a id="a4e35a2d2ef2cd6322c380eb41e8a0778"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a4e35a2d2ef2cd6322c380eb41e8a0778"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const CharT *lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a4e35a2d2ef2cd6322c380eb41e8a0778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539f5f98e11d8b2c8dbc1c0285e833b7"><td class="memTemplParams" colspan="2"><a id="a539f5f98e11d8b2c8dbc1c0285e833b7"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a539f5f98e11d8b2c8dbc1c0285e833b7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a539f5f98e11d8b2c8dbc1c0285e833b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af007b68abef36d1a098334fe7874d2e0"><td class="memTemplParams" colspan="2"><a id="af007b68abef36d1a098334fe7874d2e0"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:af007b68abef36d1a098334fe7874d2e0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:af007b68abef36d1a098334fe7874d2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26180d86b4a63447cb01a783830c132"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:aa26180d86b4a63447cb01a783830c132"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aa26180d86b4a63447cb01a783830c132">operator&lt;=</a> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aa26180d86b4a63447cb01a783830c132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82932b40acc93e5e80787626764fd16"><td class="memTemplParams" colspan="2"><a id="ac82932b40acc93e5e80787626764fd16"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:ac82932b40acc93e5e80787626764fd16"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, CharT(&amp;rhs)[N]) noexcept</td></tr>
<tr class="separator:ac82932b40acc93e5e80787626764fd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ae3dd067e28d330495df20a78694fc"><td class="memTemplParams" colspan="2"><a id="a17ae3dd067e28d330495df20a78694fc"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a17ae3dd067e28d330495df20a78694fc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (CharT(&amp;lhs)[N], const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a17ae3dd067e28d330495df20a78694fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98145429af3ea46b4cf6cb38f119b909"><td class="memTemplParams" colspan="2"><a id="a98145429af3ea46b4cf6cb38f119b909"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a98145429af3ea46b4cf6cb38f119b909"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const CharT *rhs) noexcept</td></tr>
<tr class="separator:a98145429af3ea46b4cf6cb38f119b909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff07010e479b43f73503fcbb76647df"><td class="memTemplParams" colspan="2"><a id="a4ff07010e479b43f73503fcbb76647df"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a4ff07010e479b43f73503fcbb76647df"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const CharT *lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a4ff07010e479b43f73503fcbb76647df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203fbef324541c74f6ecfca523e44f45"><td class="memTemplParams" colspan="2"><a id="a203fbef324541c74f6ecfca523e44f45"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a203fbef324541c74f6ecfca523e44f45"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a203fbef324541c74f6ecfca523e44f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2224c89a580ca38b315d31d9c937f33"><td class="memTemplParams" colspan="2"><a id="ad2224c89a580ca38b315d31d9c937f33"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ad2224c89a580ca38b315d31d9c937f33"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ad2224c89a580ca38b315d31d9c937f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab692e38a5d9027b524c7532b189d8ff1"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:ab692e38a5d9027b524c7532b189d8ff1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ab692e38a5d9027b524c7532b189d8ff1">operator&gt;=</a> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ab692e38a5d9027b524c7532b189d8ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9cd492fc1e8ff479d9877e57224abf"><td class="memTemplParams" colspan="2"><a id="a3c9cd492fc1e8ff479d9877e57224abf"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a3c9cd492fc1e8ff479d9877e57224abf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, CharT(&amp;rhs)[N]) noexcept</td></tr>
<tr class="separator:a3c9cd492fc1e8ff479d9877e57224abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4611a988120f1e8fc340fa8e2ac66282"><td class="memTemplParams" colspan="2"><a id="a4611a988120f1e8fc340fa8e2ac66282"></a>
template&lt;typename CharT , typename Traits , std::size_t N&gt; </td></tr>
<tr class="memitem:a4611a988120f1e8fc340fa8e2ac66282"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (CharT(&amp;lhs)[N], const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a4611a988120f1e8fc340fa8e2ac66282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffbf3a347d72e521e5f310e10724251"><td class="memTemplParams" colspan="2"><a id="abffbf3a347d72e521e5f310e10724251"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:abffbf3a347d72e521e5f310e10724251"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const CharT *rhs) noexcept</td></tr>
<tr class="separator:abffbf3a347d72e521e5f310e10724251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3688ab7c84f8b2b6a12cea27882831"><td class="memTemplParams" colspan="2"><a id="a9c3688ab7c84f8b2b6a12cea27882831"></a>
template&lt;typename CharT , typename Traits &gt; </td></tr>
<tr class="memitem:a9c3688ab7c84f8b2b6a12cea27882831"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const CharT *lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a9c3688ab7c84f8b2b6a12cea27882831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf12778606813885b01e3a36e6e3566"><td class="memTemplParams" colspan="2"><a id="aaaf12778606813885b01e3a36e6e3566"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:aaaf12778606813885b01e3a36e6e3566"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aaaf12778606813885b01e3a36e6e3566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d37bde67cc0f72cfa523b8682d0794e"><td class="memTemplParams" colspan="2"><a id="a3d37bde67cc0f72cfa523b8682d0794e"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a3d37bde67cc0f72cfa523b8682d0794e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a3d37bde67cc0f72cfa523b8682d0794e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b7dfdbd963da0f7c8ebf9bccb64a6a"><td class="memTemplParams" colspan="2"><a id="af2b7dfdbd963da0f7c8ebf9bccb64a6a"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:af2b7dfdbd963da0f7c8ebf9bccb64a6a"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; CharT, Traits, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="separator:af2b7dfdbd963da0f7c8ebf9bccb64a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c20018db91ce9a900d2977e48ddfa70"><td class="memTemplParams" colspan="2"><a id="a6c20018db91ce9a900d2977e48ddfa70"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a6c20018db91ce9a900d2977e48ddfa70"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; CharT, Traits, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;lhs, const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;rhs)</td></tr>
<tr class="separator:a6c20018db91ce9a900d2977e48ddfa70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360314b0bf0ee3c7b4c684590fa45553"><td class="memTemplParams" colspan="2"><a id="a360314b0bf0ee3c7b4c684590fa45553"></a>
template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a360314b0bf0ee3c7b4c684590fa45553"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;lhs, const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;rhs)</td></tr>
<tr class="separator:a360314b0bf0ee3c7b4c684590fa45553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0dbaaca037aad1973f344bc1f6bbd81"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ad0dbaaca037aad1973f344bc1f6bbd81">indeterminate</a> (const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:ad0dbaaca037aad1973f344bc1f6bbd81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tribool is indeterminate.  <a href="#ad0dbaaca037aad1973f344bc1f6bbd81">More...</a><br /></td></tr>
<tr class="separator:ad0dbaaca037aad1973f344bc1f6bbd81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968683d715c2057ccd509693daac42de"><td class="memItemLeft" align="right" valign="top"><a id="a968683d715c2057ccd509693daac42de"></a>
constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>hash_value</b> (<a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> t) noexcept</td></tr>
<tr class="separator:a968683d715c2057ccd509693daac42de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8dec5bd2fc486c8d2144b3d7f17943"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a1f8dec5bd2fc486c8d2144b3d7f17943">operator==</a> (const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;lhs, const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a1f8dec5bd2fc486c8d2144b3d7f17943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two tribooleans.  <a href="#a1f8dec5bd2fc486c8d2144b3d7f17943">More...</a><br /></td></tr>
<tr class="separator:a1f8dec5bd2fc486c8d2144b3d7f17943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a4151c0d15bef2c65b5d64a2ec2975"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a83a4151c0d15bef2c65b5d64a2ec2975">operator==</a> (<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5853dc716058231d67db9de2a050a251">indeterminate_t</a>, const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a83a4151c0d15bef2c65b5d64a2ec2975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two tribooleans.  <a href="#a83a4151c0d15bef2c65b5d64a2ec2975">More...</a><br /></td></tr>
<tr class="separator:a83a4151c0d15bef2c65b5d64a2ec2975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894b424c1fe9bf6f27b776ecefd8300f"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a894b424c1fe9bf6f27b776ecefd8300f">operator==</a> (const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;lhs, <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5853dc716058231d67db9de2a050a251">indeterminate_t</a>) noexcept</td></tr>
<tr class="memdesc:a894b424c1fe9bf6f27b776ecefd8300f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two tribooleans.  <a href="#a894b424c1fe9bf6f27b776ecefd8300f">More...</a><br /></td></tr>
<tr class="separator:a894b424c1fe9bf6f27b776ecefd8300f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f719bc2f88ec95bdce7ac3bddaca536"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3f719bc2f88ec95bdce7ac3bddaca536">operator!=</a> (const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;lhs, const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a3f719bc2f88ec95bdce7ac3bddaca536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two tribooleans.  <a href="#a3f719bc2f88ec95bdce7ac3bddaca536">More...</a><br /></td></tr>
<tr class="separator:a3f719bc2f88ec95bdce7ac3bddaca536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8cacd7e1ce32b5e367aba95145f0c87"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#af8cacd7e1ce32b5e367aba95145f0c87">operator!=</a> (<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5853dc716058231d67db9de2a050a251">indeterminate_t</a>, const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:af8cacd7e1ce32b5e367aba95145f0c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two tribooleans.  <a href="#af8cacd7e1ce32b5e367aba95145f0c87">More...</a><br /></td></tr>
<tr class="separator:af8cacd7e1ce32b5e367aba95145f0c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0377caf58e0deaa3a8b13d34c398e3"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aea0377caf58e0deaa3a8b13d34c398e3">operator!=</a> (const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;lhs, <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5853dc716058231d67db9de2a050a251">indeterminate_t</a>) noexcept</td></tr>
<tr class="memdesc:aea0377caf58e0deaa3a8b13d34c398e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison between two tribooleans.  <a href="#aea0377caf58e0deaa3a8b13d34c398e3">More...</a><br /></td></tr>
<tr class="separator:aea0377caf58e0deaa3a8b13d34c398e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e63ae8d7d9b72fc44d5760c28e3460e"><td class="memItemLeft" align="right" valign="top"><a id="a7e63ae8d7d9b72fc44d5760c28e3460e"></a>
constexpr <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&amp;&amp;</b> (const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;lhs, const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:a7e63ae8d7d9b72fc44d5760c28e3460e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605691fbded7f41dc94ded59772265e8"><td class="memItemLeft" align="right" valign="top"><a id="a605691fbded7f41dc94ded59772265e8"></a>
constexpr <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator||</b> (const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;lhs, const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:a605691fbded7f41dc94ded59772265e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767ceaa1de7727dadc2a6523b37ffa5b"><td class="memTemplParams" colspan="2">template&lt;typename Func , typename Tuple &gt; </td></tr>
<tr class="memitem:a767ceaa1de7727dadc2a6523b37ffa5b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a767ceaa1de7727dadc2a6523b37ffa5b">apply</a> (Func &amp;&amp;function, Tuple &amp;&amp;tuple)</td></tr>
<tr class="memdesc:a767ceaa1de7727dadc2a6523b37ffa5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the Callable object <code>function</code> with a <code>tuple</code> of arguments.  <a href="#a767ceaa1de7727dadc2a6523b37ffa5b">More...</a><br /></td></tr>
<tr class="separator:a767ceaa1de7727dadc2a6523b37ffa5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a49f6f584ffbee6b67c31087a95e03"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tuple &gt; </td></tr>
<tr class="memitem:af9a49f6f584ffbee6b67c31087a95e03"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#af9a49f6f584ffbee6b67c31087a95e03">make_from_tuple</a> (Tuple &amp;&amp;tuple)</td></tr>
<tr class="memdesc:af9a49f6f584ffbee6b67c31087a95e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an object of type  T, using the elements of the tuple t as the arguments to the constructor.  <a href="#af9a49f6f584ffbee6b67c31087a95e03">More...</a><br /></td></tr>
<tr class="separator:af9a49f6f584ffbee6b67c31087a95e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b29133bb72579a5b279a23283c181d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dd/d57/structbit_1_1stl_1_1in__place__tag.html">in_place_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a0b29133bb72579a5b279a23283c181d5">in_place</a> ()</td></tr>
<tr class="memdesc:a0b29133bb72579a5b279a23283c181d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is a special disambiguation tag for variadic functions, used in any and optional.  <a href="#a0b29133bb72579a5b279a23283c181d5">More...</a><br /></td></tr>
<tr class="separator:a0b29133bb72579a5b279a23283c181d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fb1c369e77d674a654bb943210c7b0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a20fb1c369e77d674a654bb943210c7b0"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a20fb1c369e77d674a654bb943210c7b0">fwd</a> (T &amp;&amp;x) noexcept</td></tr>
<tr class="memdesc:a20fb1c369e77d674a654bb943210c7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around std::forward that removes the need for specifying the type T.  <a href="#a20fb1c369e77d674a654bb943210c7b0">More...</a><br /></td></tr>
<tr class="separator:a20fb1c369e77d674a654bb943210c7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236808cad8579906855eb09a4e161bd0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a236808cad8579906855eb09a4e161bd0"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a236808cad8579906855eb09a4e161bd0">decay_forward</a> (T &amp;&amp;x) noexcept</td></tr>
<tr class="memdesc:a236808cad8579906855eb09a4e161bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper function that acts like std::forward while decaying the underlying type.  <a href="#a236808cad8579906855eb09a4e161bd0">More...</a><br /></td></tr>
<tr class="separator:a236808cad8579906855eb09a4e161bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc07be03c7b93e780e6b6369cfb5c718"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:acc07be03c7b93e780e6b6369cfb5c718"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="../../db/dc4/classbit_1_1stl_1_1final__act.html">final_act</a>&lt; Func &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#acc07be03c7b93e780e6b6369cfb5c718">finally</a> (Func &amp;&amp;function) noexcept</td></tr>
<tr class="memdesc:acc07be03c7b93e780e6b6369cfb5c718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to generate a <a class="el" href="../../db/dc4/classbit_1_1stl_1_1final__act.html" title="This class leverages RAII to perform cleanup actions at the end of a scope. ">final_act</a>.  <a href="#acc07be03c7b93e780e6b6369cfb5c718">More...</a><br /></td></tr>
<tr class="separator:acc07be03c7b93e780e6b6369cfb5c718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994018402d561913cfd756806468244a"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a994018402d561913cfd756806468244a"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a994018402d561913cfd756806468244a">at</a> (T(&amp;array)[N], std::size_t n)</td></tr>
<tr class="memdesc:a994018402d561913cfd756806468244a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely retrieves the value at the given index, otherwise asserts.  <a href="#a994018402d561913cfd756806468244a">More...</a><br /></td></tr>
<tr class="separator:a994018402d561913cfd756806468244a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace51dc6914690cfdbde3caf2c7f66105"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Key &gt; </td></tr>
<tr class="memitem:ace51dc6914690cfdbde3caf2c7f66105"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ace51dc6914690cfdbde3caf2c7f66105">at</a> (Container &amp;container, Key &amp;&amp;key)</td></tr>
<tr class="memdesc:ace51dc6914690cfdbde3caf2c7f66105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely retrieves the value at the given index, otherwise asserts.  <a href="#ace51dc6914690cfdbde3caf2c7f66105">More...</a><br /></td></tr>
<tr class="separator:ace51dc6914690cfdbde3caf2c7f66105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f49b109d7088448b46673cb58124764"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2f49b109d7088448b46673cb58124764"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a2f49b109d7088448b46673cb58124764">hash_combine</a> (std::size_t &amp;seed, const T &amp;v)</td></tr>
<tr class="memdesc:a2f49b109d7088448b46673cb58124764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines the hash with another hash.  <a href="#a2f49b109d7088448b46673cb58124764">More...</a><br /></td></tr>
<tr class="separator:a2f49b109d7088448b46673cb58124764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9693facf6e039e9742d25bb169b13b23"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a9693facf6e039e9742d25bb169b13b23"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a9693facf6e039e9742d25bb169b13b23">hash_range</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a9693facf6e039e9742d25bb169b13b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes a range of entries, returning the result.  <a href="#a9693facf6e039e9742d25bb169b13b23">More...</a><br /></td></tr>
<tr class="separator:a9693facf6e039e9742d25bb169b13b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fcd550eed18391c0c378c3c1dcd802"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a30fcd550eed18391c0c378c3c1dcd802"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a30fcd550eed18391c0c378c3c1dcd802">hash_range</a> (std::size_t &amp;seed, InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a30fcd550eed18391c0c378c3c1dcd802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes a range of entries.  <a href="#a30fcd550eed18391c0c378c3c1dcd802">More...</a><br /></td></tr>
<tr class="separator:a30fcd550eed18391c0c378c3c1dcd802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584a27d0ea529578cfc11814176d3c77"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a584a27d0ea529578cfc11814176d3c77">hash_value</a> (std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:a584a27d0ea529578cfc11814176d3c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of a null pointer.  <a href="#a584a27d0ea529578cfc11814176d3c77">More...</a><br /></td></tr>
<tr class="separator:a584a27d0ea529578cfc11814176d3c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9403b1d1333c84854974c3a26930c43e"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a9403b1d1333c84854974c3a26930c43e">hash_value</a> (bool val) noexcept</td></tr>
<tr class="memdesc:a9403b1d1333c84854974c3a26930c43e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given bool.  <a href="#a9403b1d1333c84854974c3a26930c43e">More...</a><br /></td></tr>
<tr class="separator:a9403b1d1333c84854974c3a26930c43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63eb167c6e9f2f72cb951d98e6b524aa"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a63eb167c6e9f2f72cb951d98e6b524aa">hash_value</a> (char val) noexcept</td></tr>
<tr class="memdesc:a63eb167c6e9f2f72cb951d98e6b524aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given char.  <a href="#a63eb167c6e9f2f72cb951d98e6b524aa">More...</a><br /></td></tr>
<tr class="separator:a63eb167c6e9f2f72cb951d98e6b524aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0659afd18943b4b40ce92861a91508"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aec0659afd18943b4b40ce92861a91508">hash_value</a> (signed char val) noexcept</td></tr>
<tr class="memdesc:aec0659afd18943b4b40ce92861a91508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given signed char.  <a href="#aec0659afd18943b4b40ce92861a91508">More...</a><br /></td></tr>
<tr class="separator:aec0659afd18943b4b40ce92861a91508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66ae1724a126027297374c374b6ef6a"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aa66ae1724a126027297374c374b6ef6a">hash_value</a> (unsigned char val) noexcept</td></tr>
<tr class="memdesc:aa66ae1724a126027297374c374b6ef6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given unsigned char.  <a href="#aa66ae1724a126027297374c374b6ef6a">More...</a><br /></td></tr>
<tr class="separator:aa66ae1724a126027297374c374b6ef6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72f61cc97f25653194a936ee6b7dcf7"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ad72f61cc97f25653194a936ee6b7dcf7">hash_value</a> (wchar_t val) noexcept</td></tr>
<tr class="memdesc:ad72f61cc97f25653194a936ee6b7dcf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given wchar_t.  <a href="#ad72f61cc97f25653194a936ee6b7dcf7">More...</a><br /></td></tr>
<tr class="separator:ad72f61cc97f25653194a936ee6b7dcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c975f2d74a9235b487048cdf8379cc"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a71c975f2d74a9235b487048cdf8379cc">hash_value</a> (char16_t val) noexcept</td></tr>
<tr class="memdesc:a71c975f2d74a9235b487048cdf8379cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given char16_t.  <a href="#a71c975f2d74a9235b487048cdf8379cc">More...</a><br /></td></tr>
<tr class="separator:a71c975f2d74a9235b487048cdf8379cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d397ddf0317c66df2bfc01f46f8a5cf"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5d397ddf0317c66df2bfc01f46f8a5cf">hash_value</a> (char32_t val) noexcept</td></tr>
<tr class="memdesc:a5d397ddf0317c66df2bfc01f46f8a5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given char32_t.  <a href="#a5d397ddf0317c66df2bfc01f46f8a5cf">More...</a><br /></td></tr>
<tr class="separator:a5d397ddf0317c66df2bfc01f46f8a5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7154f4d7363372961d1e1994fa5bb7c7"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a7154f4d7363372961d1e1994fa5bb7c7">hash_value</a> (short val) noexcept</td></tr>
<tr class="memdesc:a7154f4d7363372961d1e1994fa5bb7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given short.  <a href="#a7154f4d7363372961d1e1994fa5bb7c7">More...</a><br /></td></tr>
<tr class="separator:a7154f4d7363372961d1e1994fa5bb7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a525d7be855171985a7193ecaecab76"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a4a525d7be855171985a7193ecaecab76">hash_value</a> (unsigned short val) noexcept</td></tr>
<tr class="memdesc:a4a525d7be855171985a7193ecaecab76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given unsigned short.  <a href="#a4a525d7be855171985a7193ecaecab76">More...</a><br /></td></tr>
<tr class="separator:a4a525d7be855171985a7193ecaecab76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f0ceba5bc16b60258fbf0506bcae35"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ae0f0ceba5bc16b60258fbf0506bcae35">hash_value</a> (int val) noexcept</td></tr>
<tr class="memdesc:ae0f0ceba5bc16b60258fbf0506bcae35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given int.  <a href="#ae0f0ceba5bc16b60258fbf0506bcae35">More...</a><br /></td></tr>
<tr class="separator:ae0f0ceba5bc16b60258fbf0506bcae35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a377050372166907861b21ab4b56c8"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a40a377050372166907861b21ab4b56c8">hash_value</a> (unsigned int val) noexcept</td></tr>
<tr class="memdesc:a40a377050372166907861b21ab4b56c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given unsigned int.  <a href="#a40a377050372166907861b21ab4b56c8">More...</a><br /></td></tr>
<tr class="separator:a40a377050372166907861b21ab4b56c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596483385fd40c05411995fb76e8cfa5"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a596483385fd40c05411995fb76e8cfa5">hash_value</a> (long val) noexcept</td></tr>
<tr class="memdesc:a596483385fd40c05411995fb76e8cfa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given long.  <a href="#a596483385fd40c05411995fb76e8cfa5">More...</a><br /></td></tr>
<tr class="separator:a596483385fd40c05411995fb76e8cfa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c2924b2f3e21ee85f0f514f59848e4"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a45c2924b2f3e21ee85f0f514f59848e4">hash_value</a> (unsigned long val) noexcept</td></tr>
<tr class="memdesc:a45c2924b2f3e21ee85f0f514f59848e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given unsigned long.  <a href="#a45c2924b2f3e21ee85f0f514f59848e4">More...</a><br /></td></tr>
<tr class="separator:a45c2924b2f3e21ee85f0f514f59848e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a97a54533bc83393bc21f5155c8f331"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5a97a54533bc83393bc21f5155c8f331">hash_value</a> (long long val) noexcept</td></tr>
<tr class="memdesc:a5a97a54533bc83393bc21f5155c8f331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given long long.  <a href="#a5a97a54533bc83393bc21f5155c8f331">More...</a><br /></td></tr>
<tr class="separator:a5a97a54533bc83393bc21f5155c8f331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f32f66345d679e5031c7e7197dadc4"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a16f32f66345d679e5031c7e7197dadc4">hash_value</a> (unsigned long long val) noexcept</td></tr>
<tr class="memdesc:a16f32f66345d679e5031c7e7197dadc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given unsigned long long.  <a href="#a16f32f66345d679e5031c7e7197dadc4">More...</a><br /></td></tr>
<tr class="separator:a16f32f66345d679e5031c7e7197dadc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fd58ad444420cb8b01a2832fdf496c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a77fd58ad444420cb8b01a2832fdf496c">hash_value</a> (float val) noexcept</td></tr>
<tr class="memdesc:a77fd58ad444420cb8b01a2832fdf496c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given float.  <a href="#a77fd58ad444420cb8b01a2832fdf496c">More...</a><br /></td></tr>
<tr class="separator:a77fd58ad444420cb8b01a2832fdf496c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8add61aed3531d951d4e8cce1013363"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aa8add61aed3531d951d4e8cce1013363">hash_value</a> (double val) noexcept</td></tr>
<tr class="memdesc:aa8add61aed3531d951d4e8cce1013363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given double.  <a href="#aa8add61aed3531d951d4e8cce1013363">More...</a><br /></td></tr>
<tr class="separator:aa8add61aed3531d951d4e8cce1013363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e06a2ef7ee4eb339d240272fa4a3eeb"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a4e06a2ef7ee4eb339d240272fa4a3eeb">hash_value</a> (long double val) noexcept</td></tr>
<tr class="memdesc:a4e06a2ef7ee4eb339d240272fa4a3eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given long double.  <a href="#a4e06a2ef7ee4eb339d240272fa4a3eeb">More...</a><br /></td></tr>
<tr class="separator:a4e06a2ef7ee4eb339d240272fa4a3eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcde1a36bf0d2e13786387e2b0150f1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4fcde1a36bf0d2e13786387e2b0150f1"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a4fcde1a36bf0d2e13786387e2b0150f1">hash_value</a> (T *const &amp;val) noexcept</td></tr>
<tr class="memdesc:a4fcde1a36bf0d2e13786387e2b0150f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given pointer.  <a href="#a4fcde1a36bf0d2e13786387e2b0150f1">More...</a><br /></td></tr>
<tr class="separator:a4fcde1a36bf0d2e13786387e2b0150f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20db1218b612cc2ab37f8dcd38615a72"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned N&gt; </td></tr>
<tr class="memitem:a20db1218b612cc2ab37f8dcd38615a72"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a20db1218b612cc2ab37f8dcd38615a72">hash_value</a> (T(&amp;val)[N])</td></tr>
<tr class="memdesc:a20db1218b612cc2ab37f8dcd38615a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given T array.  <a href="#a20db1218b612cc2ab37f8dcd38615a72">More...</a><br /></td></tr>
<tr class="separator:a20db1218b612cc2ab37f8dcd38615a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad849248942ee4fdca3f4d0c9f5ecb2ee"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned N&gt; </td></tr>
<tr class="memitem:ad849248942ee4fdca3f4d0c9f5ecb2ee"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ad849248942ee4fdca3f4d0c9f5ecb2ee">hash_value</a> (const T(&amp;val)[N])</td></tr>
<tr class="memdesc:ad849248942ee4fdca3f4d0c9f5ecb2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a hash of the given T array.  <a href="#ad849248942ee4fdca3f4d0c9f5ecb2ee">More...</a><br /></td></tr>
<tr class="separator:ad849248942ee4fdca3f4d0c9f5ecb2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034adf6da7e194b42f547fd9893c7eb8"><td class="memTemplParams" colspan="2">template&lt;typename Enum &gt; </td></tr>
<tr class="memitem:a034adf6da7e194b42f547fd9893c7eb8"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a034adf6da7e194b42f547fd9893c7eb8">hash_value</a> (Enum val) noexcept</td></tr>
<tr class="memdesc:a034adf6da7e194b42f547fd9893c7eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes enum values.  <a href="#a034adf6da7e194b42f547fd9893c7eb8">More...</a><br /></td></tr>
<tr class="separator:a034adf6da7e194b42f547fd9893c7eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdef9b2830203ce585db5d761edd266"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a2fdef9b2830203ce585db5d761edd266"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a2fdef9b2830203ce585db5d761edd266">hash_value</a> (const Container &amp;container) noexcept</td></tr>
<tr class="memdesc:a2fdef9b2830203ce585db5d761edd266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes any given container.  <a href="#a2fdef9b2830203ce585db5d761edd266">More...</a><br /></td></tr>
<tr class="separator:a2fdef9b2830203ce585db5d761edd266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4b0d5342a805f542d824ef4348b9af"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a5f4b0d5342a805f542d824ef4348b9af"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5f4b0d5342a805f542d824ef4348b9af">hash_value</a> (const std::pair&lt; T, U &gt; &amp;pair)</td></tr>
<tr class="memdesc:a5f4b0d5342a805f542d824ef4348b9af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes a std::pair.  <a href="#a5f4b0d5342a805f542d824ef4348b9af">More...</a><br /></td></tr>
<tr class="separator:a5f4b0d5342a805f542d824ef4348b9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3887964130579e473a8c9ba19497f6"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a1d3887964130579e473a8c9ba19497f6"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a1d3887964130579e473a8c9ba19497f6">hash_value</a> (const std::tuple&lt; Args... &gt; &amp;tuple)</td></tr>
<tr class="memdesc:a1d3887964130579e473a8c9ba19497f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes a tuple of entries.  <a href="#a1d3887964130579e473a8c9ba19497f6">More...</a><br /></td></tr>
<tr class="separator:a1d3887964130579e473a8c9ba19497f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095457d6a448fa63db72891dda7ff055"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a095457d6a448fa63db72891dda7ff055"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a095457d6a448fa63db72891dda7ff055">hash_value</a> (const std::initializer_list&lt; T &gt; &amp;il)</td></tr>
<tr class="memdesc:a095457d6a448fa63db72891dda7ff055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes an initializer_list.  <a href="#a095457d6a448fa63db72891dda7ff055">More...</a><br /></td></tr>
<tr class="separator:a095457d6a448fa63db72891dda7ff055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd395f73ba3488ce123b405e80b43eee"><td class="memTemplParams" colspan="2">template&lt;typename F , typename Tuple &gt; </td></tr>
<tr class="memitem:abd395f73ba3488ce123b405e80b43eee"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#abd395f73ba3488ce123b405e80b43eee">apply</a> (F &amp;&amp;f, Tuple &amp;&amp;t)</td></tr>
<tr class="memdesc:abd395f73ba3488ce123b405e80b43eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the Callable object f with a tuple of arguments.  <a href="#abd395f73ba3488ce123b405e80b43eee">More...</a><br /></td></tr>
<tr class="separator:abd395f73ba3488ce123b405e80b43eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44765e2cf31239152e2374bc6684ff6"><td class="memTemplParams" colspan="2">template&lt;typename Container , underlying_container_type_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac44765e2cf31239152e2374bc6684ff6"><td class="memTemplItemLeft" align="right" valign="top">underlying_container_type_t&lt; Container &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ac44765e2cf31239152e2374bc6684ff6">get_underlying_container</a> (Container &amp;container)</td></tr>
<tr class="memdesc:ac44765e2cf31239152e2374bc6684ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying container of a given container adapter.  <a href="#ac44765e2cf31239152e2374bc6684ff6">More...</a><br /></td></tr>
<tr class="separator:ac44765e2cf31239152e2374bc6684ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab993070150ba659591029ded08c97ab4"><td class="memItemLeft" align="right" valign="top"><a id="ab993070150ba659591029ded08c97ab4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a> &amp;lhs, const <a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:ab993070150ba659591029ded08c97ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db25858f4dacf51429ed979f4d63f8d"><td class="memItemLeft" align="right" valign="top"><a id="a6db25858f4dacf51429ed979f4d63f8d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a> &amp;lhs, const <a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:a6db25858f4dacf51429ed979f4d63f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6818223213d20420bf5c6f867e5130ca"><td class="memItemLeft" align="right" valign="top"><a id="a6818223213d20420bf5c6f867e5130ca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a> &amp;lhs, const <a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:a6818223213d20420bf5c6f867e5130ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062a995a56331341fe185a89df3f2f19"><td class="memItemLeft" align="right" valign="top"><a id="a062a995a56331341fe185a89df3f2f19"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a> &amp;lhs, const <a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:a062a995a56331341fe185a89df3f2f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962c5fecd9a1db1794835196db28a0b2"><td class="memItemLeft" align="right" valign="top"><a id="a962c5fecd9a1db1794835196db28a0b2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a> &amp;lhs, const <a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:a962c5fecd9a1db1794835196db28a0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693bfc84a9be219c1b0f18478b3cce1e"><td class="memItemLeft" align="right" valign="top"><a id="a693bfc84a9be219c1b0f18478b3cce1e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a> &amp;lhs, const <a class="el" href="../../d5/d75/classbit_1_1stl_1_1uuid.html">uuid</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:a693bfc84a9be219c1b0f18478b3cce1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a74872a5b5134f3972927a78e69b5c8c7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a74872a5b5134f3972927a78e69b5c8c7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a74872a5b5134f3972927a78e69b5c8c7">deep_compare</a> (const T &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a74872a5b5134f3972927a78e69b5c8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep comparison of two pointer-like objects.  <a href="#a74872a5b5134f3972927a78e69b5c8c7">More...</a><br /></td></tr>
<tr class="separator:a74872a5b5134f3972927a78e69b5c8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b012db31ce10640055ff0c1bcc8baf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a61b012db31ce10640055ff0c1bcc8baf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a61b012db31ce10640055ff0c1bcc8baf">deep_compare</a> (std::nullptr_t, const T &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a61b012db31ce10640055ff0c1bcc8baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep comparison of two pointer-like objects.  <a href="#a61b012db31ce10640055ff0c1bcc8baf">More...</a><br /></td></tr>
<tr class="separator:a61b012db31ce10640055ff0c1bcc8baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f080cd59b223c721bb87836df95e0b9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f080cd59b223c721bb87836df95e0b9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a4f080cd59b223c721bb87836df95e0b9">deep_compare</a> (const T &amp;lhs, std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:a4f080cd59b223c721bb87836df95e0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep comparison of two pointer-like objects.  <a href="#a4f080cd59b223c721bb87836df95e0b9">More...</a><br /></td></tr>
<tr class="separator:a4f080cd59b223c721bb87836df95e0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef190c6b43facf566fc7bf0ccf2b5d2"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3ef190c6b43facf566fc7bf0ccf2b5d2">deep_compare</a> (std::nullptr_t, std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:a3ef190c6b43facf566fc7bf0ccf2b5d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep comparison of two pointer-like objects.  <a href="#a3ef190c6b43facf566fc7bf0ccf2b5d2">More...</a><br /></td></tr>
<tr class="separator:a3ef190c6b43facf566fc7bf0ccf2b5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a322ace5ea4e3242457cfc64f6bf00717"><td class="memItemLeft" align="right" valign="top"><a id="a322ace5ea4e3242457cfc64f6bf00717"></a>
constexpr <a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a322ace5ea4e3242457cfc64f6bf00717">nullopt</a> = <a class="el" href="../../d0/de0/structbit_1_1stl_1_1nullopt__t.html">nullopt_t</a>(0)</td></tr>
<tr class="memdesc:a322ace5ea4e3242457cfc64f6bf00717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instance of a nullopt type. <br /></td></tr>
<tr class="separator:a322ace5ea4e3242457cfc64f6bf00717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecff478de92d62272d16166405cc0c9"><td class="memItemLeft" align="right" valign="top"><a id="a2ecff478de92d62272d16166405cc0c9"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a2ecff478de92d62272d16166405cc0c9">dynamic_extent</a> = std::ptrdiff_t{-1}</td></tr>
<tr class="memdesc:a2ecff478de92d62272d16166405cc0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to represent dynamic-extents. <br /></td></tr>
<tr class="separator:a2ecff478de92d62272d16166405cc0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c294b39c8553f7c91b91b7c228ab75"><td class="memItemLeft" align="right" valign="top"><a id="a90c294b39c8553f7c91b91b7c228ab75"></a>
constexpr <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#d4/d21/structbit_1_1stl_1_1ctor__zero__out__tag">ctor_zero_out_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a90c294b39c8553f7c91b91b7c228ab75">ctor_zero_out</a> = {}</td></tr>
<tr class="memdesc:a90c294b39c8553f7c91b91b7c228ab75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predefined constant for zeroing out a constructor. <br /></td></tr>
<tr class="separator:a90c294b39c8553f7c91b91b7c228ab75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17774bfa5140111a54ac668ae883cc45"><td class="memItemLeft" align="right" valign="top"><a id="a17774bfa5140111a54ac668ae883cc45"></a>
constexpr <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#dd/d27/structbit_1_1stl_1_1ctor__do__not__convert__tag">ctor_do_not_convert_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a17774bfa5140111a54ac668ae883cc45">ctor_dnc</a> = {}</td></tr>
<tr class="memdesc:a17774bfa5140111a54ac668ae883cc45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predefined constant for disabling internal conversion. <br /></td></tr>
<tr class="separator:a17774bfa5140111a54ac668ae883cc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156d311abc0ddbfe589e2245538f5d96"><td class="memTemplParams" colspan="2"><a id="a156d311abc0ddbfe589e2245538f5d96"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a156d311abc0ddbfe589e2245538f5d96"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_in_place_v</b> = <a class="el" href="../../d9/dd8/structbit_1_1stl_1_1is__in__place.html">is_in_place</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a156d311abc0ddbfe589e2245538f5d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The standard namespace for this project. </p>
<p>Every class, free function, and sub-namespace will be defined inside of this namespace. </p>
</div><hr/><h2 class="groupheader">Class Documentation</h2>
<a name="dd/d27/structbit_1_1stl_1_1ctor__do__not__convert__tag" id="dd/d27/structbit_1_1stl_1_1ctor__do__not__convert__tag"></a>
<h2 class="memtitle"><span class="permalink"><a href="#dd/d27/structbit_1_1stl_1_1ctor__do__not__convert__tag">&#9670;&nbsp;</a></span>bit::stl::ctor_do_not_convert_tag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::stl::ctor_do_not_convert_tag</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Constructor tag used to disable automatic internal conversion. </p>

<p class="definition">Definition at line <a class="el" href="../../db/dd7/stddef_8hpp_source.html#l00245">245</a> of file <a class="el" href="../../db/dd7/stddef_8hpp_source.html">stddef.hpp</a>.</p>
</div>
</div>
</div>
<a name="d4/dd2/structbit_1_1stl_1_1ctor__va__args__tag" id="d4/dd2/structbit_1_1stl_1_1ctor__va__args__tag"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d4/dd2/structbit_1_1stl_1_1ctor__va__args__tag">&#9670;&nbsp;</a></span>bit::stl::ctor_va_args_tag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::stl::ctor_va_args_tag</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Constructor tag used as a placeholder to not conflict with variadic constructors. </p>

<p class="definition">Definition at line <a class="el" href="../../db/dd7/stddef_8hpp_source.html#l00249">249</a> of file <a class="el" href="../../db/dd7/stddef_8hpp_source.html">stddef.hpp</a>.</p>
</div>
</div>
</div>
<a name="d4/d21/structbit_1_1stl_1_1ctor__zero__out__tag" id="d4/d21/structbit_1_1stl_1_1ctor__zero__out__tag"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d4/d21/structbit_1_1stl_1_1ctor__zero__out__tag">&#9670;&nbsp;</a></span>bit::stl::ctor_zero_out_tag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bit::stl::ctor_zero_out_tag</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>For specified string types. </p>
<p>Constructor tag used to zero out the entire class </p>

<p class="definition">Definition at line <a class="el" href="../../db/dd7/stddef_8hpp_source.html#l00242">242</a> of file <a class="el" href="../../db/dd7/stddef_8hpp_source.html">stddef.hpp</a>.</p>
</div>
</div>
</div>
<a name="d6/d7e/classbit_1_1stl_1_1delegate" id="d6/d7e/classbit_1_1stl_1_1delegate"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d6/d7e/classbit_1_1stl_1_1delegate">&#9670;&nbsp;</a></span>bit::stl::delegate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class bit::stl::delegate</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Fn&gt;<br />
class bit::stl::delegate&lt; Fn &gt;</h3>

<p>This class is for a lightweight way of managing function callbacks without requiring heap allocations. </p>
<p>The syntax is a little off as a result, requiring a call to Delegate::bind.</p>
<p>Example </p><div class="fragment"><div class="line">Delegate&lt;void()&gt; delegate;</div><div class="line">T       t;</div><div class="line"><span class="keyword">const</span> T ct;</div><div class="line"></div><div class="line">delegate.bind&lt;&amp;foo&gt;();           <span class="comment">// bind free function</span></div><div class="line">delegate.bind&lt;T,&amp;T::foo&gt;( &amp;t );  <span class="comment">// bind member functions</span></div><div class="line">delegate.bind&lt;T,&amp;T::foo&gt;( &amp;ct ); <span class="comment">// bind const member function</span></div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>signature and return type </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d0/d68/delegate_8hpp_source.html#l00045">45</a> of file <a class="el" href="../../d0/d68/delegate_8hpp_source.html">delegate.hpp</a>.</p>
</div>
</div>
</div>
<a name="dd/d73/classbit_1_1stl_1_1underlying__container__type" id="dd/d73/classbit_1_1stl_1_1underlying__container__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#dd/d73/classbit_1_1stl_1_1underlying__container__type">&#9670;&nbsp;</a></span>bit::stl::underlying_container_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class bit::stl::underlying_container_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class bit::stl::underlying_container_type&lt; T &gt;</h3>


<p class="definition">Definition at line <a class="el" href="../../d1/d4e/utility_8hpp_source.html#l00527">527</a> of file <a class="el" href="../../d1/d4e/utility_8hpp_source.html">utility.hpp</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="ad061421c9c25bca1057630ee1a55fa0a"></a>typedef typename type</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a8f679456d2b3cd6f3f65577718d97c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f679456d2b3cd6f3f65577718d97c79">&#9670;&nbsp;</a></span>function_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a8f679456d2b3cd6f3f65577718d97c79">bit::stl::function_t</a> = typedef typename detail::function_t&lt;Fn&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type alias for function pointers to make it more readable. </p>
<dl class="section note"><dt>Note</dt><dd>That function_t is unable to deduce it's template parameters if used in a deduction context. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../db/dd7/stddef_8hpp_source.html#l00191">191</a> of file <a class="el" href="../../db/dd7/stddef_8hpp_source.html">stddef.hpp</a>.</p>

</div>
</div>
<a id="ac960b0c0061252bb398695e4bd0c706b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac960b0c0061252bb398695e4bd0c706b">&#9670;&nbsp;</a></span>is_string_span</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ac960b0c0061252bb398695e4bd0c706b">bit::stl::is_string_span</a> = typedef detail::is_string_span&lt;std::remove_cv_t&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type-trait to determine whether the type is a string_span </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d9/d14/string__span_8hpp_source.html#l00095">95</a> of file <a class="el" href="../../d9/d14/string__span_8hpp_source.html">string_span.hpp</a>.</p>

</div>
</div>
<a id="ad591c6c50fab0fb9348d8afd38322a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad591c6c50fab0fb9348d8afd38322a37">&#9670;&nbsp;</a></span>is_zstring_span</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#ad591c6c50fab0fb9348d8afd38322a37">bit::stl::is_zstring_span</a> = typedef detail::is_zstring_span&lt;std::remove_cv_t&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type-trait to determine whether the type is a null-terminated string </p>
<p>The result is aliased as <code>::value</code> </p>

<p class="definition">Definition at line <a class="el" href="../../d9/d14/string__span_8hpp_source.html#l00102">102</a> of file <a class="el" href="../../d9/d14/string__span_8hpp_source.html">string_span.hpp</a>.</p>

</div>
</div>
<a id="a3c6a691794dcbf6afcdeba00278da3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c6a691794dcbf6afcdeba00278da3d5">&#9670;&nbsp;</a></span>member_function_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a3c6a691794dcbf6afcdeba00278da3d5">bit::stl::member_function_t</a> = typedef typename detail::member_function_t&lt;T,R&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type alias for member function pointers to make it more readable. </p>
<dl class="section note"><dt>Note</dt><dd>member_function_t is unable to deduce it's template parameters if used in a deduction context. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../db/dd7/stddef_8hpp_source.html#l00184">184</a> of file <a class="el" href="../../db/dd7/stddef_8hpp_source.html">stddef.hpp</a>.</p>

</div>
</div>
<a id="aacf455f79e68ed45d131623ae84329b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf455f79e68ed45d131623ae84329b2">&#9670;&nbsp;</a></span>member_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../da/d7e/namespacebit_1_1stl.html#aacf455f79e68ed45d131623ae84329b2">bit::stl::member_t</a> = typedef R T::*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type alias for member pointers to make it more readable. </p>
<dl class="section note"><dt>Note</dt><dd>member_t is unable to deduce it's template parameters if used in a deduction context. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../db/dd7/stddef_8hpp_source.html#l00176">176</a> of file <a class="el" href="../../db/dd7/stddef_8hpp_source.html">stddef.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="abffa940c73f4ad283c6d1bc0042ca46b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abffa940c73f4ad283c6d1bc0042ca46b">&#9670;&nbsp;</a></span>address_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::stl::address_from </td>
          <td>(</td>
          <td class="paramtype">InputIterator &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> -&gt;  typename std::iterator_traits&lt; InputIterator &gt;::value_type *</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains the actual address of the object referenced through an iterator <code>it</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the value referenced from the iterator </dd></dl>

</div>
</div>
<a id="a767ceaa1de7727dadc2a6523b37ffa5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767ceaa1de7727dadc2a6523b37ffa5b">&#9670;&nbsp;</a></span>apply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) constexpr bit::stl::apply </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the Callable object <code>function</code> with a <code>tuple</code> of arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to be invoked </td></tr>
    <tr><td class="paramname">tuple</td><td>tuple whose elements to be used as arguments to <code>function</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value returned from <code>function</code> </dd></dl>

</div>
</div>
<a id="abd395f73ba3488ce123b405e80b43eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd395f73ba3488ce123b405e80b43eee">&#9670;&nbsp;</a></span>apply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) constexpr bit::stl::apply </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke the Callable object f with a tuple of arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Callable object to be invoked </td></tr>
    <tr><td class="paramname">t</td><td>tuple whose elements to be used as arguments to <code>f</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value returned from invoking <code>f</code> with <code>t's</code> elements </dd></dl>

</div>
</div>
<a id="a994018402d561913cfd756806468244a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994018402d561913cfd756806468244a">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T&amp; bit::stl::at </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safely retrieves the value at the given index, otherwise asserts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>reference to the array to index into </td></tr>
    <tr><td class="paramname">n</td><td>the index to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to instance </dd></dl>

</div>
</div>
<a id="ace51dc6914690cfdbde3caf2c7f66105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace51dc6914690cfdbde3caf2c7f66105">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Key &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) constexpr bit::stl::at </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safely retrieves the value at the given index, otherwise asserts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>reference to the array to index into </td></tr>
    <tr><td class="paramname">n</td><td>the index to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to instance </dd></dl>

</div>
</div>
<a id="a236808cad8579906855eb09a4e161bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236808cad8579906855eb09a4e161bd0">&#9670;&nbsp;</a></span>decay_forward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) constexpr bit::stl::decay_forward </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wrapper function that acts like std::forward while decaying the underlying type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to forward </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the decay-forwarded value </dd></dl>

</div>
</div>
<a id="a74872a5b5134f3972927a78e69b5c8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74872a5b5134f3972927a78e69b5c8c7">&#9670;&nbsp;</a></span>deep_compare() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::deep_compare </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a deep comparison of two pointer-like objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left pointer </td></tr>
    <tr><td class="paramname">rhs</td><td>the right pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> is the same as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a61b012db31ce10640055ff0c1bcc8baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b012db31ce10640055ff0c1bcc8baf">&#9670;&nbsp;</a></span>deep_compare() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::deep_compare </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a deep comparison of two pointer-like objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left pointer </td></tr>
    <tr><td class="paramname">rhs</td><td>the right pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> is the same as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a4f080cd59b223c721bb87836df95e0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f080cd59b223c721bb87836df95e0b9">&#9670;&nbsp;</a></span>deep_compare() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::deep_compare </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a deep comparison of two pointer-like objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left pointer </td></tr>
    <tr><td class="paramname">rhs</td><td>the right pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> is the same as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a3ef190c6b43facf566fc7bf0ccf2b5d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef190c6b43facf566fc7bf0ccf2b5d2">&#9670;&nbsp;</a></span>deep_compare() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::deep_compare </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a deep comparison of two pointer-like objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left pointer </td></tr>
    <tr><td class="paramname">rhs</td><td>the right pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> is the same as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="af04c12401a97f0afbb5d9863e3454b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04c12401a97f0afbb5d9863e3454b3a">&#9670;&nbsp;</a></span>dereference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) constexpr bit::stl::dereference </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dereferences all levels of pointer indirection from the supplied pointer. </p>
<dl class="section note"><dt>Note</dt><dd>This does not do any null-checking</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer to dereference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the dereferenced pointer </dd></dl>

</div>
</div>
<a id="a1691dc7bcc77311536263be8d1273d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1691dc7bcc77311536263be8d1273d7b">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bit::stl::destroy </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the objects in the range <code></code>[first, <code>last</code>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the start of the range to destroy </td></tr>
    <tr><td class="paramname">end</td><td>the end of the range to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf862f7facbc4267ce240a9167ce3dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf862f7facbc4267ce240a9167ce3dfa">&#9670;&nbsp;</a></span>destroy_array_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bit::stl::destroy_array_at </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys an array of entries at the given <code>ptr</code>. </p>
<dl class="section note"><dt>Note</dt><dd>The pointer to the destroyed array must have been created with A call to uninitialized_create_array_at</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to an </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d9c14044feb39441c88d133e6f94bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9c14044feb39441c88d133e6f94bf9">&#9670;&nbsp;</a></span>destroy_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bit::stl::destroy_at </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the destructor of the object pointed to by p, as if by p-&gt;~T(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>a pointer to the object to be destroyed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63bf67710219534b12e99dec573c4802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63bf67710219534b12e99dec573c4802">&#9670;&nbsp;</a></span>destroy_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator bit::stl::destroy_n </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the <code>n</code> objects in the range starting at <code>first</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the start of the range to destroy </td></tr>
    <tr><td class="paramname">n</td><td>the number of entries to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc07be03c7b93e780e6b6369cfb5c718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc07be03c7b93e780e6b6369cfb5c718">&#9670;&nbsp;</a></span>finally()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../db/dc4/classbit_1_1stl_1_1final__act.html">final_act</a>&lt;Func&gt; bit::stl::finally </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function to generate a <a class="el" href="../../db/dc4/classbit_1_1stl_1_1final__act.html" title="This class leverages RAII to perform cleanup actions at the end of a scope. ">final_act</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>the function to perform on the final act </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e2bf516ec5150488457255f5b3f63cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2bf516ec5150488457255f5b3f63cf">&#9670;&nbsp;</a></span>from_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* bit::stl::from_address </td>
          <td>(</td>
          <td class="paramtype">std::uintptr_t&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a numeric address <code>address</code> into a pointer pointing to the address location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>the address value to convert to a pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer pointing to the given address </dd></dl>

</div>
</div>
<a id="a20fb1c369e77d674a654bb943210c7b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20fb1c369e77d674a654bb943210c7b0">&#9670;&nbsp;</a></span>fwd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) constexpr bit::stl::fwd </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wrapper around std::forward that removes the need for specifying the type T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to forward </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87c0ed1fbd40262a8ea362a934dec70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c0ed1fbd40262a8ea362a934dec70f">&#9670;&nbsp;</a></span>gcd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::common_type_t&lt;T,U&gt; bit::stl::gcd </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the greatest common divisor of the integers <code>m</code> and <code>n</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first integer value </td></tr>
    <tr><td class="paramname">b</td><td>the second integer value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The greatest common divisor </dd></dl>

</div>
</div>
<a id="ac44765e2cf31239152e2374bc6684ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44765e2cf31239152e2374bc6684ff6">&#9670;&nbsp;</a></span>get_underlying_container()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , underlying_container_type_t&lt; Container &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">underlying_container_type_t&lt;Container&gt;&amp; bit::stl::get_underlying_container </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the underlying container of a given container adapter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>reference to the container adapter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the underlying container </dd></dl>

</div>
</div>
<a id="a2f49b109d7088448b46673cb58124764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f49b109d7088448b46673cb58124764">&#9670;&nbsp;</a></span>hash_combine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr void bit::stl::hash_combine </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines the hash with another hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The seed to combine the hash with </td></tr>
    <tr><td class="paramname">v</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9693facf6e039e9742d25bb169b13b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9693facf6e039e9742d25bb169b13b23">&#9670;&nbsp;</a></span>hash_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_range </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hashes a range of entries, returning the result. </p>
<p>This is equivalent to combining hashes of all entries within the range</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range to hash </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hashed value </dd></dl>

</div>
</div>
<a id="a30fcd550eed18391c0c378c3c1dcd802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30fcd550eed18391c0c378c3c1dcd802">&#9670;&nbsp;</a></span>hash_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr void bit::stl::hash_range </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hashes a range of entries. </p>
<p>This is equivalent to combining hashes of all entries within the range</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The seed to comine the hash with </td></tr>
    <tr><td class="paramname">first</td><td>The beginning of the range to hash </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range to hash </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f350703033effb94b5441aa17bccc02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f350703033effb94b5441aa17bccc02">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[1/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes a std::basic_string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash </dd></dl>

</div>
</div>
<a id="a21f07967eb5d5b849827db763987c8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f07967eb5d5b849827db763987c8fa">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[2/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Deleter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; T, Deleter &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes a unique_ptr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the ptr to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the unique_ptr </dd></dl>

</div>
</div>
<a id="ab931efe137588922f0e94656ecc1f973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab931efe137588922f0e94656ecc1f973">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[3/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html">basic_hashed_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the hash from a given <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html" title="The basic_hashed_string_view is a compile-time hashed wrapper around a non-owning string (basic_strin...">basic_hashed_string_view</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html" title="The basic_hashed_string_view is a compile-time hashed wrapper around a non-owning string (basic_strin...">basic_hashed_string_view</a> to retrieve the hash from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the string </dd></dl>

</div>
</div>
<a id="acbec1aa53918460d5481c91354848547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbec1aa53918460d5481c91354848547">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[4/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes a shared_ptr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the ptr to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the unique_ptr </dd></dl>

</div>
</div>
<a id="a8c9de76842f31be5040cc11a5d14ea85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9de76842f31be5040cc11a5d14ea85">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[5/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/db6/classbit_1_1stl_1_1basic__hashed__string.html">basic_hashed_string</a>&lt; CharT, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the hash from a given <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html" title="The basic_hashed_string_view is a compile-time hashed wrapper around a non-owning string (basic_strin...">basic_hashed_string_view</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the <a class="el" href="../../d3/d2f/classbit_1_1stl_1_1basic__hashed__string__view.html" title="The basic_hashed_string_view is a compile-time hashed wrapper around a non-owning string (basic_strin...">basic_hashed_string_view</a> to retrieve the hash from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the string </dd></dl>

</div>
</div>
<a id="a584a27d0ea529578cfc11814176d3c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584a27d0ea529578cfc11814176d3c77">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[6/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of a null pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a9403b1d1333c84854974c3a26930c43e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9403b1d1333c84854974c3a26930c43e">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[7/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given bool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a63eb167c6e9f2f72cb951d98e6b524aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63eb167c6e9f2f72cb951d98e6b524aa">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[8/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given char. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="aec0659afd18943b4b40ce92861a91508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0659afd18943b4b40ce92861a91508">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[9/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">signed char&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given signed char. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="aa66ae1724a126027297374c374b6ef6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66ae1724a126027297374c374b6ef6a">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[10/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given unsigned char. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="ad72f61cc97f25653194a936ee6b7dcf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad72f61cc97f25653194a936ee6b7dcf7">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[11/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">wchar_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given wchar_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a71c975f2d74a9235b487048cdf8379cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c975f2d74a9235b487048cdf8379cc">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[12/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">char16_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given char16_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a5d397ddf0317c66df2bfc01f46f8a5cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d397ddf0317c66df2bfc01f46f8a5cf">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[13/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">char32_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given char32_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a7154f4d7363372961d1e1994fa5bb7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7154f4d7363372961d1e1994fa5bb7c7">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[14/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given short. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a4a525d7be855171985a7193ecaecab76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a525d7be855171985a7193ecaecab76">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[15/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given unsigned short. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="ae0f0ceba5bc16b60258fbf0506bcae35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f0ceba5bc16b60258fbf0506bcae35">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[16/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given int. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a40a377050372166907861b21ab4b56c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a377050372166907861b21ab4b56c8">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[17/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given unsigned int. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a596483385fd40c05411995fb76e8cfa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596483385fd40c05411995fb76e8cfa5">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[18/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given long. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a45c2924b2f3e21ee85f0f514f59848e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c2924b2f3e21ee85f0f514f59848e4">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[19/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given unsigned long. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a5a97a54533bc83393bc21f5155c8f331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a97a54533bc83393bc21f5155c8f331">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[20/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given long long. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a16f32f66345d679e5031c7e7197dadc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f32f66345d679e5031c7e7197dadc4">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[21/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given unsigned long long. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a77fd58ad444420cb8b01a2832fdf496c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77fd58ad444420cb8b01a2832fdf496c">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[22/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given float. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="aa8add61aed3531d951d4e8cce1013363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8add61aed3531d951d4e8cce1013363">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[23/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a4e06a2ef7ee4eb339d240272fa4a3eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e06a2ef7ee4eb339d240272fa4a3eeb">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[24/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given long double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a4fcde1a36bf0d2e13786387e2b0150f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fcde1a36bf0d2e13786387e2b0150f1">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[25/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">T *const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a hash of the given pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a20db1218b612cc2ab37f8dcd38615a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20db1218b612cc2ab37f8dcd38615a72">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[26/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>val</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a hash of the given T array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="ad849248942ee4fdca3f4d0c9f5ecb2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad849248942ee4fdca3f4d0c9f5ecb2ee">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[27/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>val</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a hash of the given T array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the supplied value </dd></dl>

</div>
</div>
<a id="a034adf6da7e194b42f547fd9893c7eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034adf6da7e194b42f547fd9893c7eb8">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[28/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Enum &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">Enum&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes enum values. </p>
<dl class="section note"><dt>Note</dt><dd>This only participates in overload resolution if <code>std::is_enum</code> is <code>true</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the enum value to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash value of the enum </dd></dl>

</div>
</div>
<a id="a2fdef9b2830203ce585db5d761edd266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdef9b2830203ce585db5d761edd266">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[29/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes any given container. </p>
<p>The hash is computed as the combination of all the hashes within the container</p>
<dl class="section note"><dt>Note</dt><dd>This does not participate in overload resolution unless the container defines begin() and end()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>the container to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash value </dd></dl>

</div>
</div>
<a id="a5f4b0d5342a805f542d824ef4348b9af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4b0d5342a805f542d824ef4348b9af">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[30/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>pair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hashes a std::pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pair</td><td>the pair to hash </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d3887964130579e473a8c9ba19497f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3887964130579e473a8c9ba19497f6">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[31/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; Args... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hashes a tuple of entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>the tuple to hash </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a095457d6a448fa63db72891dda7ff055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095457d6a448fa63db72891dda7ff055">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[32/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hashes an initializer_list. </p>
<p>This is equivalent to calling hash_range( il.begin(), il.end() )</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>the initializer_list to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the initializer_list </dd></dl>

</div>
</div>
<a id="a83b254b21c3e850abecc2b128cb236b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b254b21c3e850abecc2b128cb236b3">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[33/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a hash of the underlying lazy, instantiating it if not already instantiated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to retrieve the has of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the lazy </dd></dl>

</div>
</div>
<a id="a0d4f9bef5f51b8b9fde39f5ab1b29212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4f9bef5f51b8b9fde39f5ab1b29212">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[34/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the hash from a given optional. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the optional to retrieve the hash from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the string </dd></dl>

</div>
</div>
<a id="a1c322fa5c383e7eeec10f36b8660b4f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c322fa5c383e7eeec10f36b8660b4f1">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[35/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the hash from a given expected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the expected to retrieve the hash from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the string </dd></dl>

</div>
</div>
<a id="ab9e8cbdbfe193a3f1e00930facf8de97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e8cbdbfe193a3f1e00930facf8de97">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[36/37]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the hash from a given expected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the expected to retrieve the hash from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> </dd></dl>

</div>
</div>
<a id="adca339d8647a8939fccfe7e0aef8b9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca339d8647a8939fccfe7e0aef8b9d7">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[37/37]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t bit::stl::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the hash from a given <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html" title="A wrapper around non-owned strings. ">basic_string_view</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the basic_ string_view to retrieve the hash from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the hash of the string </dd></dl>

</div>
</div>
<a id="a0b29133bb72579a5b279a23283c181d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b29133bb72579a5b279a23283c181d5">&#9670;&nbsp;</a></span>in_place()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d57/structbit_1_1stl_1_1in__place__tag.html">in_place_tag</a> bit::stl::in_place </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is a special disambiguation tag for variadic functions, used in any and optional. </p>
<dl class="section note"><dt>Note</dt><dd>Calling this function results in undefined behaviour. </dd></dl>

</div>
</div>
<a id="ad0dbaaca037aad1973f344bc1f6bbd81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0dbaaca037aad1973f344bc1f6bbd81">&#9670;&nbsp;</a></span>indeterminate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::indeterminate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tribool is indeterminate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tribool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>t</code> is <code>indeterminate</code> </dd></dl>

</div>
</div>
<a id="a415055bab1cfe18bfe0db940944bbf63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415055bab1cfe18bfe0db940944bbf63">&#9670;&nbsp;</a></span>invoke()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto bit::stl::invoke </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(detail::INVOKE(std::forward&lt; Func &gt;(function), std::forward&lt; Args &gt;(args)...))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke the Callable object <code>function</code> with the parameters <code>args</code>. </p>
<p>As by <code>INVOKE</code>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to be invoked </td></tr>
    <tr><td class="paramname">args</td><td>arguments to pass to <code>function</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a064c1a74dad23ef09ef9eaf423532596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064c1a74dad23ef09ef9eaf423532596">&#9670;&nbsp;</a></span>lcm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::common_type_t&lt;T,U&gt; bit::stl::lcm </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the least common multiple of the integers <code>m</code> and <code>n</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first integer value </td></tr>
    <tr><td class="paramname">b</td><td>the second integer value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The least-common multiple of <code>a</code> and <code>b</code> </dd></dl>

</div>
</div>
<a id="a2befb911f8c8b196b4ba81d50e20fb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2befb911f8c8b196b4ba81d50e20fb28">&#9670;&nbsp;</a></span>make_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = detail::array_autodeduce, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::stl::make_array </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt;  detail::array_return_type_t&lt; T, Args... &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make utility for creating a std::array. </p>
<p>If the return type is explicitly specified, no deduction take place; if the type is ommitted, the return type is the common type of all inputs.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the return type of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>the arguments for the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array containing the arguments </dd></dl>

</div>
</div>
<a id="a14e8cff3ee1637db01fb2e8c04a4a9a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e8cff3ee1637db01fb2e8c04a4a9a0">&#9670;&nbsp;</a></span>make_enum_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Enum &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d5/d36/classbit_1_1stl_1_1enum__range.html">enum_range</a>&lt;Enum&gt; bit::stl::make_enum_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes an enum range from a given. </p>
<dl class="section return"><dt>Returns</dt><dd>an enum range </dd></dl>

</div>
</div>
<a id="a6011c513ea463a3fafeb938c8105e788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6011c513ea463a3fafeb938c8105e788">&#9670;&nbsp;</a></span>make_error() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Error , std::enable_if_t&lt; std::is_enum&lt; Error &gt;::value &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dbd/classbit_1_1stl_1_1error__code.html">error_code</a> bit::stl::make_error </td>
          <td>(</td>
          <td class="paramtype">Error&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::error_category &amp;&#160;</td>
          <td class="paramname"><em>category</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td></td></tr>
    <tr><td class="paramname">category</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a35f197508e34e2051346698594a492cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f197508e34e2051346698594a492cf">&#9670;&nbsp;</a></span>make_error() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dbd/classbit_1_1stl_1_1error__code.html">error_code</a> bit::stl::make_error </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::error_category &amp;&#160;</td>
          <td class="paramname"><em>category</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td></td></tr>
    <tr><td class="paramname">category</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a698e301e29a1fb9d276b511a6eb71463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698e301e29a1fb9d276b511a6eb71463">&#9670;&nbsp;</a></span>make_expected() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt;std::decay_t&lt;T&gt; &gt; bit::stl::make_expected </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an expected object from <code>value</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to construct the optional from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8d93c28213541b7b8a28077d3bda144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d93c28213541b7b8a28077d3bda144">&#9670;&nbsp;</a></span>make_expected() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt;T&gt; bit::stl::make_expected </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an expected object of type <code>T</code> from the given <code>args</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to construct </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args...</td><td>the arguments to pass to <code>T's</code> constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2105804f0773cf2327a705e2424e1116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2105804f0773cf2327a705e2424e1116">&#9670;&nbsp;</a></span>make_expected() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt;T&gt; bit::stl::make_expected </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; U &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an expected object of type <code>T</code> from the given <code>il</code> <code>args</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to construct </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>the initializer list to pass </td></tr>
    <tr><td class="paramname">args...</td><td>the arguments to pass to <code>T's</code> constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9a49f6f584ffbee6b67c31087a95e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a49f6f584ffbee6b67c31087a95e03">&#9670;&nbsp;</a></span>make_from_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T bit::stl::make_from_tuple </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an object of type  T, using the elements of the tuple t as the arguments to the constructor. </p>
<p>Construct an object of type T, using the elements of the tuple t as the arguments to the constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>tuple whose elements to be used as arguments to the constructor of T </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The constructed T object</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to construct </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>tuple whose elements to be used as arguments to the constructor of T </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The constructed T object </dd></dl>

</div>
</div>
<a id="a6dc89f6045f99bceeb2727afc074f01f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc89f6045f99bceeb2727afc074f01f">&#9670;&nbsp;</a></span>make_key_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr tuple_element_iterator&lt;0,Iter&gt; bit::stl::make_key_iterator </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for making a tuple iterator that only iterates the first tuple element, which is the key in associative containers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tuple element iterator </dd></dl>

</div>
</div>
<a id="a6396e40adc7ac96d04f3a51b6fa869bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6396e40adc7ac96d04f3a51b6fa869bb">&#9670;&nbsp;</a></span>make_key_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::stl::make_key_range </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>sentinel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  range&lt; tuple_element_iterator&lt; 0, I &gt;, tuple_element_iterator&lt; 0, S &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a range from a given <code>iterator</code> <code>sentinel</code> pair iterating the first value of a given tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>the beginning of a range </td></tr>
    <tr><td class="paramname">sentinel</td><td>the end of a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced tuple_element range </dd></dl>

</div>
</div>
<a id="a44b291d11c52d94444f2625dcefb69da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b291d11c52d94444f2625dcefb69da">&#9670;&nbsp;</a></span>make_key_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::stl::make_key_range </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> -&gt;  decltype(make_key_range(r.begin(), r.end()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a key range from another range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a key range </dd></dl>

</div>
</div>
<a id="a9ea22e81640ef84b40a63a3aa0280a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea22e81640ef84b40a63a3aa0280a2f">&#9670;&nbsp;</a></span>make_lazy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt;T&gt; bit::stl::make_lazy </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a lazy type from the given arguments. </p>
<p>This is just a wrapper around lazy&lt;T&gt;( in_place, args... );</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>the arguments to forward to T's constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the lazy instance </dd></dl>

</div>
</div>
<a id="a769c3379a597a59899d35d552c8a14a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a769c3379a597a59899d35d552c8a14a2">&#9670;&nbsp;</a></span>make_lazy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt;T&gt; bit::stl::make_lazy </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; U &gt;&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a lazy type from the given arguments. </p>
<p>This is just a wrapper around lazy&lt;T&gt;( in_place, ilist, args... );</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ilist</td><td>an initializer list to forward to T's constructor </td></tr>
    <tr><td class="paramname">args</td><td>the arguments to forward to T's constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the lazy instance </dd></dl>

</div>
</div>
<a id="ad7844a4592038b7ba6cf898167d593d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7844a4592038b7ba6cf898167d593d4">&#9670;&nbsp;</a></span>make_lazy_generator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Ctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt;T&gt; bit::stl::make_lazy_generator </td>
          <td>(</td>
          <td class="paramtype">Ctor &amp;&amp;&#160;</td>
          <td class="paramname"><em>ctor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a lazy type that uses a generator function to generate the arguments that will be forwarded to T's constructor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the lazy to construct </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctor</td><td>A function that returns a tuple of arguments used to forward to T's constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly constructed lazy </dd></dl>

</div>
</div>
<a id="a06d87ecf8388e99a7309e1ba5d63ccd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d87ecf8388e99a7309e1ba5d63ccd2">&#9670;&nbsp;</a></span>make_move_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::stl::make_move_range </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>sentinel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  range&lt; std::move_iterator&lt; I &gt;, std::move_iterator&lt; S &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a movable range from a given <code>iterator</code> <code>sentinal</code> pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>the beginning of a range </td></tr>
    <tr><td class="paramname">sentinel</td><td>the end of a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced range </dd></dl>

</div>
</div>
<a id="a6fd4d204c6360d55e80c63411164decb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd4d204c6360d55e80c63411164decb">&#9670;&nbsp;</a></span>make_move_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::stl::make_move_range </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> -&gt;  decltype(make_move_range(r.begin(), r.end()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a reverse range from a given <code>iterator</code> <code>sentinal</code> pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irange</td><td>the range to deduce </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced range </dd></dl>

</div>
</div>
<a id="ad1685414ab5b9729175258024c1f034a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1685414ab5b9729175258024c1f034a">&#9670;&nbsp;</a></span>make_optional() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt;std::decay_t&lt;T&gt; &gt; bit::stl::make_optional </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an optional object from <code>value</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to construct the optional from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c586d69708cf2aa3d6196f5c38e5edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c586d69708cf2aa3d6196f5c38e5edd">&#9670;&nbsp;</a></span>make_optional() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt;T&gt; bit::stl::make_optional </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an optional object of type <code>T</code> from the given <code>args</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to construct </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args...</td><td>the arguments to pass to <code>T's</code> constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdcc7a61cae2e21593e248e3996eac0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcc7a61cae2e21593e248e3996eac0c">&#9670;&nbsp;</a></span>make_optional() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt;T&gt; bit::stl::make_optional </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; U &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an optional object of type <code>T</code> from the given <code>il</code> <code>args</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to construct </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>the initializer list to pass </td></tr>
    <tr><td class="paramname">args...</td><td>the arguments to pass to <code>T's</code> constructor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44311fa8af9c4066b4aff80158e37429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44311fa8af9c4066b4aff80158e37429">&#9670;&nbsp;</a></span>make_pointer_wrapper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/dde/classbit_1_1stl_1_1pointer__wrapper.html">pointer_wrapper</a>&lt;T&gt; bit::stl::make_pointer_wrapper </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a <a class="el" href="../../d6/dde/classbit_1_1stl_1_1pointer__wrapper.html" title="A wrapper type around a given type that allows it to be treated with pointer-semantics instead of ref...">pointer_wrapper</a> of the underlying type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args...</td><td>the arguments to forward </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f242f7df14fb4961730a553e96084b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f242f7df14fb4961730a553e96084b2">&#9670;&nbsp;</a></span>make_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr range&lt;I,S&gt; bit::stl::make_range </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>sentinel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a range from a given <code>iterator</code> <code>sentinel</code> pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>the beginning of a range </td></tr>
    <tr><td class="paramname">sentinel</td><td>the end of a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced range </dd></dl>

</div>
</div>
<a id="ab23ff312d0bacfde323a4daa9e92da83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab23ff312d0bacfde323a4daa9e92da83">&#9670;&nbsp;</a></span>make_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr Range&amp;&amp; bit::stl::make_range </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function acts as an identity function, and exists solely for completion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>a range to iterate over </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the original range </dd></dl>

</div>
</div>
<a id="a9d1273582ac976cd6a10f739435bbbeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1273582ac976cd6a10f739435bbbeb">&#9670;&nbsp;</a></span>make_reverse_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::stl::make_reverse_range </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> -&gt;  decltype(<a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a0f242f7df14fb4961730a553e96084b2">make_range</a>(r.rbegin(), r.rend()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a reverse range from a given <code>iterator</code> <code>sentinal</code> pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irange</td><td>the range to deduce </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced range </dd></dl>

</div>
</div>
<a id="a35c9069b3af0247530dfac78370c080c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c9069b3af0247530dfac78370c080c">&#9670;&nbsp;</a></span>make_tuple_element_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr tuple_element_iterator&lt;N,Iter&gt; bit::stl::make_tuple_element_iterator </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to type-deduce and make an iterator for iterating specific tuple elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tuple element iterator </dd></dl>

</div>
</div>
<a id="a7352c33e18cc147a4533ab1c7e1b9d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7352c33e18cc147a4533ab1c7e1b9d4d">&#9670;&nbsp;</a></span>make_tuple_element_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename I , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::stl::make_tuple_element_range </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>sentinel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  range&lt; tuple_element_iterator&lt; N, I &gt;, tuple_element_iterator&lt; N, S &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a range from a given <code>iterator</code> <code>sentinel</code> pair iterating values of a given tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>the beginning of a range </td></tr>
    <tr><td class="paramname">sentinel</td><td>the end of a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced tuple_element range </dd></dl>

</div>
</div>
<a id="a643bd0d2baac568efa86e1dbd43dea20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643bd0d2baac568efa86e1dbd43dea20">&#9670;&nbsp;</a></span>make_tuple_element_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::stl::make_tuple_element_range </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> -&gt;  decltype(make_tuple_element_range(r.begin(), r.end()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a tuple element range from a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced tuple_element range </dd></dl>

</div>
</div>
<a id="afc32653c70963f92afdb922bf41df9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc32653c70963f92afdb922bf41df9b9">&#9670;&nbsp;</a></span>make_value_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr tuple_element_iterator&lt;1,Iter&gt; bit::stl::make_value_iterator </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for making a tuple iterator that only iterates the second tuple element, which is the value in associative containers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>the iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tuple element iterator </dd></dl>

</div>
</div>
<a id="abc06ca40f67c1f36c538b129d94e1648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc06ca40f67c1f36c538b129d94e1648">&#9670;&nbsp;</a></span>make_value_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::stl::make_value_range </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>sentinel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  range&lt; tuple_element_iterator&lt; 1, I &gt;, tuple_element_iterator&lt; 1, S &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a range from a given <code>iterator</code> <code>sentinel</code> pair iterating the second value of a given tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>the beginning of a range </td></tr>
    <tr><td class="paramname">sentinel</td><td>the end of a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced tuple_element range </dd></dl>

</div>
</div>
<a id="a90b8bd09adc8ff6908217ee5b913628b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b8bd09adc8ff6908217ee5b913628b">&#9670;&nbsp;</a></span>make_value_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::stl::make_value_range </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> -&gt;  decltype(make_value_range(r.begin(), r.end()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a value range from another range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a value range </dd></dl>

</div>
</div>
<a id="a693d147e24e4c92faeec5a88502ad576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693d147e24e4c92faeec5a88502ad576">&#9670;&nbsp;</a></span>make_zip_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range0 , typename... RangeN&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bit::stl::make_zip_range </td>
          <td>(</td>
          <td class="paramtype">Range0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>r0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  range&lt; zip_iterator&lt; decltype(std::declval&lt; Range0 &gt;().begin()), decltype(std::declval&lt; RangeN &gt;().begin())... &gt;, zip_iterator&lt; decltype(std::declval&lt; Range0 &gt;().end()), decltype(std::declval&lt; RangeN &gt;().end())... &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a zip range from a selection of zip iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r0</td><td>the first range entry </td></tr>
    <tr><td class="paramname">rn</td><td>the rest of the range entries </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type-deduced range </dd></dl>

</div>
</div>
<a id="ae180be04635d8455a78ecd80b67ffe55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae180be04635d8455a78ecd80b67ffe55">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html">source_location</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html">source_location</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines inequality between two source_locations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html" title="Source location is a small, immutable type used for representing where retrieving information about w...">source_location</a> on the left side of the equation </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html" title="Source location is a small, immutable type used for representing where retrieving information about w...">source_location</a> on the right side of the equation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> is not equal to <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a3f719bc2f88ec95bdce7ac3bddaca536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f719bc2f88ec95bdce7ac3bddaca536">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two tribooleans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left entry </td></tr>
    <tr><td class="paramname">rhs</td><td>the right entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> has the same state as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="af8cacd7e1ce32b5e367aba95145f0c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8cacd7e1ce32b5e367aba95145f0c87">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5853dc716058231d67db9de2a050a251">indeterminate_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two tribooleans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left entry </td></tr>
    <tr><td class="paramname">rhs</td><td>the right entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> has the same state as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="aea0377caf58e0deaa3a8b13d34c398e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0377caf58e0deaa3a8b13d34c398e3">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5853dc716058231d67db9de2a050a251">indeterminate_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two tribooleans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left entry </td></tr>
    <tr><td class="paramname">rhs</td><td>the right entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> has the same state as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a7369b94edb1aa30603f6a4295280f810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7369b94edb1aa30603f6a4295280f810">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs inequality operation on two optionals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>an optional object on the left side to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>an optional object on the right side to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If bool(lhs) != bool(rhs), returns true Otherwise, if bool(lhs) == false, returns false Otherwise, returns *lhs == *rhs </dd></dl>

</div>
</div>
<a id="a0ef95178467c3eb83c8c648eb062333b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef95178467c3eb83c8c648eb062333b">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::ptrdiff_t Extent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs inequality comparison between all entries in the span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left span to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>the right span to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if the spans contain the same elements in the same order </dd></dl>

</div>
</div>
<a id="a0ace58348d55a83f9d4b81df99724d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ace58348d55a83f9d4b81df99724d33">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the left and right lazy elements together for inequality, using the underlying type's operator!=. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23e9db0b731c0f094b5fa4b5a248d46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e9db0b731c0f094b5fa4b5a248d46e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the left and right lazy elements together for inequality, using the underlying type's operator!=. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e3aa6b26006dfe792cf209e7705a192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3aa6b26006dfe792cf209e7705a192">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the left and right lazy elements together for inequality, using the underlying type's operator!=. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6ab3a3776017e9df8f4c376cd222a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ab3a3776017e9df8f4c376cd222a20">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two expected&lt;T&gt; values together for inequality equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the entry on the left of the equality </td></tr>
    <tr><td class="paramname">rhs</td><td>the entry on the right of the equality </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the two entries are not equal </dd></dl>

</div>
</div>
<a id="a2bf027ebca228450fda5cef3c2c60d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf027ebca228450fda5cef3c2c60d3c">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares inequality between the two basic_string_views. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left string view </td></tr>
    <tr><td class="paramname">rhs</td><td>the right string view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two strings are different </dd></dl>

</div>
</div>
<a id="aaf3e384d5ee5018ce420f7282e1d6992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3e384d5ee5018ce420f7282e1d6992">&#9670;&nbsp;</a></span>operator<() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs less-than operation on two optionals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>an optional object on the left side to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>an optional object on the right side to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If bool(rhs) == false, returns false Otherwise, if bool(lhs) == false, returns true Otherwise, returns *lhs &lt; *rhs </dd></dl>

</div>
</div>
<a id="af144d9c063aae932355474287ad14759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af144d9c063aae932355474287ad14759">&#9670;&nbsp;</a></span>operator<() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::ptrdiff_t Extent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexographically compares all entries in the span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left span to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>the right span to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the left span is lexographically less than the right </dd></dl>

</div>
</div>
<a id="a2ec221617391931c78569a3d2702b288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec221617391931c78569a3d2702b288">&#9670;&nbsp;</a></span>operator<() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if <code>lhs</code> &lt; <code>rhs</code>, using the underlying type's <code>operator&lt;</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad700e1ab6c0e622c376e2e9416e1c9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad700e1ab6c0e622c376e2e9416e1c9a9">&#9670;&nbsp;</a></span>operator<() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares <code>lhs</code> &lt; <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the entry on the left of the equality </td></tr>
    <tr><td class="paramname">rhs</td><td>the entry on the right of the equality </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> is less than <code>rhs</code> </dd></dl>

</div>
</div>
<a id="ac1aef677a777630f327620d039ec22bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1aef677a777630f327620d039ec22bd">&#9670;&nbsp;</a></span>operator<() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if <code>lhs</code> &lt; <code>rhs</code>, using the underlying type's <code>operator&lt;</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65343987a73506a66147635c970ce0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65343987a73506a66147635c970ce0af">&#9670;&nbsp;</a></span>operator<() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if <code>lhs</code> &lt; <code>rhs</code>, using the underlying type's <code>operator&lt;</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a415444efbcfeefad454cd010cc9b344f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415444efbcfeefad454cd010cc9b344f">&#9670;&nbsp;</a></span>operator<() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the left string is less than the right substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left string view </td></tr>
    <tr><td class="paramname">rhs</td><td>the right string view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the left string has a character less than the right string, or if the right string is shorter than the left string </dd></dl>

</div>
</div>
<a id="a1580085f3114393d66c277bc11cb5690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1580085f3114393d66c277bc11cb5690">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;CharT,Traits&gt;&amp; bit::stl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload for ostream output of <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html" title="A wrapper around non-owned strings. ">basic_string_view</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>The output stream to print to </td></tr>
    <tr><td class="paramname">str</td><td>the string to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the output stream </dd></dl>

</div>
</div>
<a id="adab66a890e7dea7249c4f81241f15753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab66a890e7dea7249c4f81241f15753">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs less-than or equal operation on two optionals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>an optional object on the left side to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>an optional object on the right side to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If bool(lhs) == false, returns true Otherwise, if bool(rhs) == false, returns false Otherwise, returns *lhs &lt;= *rhs </dd></dl>

</div>
</div>
<a id="acc3ac8246dbe309e18132145a226d5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3ac8246dbe309e18132145a226d5f9">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::ptrdiff_t Extent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexographically compares all entries in the span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left span to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>the right span to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the left span is lexographically less than or equal to the right entry </dd></dl>

</div>
</div>
<a id="aa8b3fce30938e6c628ae75e00352550e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b3fce30938e6c628ae75e00352550e">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares <code>lhs</code> &lt;= <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the entry on the left of the equality </td></tr>
    <tr><td class="paramname">rhs</td><td>the entry on the right of the equality </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> is less than or equal to <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a2694a1ebe40355527138a693adb98b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2694a1ebe40355527138a693adb98b3b">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if <code>lhs</code> &lt;= <code>rhs</code>, using the underlying type's <code>operator&lt;=</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbabcb48392e608812339f0f57526efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbabcb48392e608812339f0f57526efb">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if <code>lhs</code> &lt;= <code>rhs</code>, using the underlying type's <code>operator&lt;=</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92f0f2791bf66cf30bdf5311f48f6f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f0f2791bf66cf30bdf5311f48f6f3e">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if <code>lhs</code> &lt;= <code>rhs</code>, using the underlying type's <code>operator&lt;=</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa26180d86b4a63447cb01a783830c132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26180d86b4a63447cb01a783830c132">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a4f2a34d2c6d7bbb220c7d8ac2a79c458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2a34d2c6d7bbb220c7d8ac2a79c458">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html">source_location</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html">source_location</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines equality between two source_locations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html" title="Source location is a small, immutable type used for representing where retrieving information about w...">source_location</a> on the left side of the equation </td></tr>
    <tr><td class="paramname">rhs</td><td>The <a class="el" href="../../d6/d2f/classbit_1_1stl_1_1source__location.html" title="Source location is a small, immutable type used for representing where retrieving information about w...">source_location</a> on the right side of the equation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> is equal to <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a1f8dec5bd2fc486c8d2144b3d7f17943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8dec5bd2fc486c8d2144b3d7f17943">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two tribooleans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left entry </td></tr>
    <tr><td class="paramname">rhs</td><td>the right entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> has the same state as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a83a4151c0d15bef2c65b5d64a2ec2975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a4151c0d15bef2c65b5d64a2ec2975">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5853dc716058231d67db9de2a050a251">indeterminate_t</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two tribooleans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left entry </td></tr>
    <tr><td class="paramname">rhs</td><td>the right entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> has the same state as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a894b424c1fe9bf6f27b776ecefd8300f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894b424c1fe9bf6f27b776ecefd8300f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dc9/classbit_1_1stl_1_1tribool.html">tribool</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d7e/namespacebit_1_1stl.html#a5853dc716058231d67db9de2a050a251">indeterminate_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison between two tribooleans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left entry </td></tr>
    <tr><td class="paramname">rhs</td><td>the right entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> has the same state as <code>rhs</code> </dd></dl>

</div>
</div>
<a id="aaaaba5e942c77826b17b02c17b1b11de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaaba5e942c77826b17b02c17b1b11de">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs equality operation on two optionals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>an optional object on the left side to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>an optional object on the right side to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If bool(lhs) != bool(rhs), returns false Otherwise, if bool(lhs) == false, returns true Otherwise, returns *lhs == *rhs </dd></dl>

</div>
</div>
<a id="a949bcb6cedbc08ec6aac45fc2ed17e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949bcb6cedbc08ec6aac45fc2ed17e51">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::ptrdiff_t Extent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs equality comparison between all entries in the span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left span to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>the right span to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the spans contain the same elements in the same order </dd></dl>

</div>
</div>
<a id="a69c2c4bcf46f871a44c4d39ae1f829c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c2c4bcf46f871a44c4d39ae1f829c4">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the left and right lazy elements together for equality, using the underlying type's operator==. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef7b385636356ef469ca965df7b6372c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef7b385636356ef469ca965df7b6372c">&#9670;&nbsp;</a></span>operator==() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the left and right lazy elements together for equality, using the underlying type's operator==. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa3a169fb3e7d89f16f12ea8d5ccd0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3a169fb3e7d89f16f12ea8d5ccd0a9">&#9670;&nbsp;</a></span>operator==() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the left and right lazy elements together for equality, using the underlying type's operator==. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa57b69bbf1e9222a69223b719d8337bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57b69bbf1e9222a69223b719d8337bf">&#9670;&nbsp;</a></span>operator==() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two expected&lt;T&gt; values together for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the entry on the left of the equality </td></tr>
    <tr><td class="paramname">rhs</td><td>the entry on the right of the equality </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the two entries are equal </dd></dl>

</div>
</div>
<a id="aba40e0a952f28127626caa2438700a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba40e0a952f28127626caa2438700a5c">&#9670;&nbsp;</a></span>operator==() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares equality between the two basic_string_views. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left string view </td></tr>
    <tr><td class="paramname">rhs</td><td>the right string view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two strings are the same </dd></dl>

</div>
</div>
<a id="a9fa00301df0b90006322ef8fd5fc4f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa00301df0b90006322ef8fd5fc4f7d">&#9670;&nbsp;</a></span>operator>() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs greater-than operation on two optionals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>an optional object on the left side to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>an optional object on the right side to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If bool(lhs) == false, returns false Otherwise, if bool(rhs) == false, returns true Otherwise, returns *lhs &gt; *rhs </dd></dl>

</div>
</div>
<a id="a46d826a3a556768ab643121194d3d5d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d826a3a556768ab643121194d3d5d3">&#9670;&nbsp;</a></span>operator>() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::ptrdiff_t Extent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexographically compares all entries in the span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left span to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>the right span to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the left span is lexographically greater than the right entry </dd></dl>

</div>
</div>
<a id="a5cb28f08d7f257bf2db0dc9aa495a715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb28f08d7f257bf2db0dc9aa495a715">&#9670;&nbsp;</a></span>operator>() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares <code>lhs</code> &gt; <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the entry on the left of the equality </td></tr>
    <tr><td class="paramname">rhs</td><td>the entry on the right of the equality </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> is greater than <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a746813e83ffff1853ff45291ea291a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746813e83ffff1853ff45291ea291a8b">&#9670;&nbsp;</a></span>operator>() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if <code>lhs</code> &gt; <code>rhs</code>, using the underlying type's <code>operator&gt;</code> </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f76db3bf68fa12d31cefd4888223bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f76db3bf68fa12d31cefd4888223bf9">&#9670;&nbsp;</a></span>operator>() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if <code>lhs</code> &gt; <code>rhs</code>, using the underlying type's <code>operator&gt;</code> </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a775f362ae0a51d2f0125e1168a2fc590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775f362ae0a51d2f0125e1168a2fc590">&#9670;&nbsp;</a></span>operator>() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if <code>lhs</code> &gt; <code>rhs</code>, using the underlying type's <code>operator&gt;</code> </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69b91bebb63c963188f090691677e815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b91bebb63c963188f090691677e815">&#9670;&nbsp;</a></span>operator>() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aba083b0665196f2dab5de18013deed76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba083b0665196f2dab5de18013deed76">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs greater-than or equal operation on two optionals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>an optional object on the left side to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>an optional object on the right side to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If bool(rhs) == false, returns true Otherwise, if bool(lhs) == false, returns false Otherwise, returns *lhs &lt;= *rhs </dd></dl>

</div>
</div>
<a id="a4850b6a62191725450ad5a4c37dfdbcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4850b6a62191725450ad5a4c37dfdbcd">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::ptrdiff_t Extent&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d30/classbit_1_1stl_1_1span.html">span</a>&lt; T, Extent &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexographically compares all entries in the span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left span to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>the right span to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the left span is lexographically greater than or equal to the right entry </dd></dl>

</div>
</div>
<a id="a5cec8f9db40b0863a90f4f486eb1456c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cec8f9db40b0863a90f4f486eb1456c">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bit::stl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/da7/classbit_1_1stl_1_1expected.html">expected</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares <code>lhs</code> &gt; <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the entry on the left of the equality </td></tr>
    <tr><td class="paramname">rhs</td><td>the entry on the right of the equality </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> is greater than or equal to <code>rhs</code> </dd></dl>

</div>
</div>
<a id="a7c8e6565cc41cde9536df9c09e51d778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8e6565cc41cde9536df9c09e51d778">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if <code>lhs</code> &gt;= <code>rhs</code>, using the underlying type's <code>operator&gt;=</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a436993f5969646f1923b2f6f6f8e8c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436993f5969646f1923b2f6f6f8e8c11">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if <code>lhs</code> &gt;= <code>rhs</code>, using the underlying type's <code>operator&gt;=</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a001b72215d0b5e3721b12564542d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a001b72215d0b5e3721b12564542d95">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if <code>lhs</code> &gt;= <code>rhs</code>, using the underlying type's <code>operator&gt;=</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This will instantiate the lazy if it was not previously instantiated</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left argument </td></tr>
    <tr><td class="paramname">rhs</td><td>the right argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab692e38a5d9027b524c7532b189d8ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab692e38a5d9027b524c7532b189d8ff1">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bit::stl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d67/classbit_1_1stl_1_1basic__string__view.html">basic_string_view</a>&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a0e2212f7f9bb1f2ffa862da0cbcd2301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2212f7f9bb1f2ffa862da0cbcd2301">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bit::stl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/dbb/classbit_1_1stl_1_1lazy.html">lazy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of the lazy from <code>lhs</code> and <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left lazy to swap </td></tr>
    <tr><td class="paramname">rhs</td><td>the right lazy to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39fc15967879a2d062e81cf59e4b80c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39fc15967879a2d062e81cf59e4b80c5">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bit::stl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d1d/classbit_1_1stl_1_1optional.html">optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps <code>lhs</code> and <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left optional to swap </td></tr>
    <tr><td class="paramname">rhs</td><td>the right optional to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9807ce838e4fd230b03f9796f2203888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9807ce838e4fd230b03f9796f2203888">&#9670;&nbsp;</a></span>to_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uintptr_t bit::stl::to_address </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a pointer <code>ptr</code> into an integral type representing the address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>the pointer to convert to an integral value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the numeric address of the given pointer </dd></dl>

</div>
</div>
<a id="a0c54cd7406cc5388e67323491e900826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c54cd7406cc5388e67323491e900826">&#9670;&nbsp;</a></span>to_array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt;T,N&gt; bit::stl::to_array </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility to convert raw arrays to std::array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>a lvalue reference to an array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the std::array </dd></dl>

</div>
</div>
<a id="a966bc186dbddc974625ca051e42d2aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a966bc186dbddc974625ca051e42d2aed">&#9670;&nbsp;</a></span>to_array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt;T,N&gt; bit::stl::to_array </td>
          <td>(</td>
          <td class="paramtype">T(&amp;&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[N]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility to convert raw arrays to std::array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>a rvalue reference to an array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the std::array </dd></dl>

</div>
</div>
<a id="a5ceda0466f45a09b16591ccb2de29ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ceda0466f45a09b16591ccb2de29ab4">&#9670;&nbsp;</a></span>uninitialized_construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bit::stl::uninitialized_construct </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an instance of type <code>T</code> with the given <code>args</code> at the memory addresses in the given range [<code>first</code>, <code>last</code> ) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the start of the range of the elements to copy </td></tr>
    <tr><td class="paramname">last</td><td>the end of the range of the elements to copy </td></tr>
    <tr><td class="paramname">args...</td><td>The arguments to supply to the </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d0dcea6d5a9e100bea41a7fdc6ef7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0dcea6d5a9e100bea41a7fdc6ef7d2">&#9670;&nbsp;</a></span>uninitialized_construct_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* bit::stl::uninitialized_construct_at </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an instance of type <code>T</code> with the given <code>args</code> at the memory location specified in <code>ptr</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The memory location to construct into </td></tr>
    <tr><td class="paramname">args...</td><td>The arguments to supply to T's constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the initialized memory (cast of <code>ptr</code>) </dd></dl>

</div>
</div>
<a id="a504a3790a931e2137cecd7bc9f53deb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504a3790a931e2137cecd7bc9f53deb2">&#9670;&nbsp;</a></span>uninitialized_construct_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename Size , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator bit::stl::uninitialized_construct_n </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Size&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an instance of type <code>T</code> with the given <code>args</code> at the memory addresses in the given range [<code>first</code>, <code>first</code> + <code>n</code> ) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the start of the range of the elements to copy </td></tr>
    <tr><td class="paramname">n</td><td>the number of entries to construct </td></tr>
    <tr><td class="paramname">args...</td><td>The arguments to supply to the </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada62bae66a9ed451d9d7078146d9a8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada62bae66a9ed451d9d7078146d9a8b1">&#9670;&nbsp;</a></span>uninitialized_copy_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* bit::stl::uninitialized_copy_at </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructs an instance of type <code>T</code> in the given memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The memory location to construct into </td></tr>
    <tr><td class="paramname">other</td><td>The instance to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the initialized memory (cast of <code>ptr</code>) </dd></dl>

</div>
</div>
<a id="a29c81704abd3426d4a4f8d644bc9cca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c81704abd3426d4a4f8d644bc9cca9">&#9670;&nbsp;</a></span>uninitialized_default_construct_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* bit::stl::uninitialized_default_construct_at </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructs an instance of type <code>T</code> in the given memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The memory location to construct into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the initialized memory (cast of <code>ptr</code>) </dd></dl>

</div>
</div>
<a id="abc02d5f264a6272ee144f7d279f6cedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc02d5f264a6272ee144f7d279f6cedc">&#9670;&nbsp;</a></span>uninitialized_move_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* bit::stl::uninitialized_move_at </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructs an instance of type <code>T</code> in the given memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The memory location to construct into </td></tr>
    <tr><td class="paramname">other</td><td>The instance to move </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the initialized memory (cast of <code>ptr</code>) </dd></dl>

</div>
</div>
<a id="a24c4467d16ff80fbabb5ac8bb35f8975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c4467d16ff80fbabb5ac8bb35f8975">&#9670;&nbsp;</a></span>uninitialized_tuple_construct_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* bit::stl::uninitialized_tuple_construct_at </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an instance of type <code>T</code> with the given <code>tuple</code> at the memory location specified in <code>ptr</code>. </p>
<p>This forwards the arguments from the <code>tuple</code> to the constructor of T, as if by calling make_from_tuple</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The memory location to construct into </td></tr>
    <tr><td class="paramname">tuple</td><td>The tuple containing arguments to forward to T </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer ot the initialzied memory (cast of <code>ptr</code>) </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
